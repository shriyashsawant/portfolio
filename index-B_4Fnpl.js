(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const o of document.querySelectorAll('link[rel="modulepreload"]'))
        r(o);
    new MutationObserver(o => {
        for (const l of o)
            if (l.type === "childList")
                for (const u of l.addedNodes)
                    u.tagName === "LINK" && u.rel === "modulepreload" && r(u)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(o) {
        const l = {};
        return o.integrity && (l.integrity = o.integrity),
        o.referrerPolicy && (l.referrerPolicy = o.referrerPolicy),
        o.crossOrigin === "use-credentials" ? l.credentials = "include" : o.crossOrigin === "anonymous" ? l.credentials = "omit" : l.credentials = "same-origin",
        l
    }
    function r(o) {
        if (o.ep)
            return;
        o.ep = !0;
        const l = n(o);
        fetch(o.href, l)
    }
}
)();
var hu = {
    exports: {}
}
  , Ma = {}
  , pu = {
    exports: {}
}
  , ft = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tp;
function K0() {
    if (Tp)
        return ft;
    Tp = 1;
    var s = Symbol.for("react.element")
      , e = Symbol.for("react.portal")
      , n = Symbol.for("react.fragment")
      , r = Symbol.for("react.strict_mode")
      , o = Symbol.for("react.profiler")
      , l = Symbol.for("react.provider")
      , u = Symbol.for("react.context")
      , f = Symbol.for("react.forward_ref")
      , m = Symbol.for("react.suspense")
      , p = Symbol.for("react.memo")
      , v = Symbol.for("react.lazy")
      , _ = Symbol.iterator;
    function x(U) {
        return U === null || typeof U != "object" ? null : (U = _ && U[_] || U["@@iterator"],
        typeof U == "function" ? U : null)
    }
    var S = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , E = Object.assign
      , T = {};
    function y(U, ie, ke) {
        this.props = U,
        this.context = ie,
        this.refs = T,
        this.updater = ke || S
    }
    y.prototype.isReactComponent = {},
    y.prototype.setState = function(U, ie) {
        if (typeof U != "object" && typeof U != "function" && U != null)
            throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, U, ie, "setState")
    }
    ,
    y.prototype.forceUpdate = function(U) {
        this.updater.enqueueForceUpdate(this, U, "forceUpdate")
    }
    ;
    function g() {}
    g.prototype = y.prototype;
    function N(U, ie, ke) {
        this.props = U,
        this.context = ie,
        this.refs = T,
        this.updater = ke || S
    }
    var L = N.prototype = new g;
    L.constructor = N,
    E(L, y.prototype),
    L.isPureReactComponent = !0;
    var C = Array.isArray
      , H = Object.prototype.hasOwnProperty
      , k = {
        current: null
    }
      , F = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function j(U, ie, ke) {
        var ze, Q = {}, me = null, pe = null;
        if (ie != null)
            for (ze in ie.ref !== void 0 && (pe = ie.ref),
            ie.key !== void 0 && (me = "" + ie.key),
            ie)
                H.call(ie, ze) && !F.hasOwnProperty(ze) && (Q[ze] = ie[ze]);
        var Ce = arguments.length - 2;
        if (Ce === 1)
            Q.children = ke;
        else if (1 < Ce) {
            for (var Pe = Array(Ce), Ke = 0; Ke < Ce; Ke++)
                Pe[Ke] = arguments[Ke + 2];
            Q.children = Pe
        }
        if (U && U.defaultProps)
            for (ze in Ce = U.defaultProps,
            Ce)
                Q[ze] === void 0 && (Q[ze] = Ce[ze]);
        return {
            $$typeof: s,
            type: U,
            key: me,
            ref: pe,
            props: Q,
            _owner: k.current
        }
    }
    function b(U, ie) {
        return {
            $$typeof: s,
            type: U.type,
            key: ie,
            ref: U.ref,
            props: U.props,
            _owner: U._owner
        }
    }
    function R(U) {
        return typeof U == "object" && U !== null && U.$$typeof === s
    }
    function I(U) {
        var ie = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + U.replace(/[=:]/g, function(ke) {
            return ie[ke]
        })
    }
    var oe = /\/+/g;
    function se(U, ie) {
        return typeof U == "object" && U !== null && U.key != null ? I("" + U.key) : ie.toString(36)
    }
    function ce(U, ie, ke, ze, Q) {
        var me = typeof U;
        (me === "undefined" || me === "boolean") && (U = null);
        var pe = !1;
        if (U === null)
            pe = !0;
        else
            switch (me) {
            case "string":
            case "number":
                pe = !0;
                break;
            case "object":
                switch (U.$$typeof) {
                case s:
                case e:
                    pe = !0
                }
            }
        if (pe)
            return pe = U,
            Q = Q(pe),
            U = ze === "" ? "." + se(pe, 0) : ze,
            C(Q) ? (ke = "",
            U != null && (ke = U.replace(oe, "$&/") + "/"),
            ce(Q, ie, ke, "", function(Ke) {
                return Ke
            })) : Q != null && (R(Q) && (Q = b(Q, ke + (!Q.key || pe && pe.key === Q.key ? "" : ("" + Q.key).replace(oe, "$&/") + "/") + U)),
            ie.push(Q)),
            1;
        if (pe = 0,
        ze = ze === "" ? "." : ze + ":",
        C(U))
            for (var Ce = 0; Ce < U.length; Ce++) {
                me = U[Ce];
                var Pe = ze + se(me, Ce);
                pe += ce(me, ie, ke, Pe, Q)
            }
        else if (Pe = x(U),
        typeof Pe == "function")
            for (U = Pe.call(U),
            Ce = 0; !(me = U.next()).done; )
                me = me.value,
                Pe = ze + se(me, Ce++),
                pe += ce(me, ie, ke, Pe, Q);
        else if (me === "object")
            throw ie = String(U),
            Error("Objects are not valid as a React child (found: " + (ie === "[object Object]" ? "object with keys {" + Object.keys(U).join(", ") + "}" : ie) + "). If you meant to render a collection of children, use an array instead.");
        return pe
    }
    function ne(U, ie, ke) {
        if (U == null)
            return U;
        var ze = []
          , Q = 0;
        return ce(U, ze, "", "", function(me) {
            return ie.call(ke, me, Q++)
        }),
        ze
    }
    function ae(U) {
        if (U._status === -1) {
            var ie = U._result;
            ie = ie(),
            ie.then(function(ke) {
                (U._status === 0 || U._status === -1) && (U._status = 1,
                U._result = ke)
            }, function(ke) {
                (U._status === 0 || U._status === -1) && (U._status = 2,
                U._result = ke)
            }),
            U._status === -1 && (U._status = 0,
            U._result = ie)
        }
        if (U._status === 1)
            return U._result.default;
        throw U._result
    }
    var de = {
        current: null
    }
      , V = {
        transition: null
    }
      , ue = {
        ReactCurrentDispatcher: de,
        ReactCurrentBatchConfig: V,
        ReactCurrentOwner: k
    };
    function re() {
        throw Error("act(...) is not supported in production builds of React.")
    }
    return ft.Children = {
        map: ne,
        forEach: function(U, ie, ke) {
            ne(U, function() {
                ie.apply(this, arguments)
            }, ke)
        },
        count: function(U) {
            var ie = 0;
            return ne(U, function() {
                ie++
            }),
            ie
        },
        toArray: function(U) {
            return ne(U, function(ie) {
                return ie
            }) || []
        },
        only: function(U) {
            if (!R(U))
                throw Error("React.Children.only expected to receive a single React element child.");
            return U
        }
    },
    ft.Component = y,
    ft.Fragment = n,
    ft.Profiler = o,
    ft.PureComponent = N,
    ft.StrictMode = r,
    ft.Suspense = m,
    ft.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ue,
    ft.act = re,
    ft.cloneElement = function(U, ie, ke) {
        if (U == null)
            throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + U + ".");
        var ze = E({}, U.props)
          , Q = U.key
          , me = U.ref
          , pe = U._owner;
        if (ie != null) {
            if (ie.ref !== void 0 && (me = ie.ref,
            pe = k.current),
            ie.key !== void 0 && (Q = "" + ie.key),
            U.type && U.type.defaultProps)
                var Ce = U.type.defaultProps;
            for (Pe in ie)
                H.call(ie, Pe) && !F.hasOwnProperty(Pe) && (ze[Pe] = ie[Pe] === void 0 && Ce !== void 0 ? Ce[Pe] : ie[Pe])
        }
        var Pe = arguments.length - 2;
        if (Pe === 1)
            ze.children = ke;
        else if (1 < Pe) {
            Ce = Array(Pe);
            for (var Ke = 0; Ke < Pe; Ke++)
                Ce[Ke] = arguments[Ke + 2];
            ze.children = Ce
        }
        return {
            $$typeof: s,
            type: U.type,
            key: Q,
            ref: me,
            props: ze,
            _owner: pe
        }
    }
    ,
    ft.createContext = function(U) {
        return U = {
            $$typeof: u,
            _currentValue: U,
            _currentValue2: U,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
        },
        U.Provider = {
            $$typeof: l,
            _context: U
        },
        U.Consumer = U
    }
    ,
    ft.createElement = j,
    ft.createFactory = function(U) {
        var ie = j.bind(null, U);
        return ie.type = U,
        ie
    }
    ,
    ft.createRef = function() {
        return {
            current: null
        }
    }
    ,
    ft.forwardRef = function(U) {
        return {
            $$typeof: f,
            render: U
        }
    }
    ,
    ft.isValidElement = R,
    ft.lazy = function(U) {
        return {
            $$typeof: v,
            _payload: {
                _status: -1,
                _result: U
            },
            _init: ae
        }
    }
    ,
    ft.memo = function(U, ie) {
        return {
            $$typeof: p,
            type: U,
            compare: ie === void 0 ? null : ie
        }
    }
    ,
    ft.startTransition = function(U) {
        var ie = V.transition;
        V.transition = {};
        try {
            U()
        } finally {
            V.transition = ie
        }
    }
    ,
    ft.unstable_act = re,
    ft.useCallback = function(U, ie) {
        return de.current.useCallback(U, ie)
    }
    ,
    ft.useContext = function(U) {
        return de.current.useContext(U)
    }
    ,
    ft.useDebugValue = function() {}
    ,
    ft.useDeferredValue = function(U) {
        return de.current.useDeferredValue(U)
    }
    ,
    ft.useEffect = function(U, ie) {
        return de.current.useEffect(U, ie)
    }
    ,
    ft.useId = function() {
        return de.current.useId()
    }
    ,
    ft.useImperativeHandle = function(U, ie, ke) {
        return de.current.useImperativeHandle(U, ie, ke)
    }
    ,
    ft.useInsertionEffect = function(U, ie) {
        return de.current.useInsertionEffect(U, ie)
    }
    ,
    ft.useLayoutEffect = function(U, ie) {
        return de.current.useLayoutEffect(U, ie)
    }
    ,
    ft.useMemo = function(U, ie) {
        return de.current.useMemo(U, ie)
    }
    ,
    ft.useReducer = function(U, ie, ke) {
        return de.current.useReducer(U, ie, ke)
    }
    ,
    ft.useRef = function(U) {
        return de.current.useRef(U)
    }
    ,
    ft.useState = function(U) {
        return de.current.useState(U)
    }
    ,
    ft.useSyncExternalStore = function(U, ie, ke) {
        return de.current.useSyncExternalStore(U, ie, ke)
    }
    ,
    ft.useTransition = function() {
        return de.current.useTransition()
    }
    ,
    ft.version = "18.3.1",
    ft
}
var Ap;
function Hd() {
    return Ap || (Ap = 1,
    pu.exports = K0()),
    pu.exports
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cp;
function Q0() {
    if (Cp)
        return Ma;
    Cp = 1;
    var s = Hd()
      , e = Symbol.for("react.element")
      , n = Symbol.for("react.fragment")
      , r = Object.prototype.hasOwnProperty
      , o = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
      , l = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function u(f, m, p) {
        var v, _ = {}, x = null, S = null;
        p !== void 0 && (x = "" + p),
        m.key !== void 0 && (x = "" + m.key),
        m.ref !== void 0 && (S = m.ref);
        for (v in m)
            r.call(m, v) && !l.hasOwnProperty(v) && (_[v] = m[v]);
        if (f && f.defaultProps)
            for (v in m = f.defaultProps,
            m)
                _[v] === void 0 && (_[v] = m[v]);
        return {
            $$typeof: e,
            type: f,
            key: x,
            ref: S,
            props: _,
            _owner: o.current
        }
    }
    return Ma.Fragment = n,
    Ma.jsx = u,
    Ma.jsxs = u,
    Ma
}
var Rp;
function Z0() {
    return Rp || (Rp = 1,
    hu.exports = Q0()),
    hu.exports
}
var O = Z0()
  , ln = Hd()
  , qo = {}
  , mu = {
    exports: {}
}
  , Ln = {}
  , gu = {
    exports: {}
}
  , _u = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bp;
function e_() {
    return bp || (bp = 1,
    function(s) {
        function e(V, ue) {
            var re = V.length;
            V.push(ue);
            e: for (; 0 < re; ) {
                var U = re - 1 >>> 1
                  , ie = V[U];
                if (0 < o(ie, ue))
                    V[U] = ue,
                    V[re] = ie,
                    re = U;
                else
                    break e
            }
        }
        function n(V) {
            return V.length === 0 ? null : V[0]
        }
        function r(V) {
            if (V.length === 0)
                return null;
            var ue = V[0]
              , re = V.pop();
            if (re !== ue) {
                V[0] = re;
                e: for (var U = 0, ie = V.length, ke = ie >>> 1; U < ke; ) {
                    var ze = 2 * (U + 1) - 1
                      , Q = V[ze]
                      , me = ze + 1
                      , pe = V[me];
                    if (0 > o(Q, re))
                        me < ie && 0 > o(pe, Q) ? (V[U] = pe,
                        V[me] = re,
                        U = me) : (V[U] = Q,
                        V[ze] = re,
                        U = ze);
                    else if (me < ie && 0 > o(pe, re))
                        V[U] = pe,
                        V[me] = re,
                        U = me;
                    else
                        break e
                }
            }
            return ue
        }
        function o(V, ue) {
            var re = V.sortIndex - ue.sortIndex;
            return re !== 0 ? re : V.id - ue.id
        }
        if (typeof performance == "object" && typeof performance.now == "function") {
            var l = performance;
            s.unstable_now = function() {
                return l.now()
            }
        } else {
            var u = Date
              , f = u.now();
            s.unstable_now = function() {
                return u.now() - f
            }
        }
        var m = []
          , p = []
          , v = 1
          , _ = null
          , x = 3
          , S = !1
          , E = !1
          , T = !1
          , y = typeof setTimeout == "function" ? setTimeout : null
          , g = typeof clearTimeout == "function" ? clearTimeout : null
          , N = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function L(V) {
            for (var ue = n(p); ue !== null; ) {
                if (ue.callback === null)
                    r(p);
                else if (ue.startTime <= V)
                    r(p),
                    ue.sortIndex = ue.expirationTime,
                    e(m, ue);
                else
                    break;
                ue = n(p)
            }
        }
        function C(V) {
            if (T = !1,
            L(V),
            !E)
                if (n(m) !== null)
                    E = !0,
                    ae(H);
                else {
                    var ue = n(p);
                    ue !== null && de(C, ue.startTime - V)
                }
        }
        function H(V, ue) {
            E = !1,
            T && (T = !1,
            g(j),
            j = -1),
            S = !0;
            var re = x;
            try {
                for (L(ue),
                _ = n(m); _ !== null && (!(_.expirationTime > ue) || V && !I()); ) {
                    var U = _.callback;
                    if (typeof U == "function") {
                        _.callback = null,
                        x = _.priorityLevel;
                        var ie = U(_.expirationTime <= ue);
                        ue = s.unstable_now(),
                        typeof ie == "function" ? _.callback = ie : _ === n(m) && r(m),
                        L(ue)
                    } else
                        r(m);
                    _ = n(m)
                }
                if (_ !== null)
                    var ke = !0;
                else {
                    var ze = n(p);
                    ze !== null && de(C, ze.startTime - ue),
                    ke = !1
                }
                return ke
            } finally {
                _ = null,
                x = re,
                S = !1
            }
        }
        var k = !1
          , F = null
          , j = -1
          , b = 5
          , R = -1;
        function I() {
            return !(s.unstable_now() - R < b)
        }
        function oe() {
            if (F !== null) {
                var V = s.unstable_now();
                R = V;
                var ue = !0;
                try {
                    ue = F(!0, V)
                } finally {
                    ue ? se() : (k = !1,
                    F = null)
                }
            } else
                k = !1
        }
        var se;
        if (typeof N == "function")
            se = function() {
                N(oe)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var ce = new MessageChannel
              , ne = ce.port2;
            ce.port1.onmessage = oe,
            se = function() {
                ne.postMessage(null)
            }
        } else
            se = function() {
                y(oe, 0)
            }
            ;
        function ae(V) {
            F = V,
            k || (k = !0,
            se())
        }
        function de(V, ue) {
            j = y(function() {
                V(s.unstable_now())
            }, ue)
        }
        s.unstable_IdlePriority = 5,
        s.unstable_ImmediatePriority = 1,
        s.unstable_LowPriority = 4,
        s.unstable_NormalPriority = 3,
        s.unstable_Profiling = null,
        s.unstable_UserBlockingPriority = 2,
        s.unstable_cancelCallback = function(V) {
            V.callback = null
        }
        ,
        s.unstable_continueExecution = function() {
            E || S || (E = !0,
            ae(H))
        }
        ,
        s.unstable_forceFrameRate = function(V) {
            0 > V || 125 < V ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < V ? Math.floor(1e3 / V) : 5
        }
        ,
        s.unstable_getCurrentPriorityLevel = function() {
            return x
        }
        ,
        s.unstable_getFirstCallbackNode = function() {
            return n(m)
        }
        ,
        s.unstable_next = function(V) {
            switch (x) {
            case 1:
            case 2:
            case 3:
                var ue = 3;
                break;
            default:
                ue = x
            }
            var re = x;
            x = ue;
            try {
                return V()
            } finally {
                x = re
            }
        }
        ,
        s.unstable_pauseExecution = function() {}
        ,
        s.unstable_requestPaint = function() {}
        ,
        s.unstable_runWithPriority = function(V, ue) {
            switch (V) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                V = 3
            }
            var re = x;
            x = V;
            try {
                return ue()
            } finally {
                x = re
            }
        }
        ,
        s.unstable_scheduleCallback = function(V, ue, re) {
            var U = s.unstable_now();
            switch (typeof re == "object" && re !== null ? (re = re.delay,
            re = typeof re == "number" && 0 < re ? U + re : U) : re = U,
            V) {
            case 1:
                var ie = -1;
                break;
            case 2:
                ie = 250;
                break;
            case 5:
                ie = 1073741823;
                break;
            case 4:
                ie = 1e4;
                break;
            default:
                ie = 5e3
            }
            return ie = re + ie,
            V = {
                id: v++,
                callback: ue,
                priorityLevel: V,
                startTime: re,
                expirationTime: ie,
                sortIndex: -1
            },
            re > U ? (V.sortIndex = re,
            e(p, V),
            n(m) === null && V === n(p) && (T ? (g(j),
            j = -1) : T = !0,
            de(C, re - U))) : (V.sortIndex = ie,
            e(m, V),
            E || S || (E = !0,
            ae(H))),
            V
        }
        ,
        s.unstable_shouldYield = I,
        s.unstable_wrapCallback = function(V) {
            var ue = x;
            return function() {
                var re = x;
                x = ue;
                try {
                    return V.apply(this, arguments)
                } finally {
                    x = re
                }
            }
        }
    }(_u)),
    _u
}
var Lp;
function t_() {
    return Lp || (Lp = 1,
    gu.exports = e_()),
    gu.exports
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Pp;
function n_() {
    if (Pp)
        return Ln;
    Pp = 1;
    var s = Hd()
      , e = t_();
    function n(t) {
        for (var i = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, a = 1; a < arguments.length; a++)
            i += "&args[]=" + encodeURIComponent(arguments[a]);
        return "Minified React error #" + t + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var r = new Set
      , o = {};
    function l(t, i) {
        u(t, i),
        u(t + "Capture", i)
    }
    function u(t, i) {
        for (o[t] = i,
        t = 0; t < i.length; t++)
            r.add(i[t])
    }
    var f = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , m = Object.prototype.hasOwnProperty
      , p = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
      , v = {}
      , _ = {};
    function x(t) {
        return m.call(_, t) ? !0 : m.call(v, t) ? !1 : p.test(t) ? _[t] = !0 : (v[t] = !0,
        !1)
    }
    function S(t, i, a, c) {
        if (a !== null && a.type === 0)
            return !1;
        switch (typeof i) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return c ? !1 : a !== null ? !a.acceptsBooleans : (t = t.toLowerCase().slice(0, 5),
            t !== "data-" && t !== "aria-");
        default:
            return !1
        }
    }
    function E(t, i, a, c) {
        if (i === null || typeof i > "u" || S(t, i, a, c))
            return !0;
        if (c)
            return !1;
        if (a !== null)
            switch (a.type) {
            case 3:
                return !i;
            case 4:
                return i === !1;
            case 5:
                return isNaN(i);
            case 6:
                return isNaN(i) || 1 > i
            }
        return !1
    }
    function T(t, i, a, c, d, h, w) {
        this.acceptsBooleans = i === 2 || i === 3 || i === 4,
        this.attributeName = c,
        this.attributeNamespace = d,
        this.mustUseProperty = a,
        this.propertyName = t,
        this.type = i,
        this.sanitizeURL = h,
        this.removeEmptyString = w
    }
    var y = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
        y[t] = new T(t,0,!1,t,null,!1,!1)
    }),
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(t) {
        var i = t[0];
        y[i] = new T(i,1,!1,t[1],null,!1,!1)
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
        y[t] = new T(t,2,!1,t.toLowerCase(),null,!1,!1)
    }),
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
        y[t] = new T(t,2,!1,t,null,!1,!1)
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
        y[t] = new T(t,3,!1,t.toLowerCase(),null,!1,!1)
    }),
    ["checked", "multiple", "muted", "selected"].forEach(function(t) {
        y[t] = new T(t,3,!0,t,null,!1,!1)
    }),
    ["capture", "download"].forEach(function(t) {
        y[t] = new T(t,4,!1,t,null,!1,!1)
    }),
    ["cols", "rows", "size", "span"].forEach(function(t) {
        y[t] = new T(t,6,!1,t,null,!1,!1)
    }),
    ["rowSpan", "start"].forEach(function(t) {
        y[t] = new T(t,5,!1,t.toLowerCase(),null,!1,!1)
    });
    var g = /[\-:]([a-z])/g;
    function N(t) {
        return t[1].toUpperCase()
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
        var i = t.replace(g, N);
        y[i] = new T(i,1,!1,t,null,!1,!1)
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
        var i = t.replace(g, N);
        y[i] = new T(i,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)
    }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
        var i = t.replace(g, N);
        y[i] = new T(i,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)
    }),
    ["tabIndex", "crossOrigin"].forEach(function(t) {
        y[t] = new T(t,1,!1,t.toLowerCase(),null,!1,!1)
    }),
    y.xlinkHref = new T("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),
    ["src", "href", "action", "formAction"].forEach(function(t) {
        y[t] = new T(t,1,!1,t.toLowerCase(),null,!0,!0)
    });
    function L(t, i, a, c) {
        var d = y.hasOwnProperty(i) ? y[i] : null;
        (d !== null ? d.type !== 0 : c || !(2 < i.length) || i[0] !== "o" && i[0] !== "O" || i[1] !== "n" && i[1] !== "N") && (E(i, a, d, c) && (a = null),
        c || d === null ? x(i) && (a === null ? t.removeAttribute(i) : t.setAttribute(i, "" + a)) : d.mustUseProperty ? t[d.propertyName] = a === null ? d.type === 3 ? !1 : "" : a : (i = d.attributeName,
        c = d.attributeNamespace,
        a === null ? t.removeAttribute(i) : (d = d.type,
        a = d === 3 || d === 4 && a === !0 ? "" : "" + a,
        c ? t.setAttributeNS(c, i, a) : t.setAttribute(i, a))))
    }
    var C = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , H = Symbol.for("react.element")
      , k = Symbol.for("react.portal")
      , F = Symbol.for("react.fragment")
      , j = Symbol.for("react.strict_mode")
      , b = Symbol.for("react.profiler")
      , R = Symbol.for("react.provider")
      , I = Symbol.for("react.context")
      , oe = Symbol.for("react.forward_ref")
      , se = Symbol.for("react.suspense")
      , ce = Symbol.for("react.suspense_list")
      , ne = Symbol.for("react.memo")
      , ae = Symbol.for("react.lazy")
      , de = Symbol.for("react.offscreen")
      , V = Symbol.iterator;
    function ue(t) {
        return t === null || typeof t != "object" ? null : (t = V && t[V] || t["@@iterator"],
        typeof t == "function" ? t : null)
    }
    var re = Object.assign, U;
    function ie(t) {
        if (U === void 0)
            try {
                throw Error()
            } catch (a) {
                var i = a.stack.trim().match(/\n( *(at )?)/);
                U = i && i[1] || ""
            }
        return `
` + U + t
    }
    var ke = !1;
    function ze(t, i) {
        if (!t || ke)
            return "";
        ke = !0;
        var a = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (i)
                if (i = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(i.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(i, [])
                    } catch (Z) {
                        var c = Z
                    }
                    Reflect.construct(t, [], i)
                } else {
                    try {
                        i.call()
                    } catch (Z) {
                        c = Z
                    }
                    t.call(i.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (Z) {
                    c = Z
                }
                t()
            }
        } catch (Z) {
            if (Z && c && typeof Z.stack == "string") {
                for (var d = Z.stack.split(`
`), h = c.stack.split(`
`), w = d.length - 1, D = h.length - 1; 1 <= w && 0 <= D && d[w] !== h[D]; )
                    D--;
                for (; 1 <= w && 0 <= D; w--,
                D--)
                    if (d[w] !== h[D]) {
                        if (w !== 1 || D !== 1)
                            do
                                if (w--,
                                D--,
                                0 > D || d[w] !== h[D]) {
                                    var B = `
` + d[w].replace(" at new ", " at ");
                                    return t.displayName && B.includes("<anonymous>") && (B = B.replace("<anonymous>", t.displayName)),
                                    B
                                }
                            while (1 <= w && 0 <= D);
                        break
                    }
            }
        } finally {
            ke = !1,
            Error.prepareStackTrace = a
        }
        return (t = t ? t.displayName || t.name : "") ? ie(t) : ""
    }
    function Q(t) {
        switch (t.tag) {
        case 5:
            return ie(t.type);
        case 16:
            return ie("Lazy");
        case 13:
            return ie("Suspense");
        case 19:
            return ie("SuspenseList");
        case 0:
        case 2:
        case 15:
            return t = ze(t.type, !1),
            t;
        case 11:
            return t = ze(t.type.render, !1),
            t;
        case 1:
            return t = ze(t.type, !0),
            t;
        default:
            return ""
        }
    }
    function me(t) {
        if (t == null)
            return null;
        if (typeof t == "function")
            return t.displayName || t.name || null;
        if (typeof t == "string")
            return t;
        switch (t) {
        case F:
            return "Fragment";
        case k:
            return "Portal";
        case b:
            return "Profiler";
        case j:
            return "StrictMode";
        case se:
            return "Suspense";
        case ce:
            return "SuspenseList"
        }
        if (typeof t == "object")
            switch (t.$$typeof) {
            case I:
                return (t.displayName || "Context") + ".Consumer";
            case R:
                return (t._context.displayName || "Context") + ".Provider";
            case oe:
                var i = t.render;
                return t = t.displayName,
                t || (t = i.displayName || i.name || "",
                t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"),
                t;
            case ne:
                return i = t.displayName || null,
                i !== null ? i : me(t.type) || "Memo";
            case ae:
                i = t._payload,
                t = t._init;
                try {
                    return me(t(i))
                } catch {}
            }
        return null
    }
    function pe(t) {
        var i = t.type;
        switch (t.tag) {
        case 24:
            return "Cache";
        case 9:
            return (i.displayName || "Context") + ".Consumer";
        case 10:
            return (i._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return t = i.render,
            t = t.displayName || t.name || "",
            i.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return i;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return me(i);
        case 8:
            return i === j ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof i == "function")
                return i.displayName || i.name || null;
            if (typeof i == "string")
                return i
        }
        return null
    }
    function Ce(t) {
        switch (typeof t) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return t;
        case "object":
            return t;
        default:
            return ""
        }
    }
    function Pe(t) {
        var i = t.type;
        return (t = t.nodeName) && t.toLowerCase() === "input" && (i === "checkbox" || i === "radio")
    }
    function Ke(t) {
        var i = Pe(t) ? "checked" : "value"
          , a = Object.getOwnPropertyDescriptor(t.constructor.prototype, i)
          , c = "" + t[i];
        if (!t.hasOwnProperty(i) && typeof a < "u" && typeof a.get == "function" && typeof a.set == "function") {
            var d = a.get
              , h = a.set;
            return Object.defineProperty(t, i, {
                configurable: !0,
                get: function() {
                    return d.call(this)
                },
                set: function(w) {
                    c = "" + w,
                    h.call(this, w)
                }
            }),
            Object.defineProperty(t, i, {
                enumerable: a.enumerable
            }),
            {
                getValue: function() {
                    return c
                },
                setValue: function(w) {
                    c = "" + w
                },
                stopTracking: function() {
                    t._valueTracker = null,
                    delete t[i]
                }
            }
        }
    }
    function Ut(t) {
        t._valueTracker || (t._valueTracker = Ke(t))
    }
    function gt(t) {
        if (!t)
            return !1;
        var i = t._valueTracker;
        if (!i)
            return !0;
        var a = i.getValue()
          , c = "";
        return t && (c = Pe(t) ? t.checked ? "true" : "false" : t.value),
        t = c,
        t !== a ? (i.setValue(t),
        !0) : !1
    }
    function z(t) {
        if (t = t || (typeof document < "u" ? document : void 0),
        typeof t > "u")
            return null;
        try {
            return t.activeElement || t.body
        } catch {
            return t.body
        }
    }
    function Tt(t, i) {
        var a = i.checked;
        return re({}, i, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: a ?? t._wrapperState.initialChecked
        })
    }
    function Qe(t, i) {
        var a = i.defaultValue == null ? "" : i.defaultValue
          , c = i.checked != null ? i.checked : i.defaultChecked;
        a = Ce(i.value != null ? i.value : a),
        t._wrapperState = {
            initialChecked: c,
            initialValue: a,
            controlled: i.type === "checkbox" || i.type === "radio" ? i.checked != null : i.value != null
        }
    }
    function xt(t, i) {
        i = i.checked,
        i != null && L(t, "checked", i, !1)
    }
    function qe(t, i) {
        xt(t, i);
        var a = Ce(i.value)
          , c = i.type;
        if (a != null)
            c === "number" ? (a === 0 && t.value === "" || t.value != a) && (t.value = "" + a) : t.value !== "" + a && (t.value = "" + a);
        else if (c === "submit" || c === "reset") {
            t.removeAttribute("value");
            return
        }
        i.hasOwnProperty("value") ? Fe(t, i.type, a) : i.hasOwnProperty("defaultValue") && Fe(t, i.type, Ce(i.defaultValue)),
        i.checked == null && i.defaultChecked != null && (t.defaultChecked = !!i.defaultChecked)
    }
    function Nt(t, i, a) {
        if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
            var c = i.type;
            if (!(c !== "submit" && c !== "reset" || i.value !== void 0 && i.value !== null))
                return;
            i = "" + t._wrapperState.initialValue,
            a || i === t.value || (t.value = i),
            t.defaultValue = i
        }
        a = t.name,
        a !== "" && (t.name = ""),
        t.defaultChecked = !!t._wrapperState.initialChecked,
        a !== "" && (t.name = a)
    }
    function Fe(t, i, a) {
        (i !== "number" || z(t.ownerDocument) !== t) && (a == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + a && (t.defaultValue = "" + a))
    }
    var lt = Array.isArray;
    function Ot(t, i, a, c) {
        if (t = t.options,
        i) {
            i = {};
            for (var d = 0; d < a.length; d++)
                i["$" + a[d]] = !0;
            for (a = 0; a < t.length; a++)
                d = i.hasOwnProperty("$" + t[a].value),
                t[a].selected !== d && (t[a].selected = d),
                d && c && (t[a].defaultSelected = !0)
        } else {
            for (a = "" + Ce(a),
            i = null,
            d = 0; d < t.length; d++) {
                if (t[d].value === a) {
                    t[d].selected = !0,
                    c && (t[d].defaultSelected = !0);
                    return
                }
                i !== null || t[d].disabled || (i = t[d])
            }
            i !== null && (i.selected = !0)
        }
    }
    function zt(t, i) {
        if (i.dangerouslySetInnerHTML != null)
            throw Error(n(91));
        return re({}, i, {
            value: void 0,
            defaultValue: void 0,
            children: "" + t._wrapperState.initialValue
        })
    }
    function P(t, i) {
        var a = i.value;
        if (a == null) {
            if (a = i.children,
            i = i.defaultValue,
            a != null) {
                if (i != null)
                    throw Error(n(92));
                if (lt(a)) {
                    if (1 < a.length)
                        throw Error(n(93));
                    a = a[0]
                }
                i = a
            }
            i == null && (i = ""),
            a = i
        }
        t._wrapperState = {
            initialValue: Ce(a)
        }
    }
    function M(t, i) {
        var a = Ce(i.value)
          , c = Ce(i.defaultValue);
        a != null && (a = "" + a,
        a !== t.value && (t.value = a),
        i.defaultValue == null && t.defaultValue !== a && (t.defaultValue = a)),
        c != null && (t.defaultValue = "" + c)
    }
    function $(t) {
        var i = t.textContent;
        i === t._wrapperState.initialValue && i !== "" && i !== null && (t.value = i)
    }
    function fe(t) {
        switch (t) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
        }
    }
    function ve(t, i) {
        return t == null || t === "http://www.w3.org/1999/xhtml" ? fe(i) : t === "http://www.w3.org/2000/svg" && i === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
    }
    var le, Ye = function(t) {
        return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, a, c, d) {
            MSApp.execUnsafeLocalFunction(function() {
                return t(i, a, c, d)
            })
        }
        : t
    }(function(t, i) {
        if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in t)
            t.innerHTML = i;
        else {
            for (le = le || document.createElement("div"),
            le.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>",
            i = le.firstChild; t.firstChild; )
                t.removeChild(t.firstChild);
            for (; i.firstChild; )
                t.appendChild(i.firstChild)
        }
    });
    function Te(t, i) {
        if (i) {
            var a = t.firstChild;
            if (a && a === t.lastChild && a.nodeType === 3) {
                a.nodeValue = i;
                return
            }
        }
        t.textContent = i
    }
    var Be = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }
      , Je = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Be).forEach(function(t) {
        Je.forEach(function(i) {
            i = i + t.charAt(0).toUpperCase() + t.substring(1),
            Be[i] = Be[t]
        })
    });
    function Me(t, i, a) {
        return i == null || typeof i == "boolean" || i === "" ? "" : a || typeof i != "number" || i === 0 || Be.hasOwnProperty(t) && Be[t] ? ("" + i).trim() : i + "px"
    }
    function Ne(t, i) {
        t = t.style;
        for (var a in i)
            if (i.hasOwnProperty(a)) {
                var c = a.indexOf("--") === 0
                  , d = Me(a, i[a], c);
                a === "float" && (a = "cssFloat"),
                c ? t.setProperty(a, d) : t[a] = d
            }
    }
    var it = re({
        menuitem: !0
    }, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });
    function We(t, i) {
        if (i) {
            if (it[t] && (i.children != null || i.dangerouslySetInnerHTML != null))
                throw Error(n(137, t));
            if (i.dangerouslySetInnerHTML != null) {
                if (i.children != null)
                    throw Error(n(60));
                if (typeof i.dangerouslySetInnerHTML != "object" || !("__html"in i.dangerouslySetInnerHTML))
                    throw Error(n(61))
            }
            if (i.style != null && typeof i.style != "object")
                throw Error(n(62))
        }
    }
    function Re(t, i) {
        if (t.indexOf("-") === -1)
            return typeof i.is == "string";
        switch (t) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var ct = null;
    function G(t) {
        return t = t.target || t.srcElement || window,
        t.correspondingUseElement && (t = t.correspondingUseElement),
        t.nodeType === 3 ? t.parentNode : t
    }
    var Se = null
      , Ae = null
      , De = null;
    function ye(t) {
        if (t = la(t)) {
            if (typeof Se != "function")
                throw Error(n(280));
            var i = t.stateNode;
            i && (i = co(i),
            Se(t.stateNode, t.type, i))
        }
    }
    function he(t) {
        Ae ? De ? De.push(t) : De = [t] : Ae = t
    }
    function je() {
        if (Ae) {
            var t = Ae
              , i = De;
            if (De = Ae = null,
            ye(t),
            i)
                for (t = 0; t < i.length; t++)
                    ye(i[t])
        }
    }
    function ot(t, i) {
        return t(i)
    }
    function Ct() {}
    var yt = !1;
    function Gn(t, i, a) {
        if (yt)
            return t(i, a);
        yt = !0;
        try {
            return ot(t, i, a)
        } finally {
            yt = !1,
            (Ae !== null || De !== null) && (Ct(),
            je())
        }
    }
    function un(t, i) {
        var a = t.stateNode;
        if (a === null)
            return null;
        var c = co(a);
        if (c === null)
            return null;
        a = c[i];
        e: switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (c = !c.disabled) || (t = t.type,
            c = !(t === "button" || t === "input" || t === "select" || t === "textarea")),
            t = !c;
            break e;
        default:
            t = !1
        }
        if (t)
            return null;
        if (a && typeof a != "function")
            throw Error(n(231, i, typeof a));
        return a
    }
    var qr = !1;
    if (f)
        try {
            var Fn = {};
            Object.defineProperty(Fn, "passive", {
                get: function() {
                    qr = !0
                }
            }),
            window.addEventListener("test", Fn, Fn),
            window.removeEventListener("test", Fn, Fn)
        } catch {
            qr = !1
        }
    function Ws(t, i, a, c, d, h, w, D, B) {
        var Z = Array.prototype.slice.call(arguments, 3);
        try {
            i.apply(a, Z)
        } catch (_e) {
            this.onError(_e)
        }
    }
    var Vi = !1
      , xr = null
      , Mi = !1
      , $r = null
      , Kr = {
        onError: function(t) {
            Vi = !0,
            xr = t
        }
    };
    function Va(t, i, a, c, d, h, w, D, B) {
        Vi = !1,
        xr = null,
        Ws.apply(Kr, arguments)
    }
    function ja(t, i, a, c, d, h, w, D, B) {
        if (Va.apply(this, arguments),
        Vi) {
            if (Vi) {
                var Z = xr;
                Vi = !1,
                xr = null
            } else
                throw Error(n(198));
            Mi || (Mi = !0,
            $r = Z)
        }
    }
    function Ei(t) {
        var i = t
          , a = t;
        if (t.alternate)
            for (; i.return; )
                i = i.return;
        else {
            t = i;
            do
                i = t,
                (i.flags & 4098) !== 0 && (a = i.return),
                t = i.return;
            while (t)
        }
        return i.tag === 3 ? a : null
    }
    function Ga(t) {
        if (t.tag === 13) {
            var i = t.memoizedState;
            if (i === null && (t = t.alternate,
            t !== null && (i = t.memoizedState)),
            i !== null)
                return i.dehydrated
        }
        return null
    }
    function Wa(t) {
        if (Ei(t) !== t)
            throw Error(n(188))
    }
    function Fl(t) {
        var i = t.alternate;
        if (!i) {
            if (i = Ei(t),
            i === null)
                throw Error(n(188));
            return i !== t ? null : t
        }
        for (var a = t, c = i; ; ) {
            var d = a.return;
            if (d === null)
                break;
            var h = d.alternate;
            if (h === null) {
                if (c = d.return,
                c !== null) {
                    a = c;
                    continue
                }
                break
            }
            if (d.child === h.child) {
                for (h = d.child; h; ) {
                    if (h === a)
                        return Wa(d),
                        t;
                    if (h === c)
                        return Wa(d),
                        i;
                    h = h.sibling
                }
                throw Error(n(188))
            }
            if (a.return !== c.return)
                a = d,
                c = h;
            else {
                for (var w = !1, D = d.child; D; ) {
                    if (D === a) {
                        w = !0,
                        a = d,
                        c = h;
                        break
                    }
                    if (D === c) {
                        w = !0,
                        c = d,
                        a = h;
                        break
                    }
                    D = D.sibling
                }
                if (!w) {
                    for (D = h.child; D; ) {
                        if (D === a) {
                            w = !0,
                            a = h,
                            c = d;
                            break
                        }
                        if (D === c) {
                            w = !0,
                            c = h,
                            a = d;
                            break
                        }
                        D = D.sibling
                    }
                    if (!w)
                        throw Error(n(189))
                }
            }
            if (a.alternate !== c)
                throw Error(n(190))
        }
        if (a.tag !== 3)
            throw Error(n(188));
        return a.stateNode.current === a ? t : i
    }
    function Xa(t) {
        return t = Fl(t),
        t !== null ? Ya(t) : null
    }
    function Ya(t) {
        if (t.tag === 5 || t.tag === 6)
            return t;
        for (t = t.child; t !== null; ) {
            var i = Ya(t);
            if (i !== null)
                return i;
            t = t.sibling
        }
        return null
    }
    var A = e.unstable_scheduleCallback
      , Y = e.unstable_cancelCallback
      , ee = e.unstable_shouldYield
      , te = e.unstable_requestPaint
      , W = e.unstable_now
      , we = e.unstable_getCurrentPriorityLevel
      , be = e.unstable_ImmediatePriority
      , He = e.unstable_UserBlockingPriority
      , Ie = e.unstable_NormalPriority
      , nt = e.unstable_LowPriority
      , rt = e.unstable_IdlePriority
      , $e = null
      , st = null;
    function At(t) {
        if (st && typeof st.onCommitFiberRoot == "function")
            try {
                st.onCommitFiberRoot($e, t, void 0, (t.current.flags & 128) === 128)
            } catch {}
    }
    var St = Math.clz32 ? Math.clz32 : Ze
      , Dt = Math.log
      , Rt = Math.LN2;
    function Ze(t) {
        return t >>>= 0,
        t === 0 ? 32 : 31 - (Dt(t) / Rt | 0) | 0
    }
    var bt = 64
      , ht = 4194304;
    function $t(t) {
        switch (t & -t) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return t & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return t & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return t
        }
    }
    function ei(t, i) {
        var a = t.pendingLanes;
        if (a === 0)
            return 0;
        var c = 0
          , d = t.suspendedLanes
          , h = t.pingedLanes
          , w = a & 268435455;
        if (w !== 0) {
            var D = w & ~d;
            D !== 0 ? c = $t(D) : (h &= w,
            h !== 0 && (c = $t(h)))
        } else
            w = a & ~d,
            w !== 0 ? c = $t(w) : h !== 0 && (c = $t(h));
        if (c === 0)
            return 0;
        if (i !== 0 && i !== c && (i & d) === 0 && (d = c & -c,
        h = i & -i,
        d >= h || d === 16 && (h & 4194240) !== 0))
            return i;
        if ((c & 4) !== 0 && (c |= a & 16),
        i = t.entangledLanes,
        i !== 0)
            for (t = t.entanglements,
            i &= c; 0 < i; )
                a = 31 - St(i),
                d = 1 << a,
                c |= t[a],
                i &= ~d;
        return c
    }
    function yn(t, i) {
        switch (t) {
        case 1:
        case 2:
        case 4:
            return i + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return i + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function yr(t, i) {
        for (var a = t.suspendedLanes, c = t.pingedLanes, d = t.expirationTimes, h = t.pendingLanes; 0 < h; ) {
            var w = 31 - St(h)
              , D = 1 << w
              , B = d[w];
            B === -1 ? ((D & a) === 0 || (D & c) !== 0) && (d[w] = yn(D, i)) : B <= i && (t.expiredLanes |= D),
            h &= ~D
        }
    }
    function It(t) {
        return t = t.pendingLanes & -1073741825,
        t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
    }
    function Sn() {
        var t = bt;
        return bt <<= 1,
        (bt & 4194240) === 0 && (bt = 64),
        t
    }
    function dn(t) {
        for (var i = [], a = 0; 31 > a; a++)
            i.push(t);
        return i
    }
    function Xt(t, i, a) {
        t.pendingLanes |= i,
        i !== 536870912 && (t.suspendedLanes = 0,
        t.pingedLanes = 0),
        t = t.eventTimes,
        i = 31 - St(i),
        t[i] = a
    }
    function fn(t, i) {
        var a = t.pendingLanes & ~i;
        t.pendingLanes = i,
        t.suspendedLanes = 0,
        t.pingedLanes = 0,
        t.expiredLanes &= i,
        t.mutableReadLanes &= i,
        t.entangledLanes &= i,
        i = t.entanglements;
        var c = t.eventTimes;
        for (t = t.expirationTimes; 0 < a; ) {
            var d = 31 - St(a)
              , h = 1 << d;
            i[d] = 0,
            c[d] = -1,
            t[d] = -1,
            a &= ~h
        }
    }
    function Sr(t, i) {
        var a = t.entangledLanes |= i;
        for (t = t.entanglements; a; ) {
            var c = 31 - St(a)
              , d = 1 << c;
            d & i | t[c] & i && (t[c] |= i),
            a &= ~d
        }
    }
    var pt = 0;
    function nf(t) {
        return t &= -t,
        1 < t ? 4 < t ? (t & 268435455) !== 0 ? 16 : 536870912 : 4 : 1
    }
    var rf, Ol, sf, af, of, zl = !1, Ja = [], ji = null, Gi = null, Wi = null, Xs = new Map, Ys = new Map, Xi = [], xg = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function lf(t, i) {
        switch (t) {
        case "focusin":
        case "focusout":
            ji = null;
            break;
        case "dragenter":
        case "dragleave":
            Gi = null;
            break;
        case "mouseover":
        case "mouseout":
            Wi = null;
            break;
        case "pointerover":
        case "pointerout":
            Xs.delete(i.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            Ys.delete(i.pointerId)
        }
    }
    function Js(t, i, a, c, d, h) {
        return t === null || t.nativeEvent !== h ? (t = {
            blockedOn: i,
            domEventName: a,
            eventSystemFlags: c,
            nativeEvent: h,
            targetContainers: [d]
        },
        i !== null && (i = la(i),
        i !== null && Ol(i)),
        t) : (t.eventSystemFlags |= c,
        i = t.targetContainers,
        d !== null && i.indexOf(d) === -1 && i.push(d),
        t)
    }
    function yg(t, i, a, c, d) {
        switch (i) {
        case "focusin":
            return ji = Js(ji, t, i, a, c, d),
            !0;
        case "dragenter":
            return Gi = Js(Gi, t, i, a, c, d),
            !0;
        case "mouseover":
            return Wi = Js(Wi, t, i, a, c, d),
            !0;
        case "pointerover":
            var h = d.pointerId;
            return Xs.set(h, Js(Xs.get(h) || null, t, i, a, c, d)),
            !0;
        case "gotpointercapture":
            return h = d.pointerId,
            Ys.set(h, Js(Ys.get(h) || null, t, i, a, c, d)),
            !0
        }
        return !1
    }
    function cf(t) {
        var i = wr(t.target);
        if (i !== null) {
            var a = Ei(i);
            if (a !== null) {
                if (i = a.tag,
                i === 13) {
                    if (i = Ga(a),
                    i !== null) {
                        t.blockedOn = i,
                        of(t.priority, function() {
                            sf(a)
                        });
                        return
                    }
                } else if (i === 3 && a.stateNode.current.memoizedState.isDehydrated) {
                    t.blockedOn = a.tag === 3 ? a.stateNode.containerInfo : null;
                    return
                }
            }
        }
        t.blockedOn = null
    }
    function qa(t) {
        if (t.blockedOn !== null)
            return !1;
        for (var i = t.targetContainers; 0 < i.length; ) {
            var a = Bl(t.domEventName, t.eventSystemFlags, i[0], t.nativeEvent);
            if (a === null) {
                a = t.nativeEvent;
                var c = new a.constructor(a.type,a);
                ct = c,
                a.target.dispatchEvent(c),
                ct = null
            } else
                return i = la(a),
                i !== null && Ol(i),
                t.blockedOn = a,
                !1;
            i.shift()
        }
        return !0
    }
    function uf(t, i, a) {
        qa(t) && a.delete(i)
    }
    function Sg() {
        zl = !1,
        ji !== null && qa(ji) && (ji = null),
        Gi !== null && qa(Gi) && (Gi = null),
        Wi !== null && qa(Wi) && (Wi = null),
        Xs.forEach(uf),
        Ys.forEach(uf)
    }
    function qs(t, i) {
        t.blockedOn === i && (t.blockedOn = null,
        zl || (zl = !0,
        e.unstable_scheduleCallback(e.unstable_NormalPriority, Sg)))
    }
    function $s(t) {
        function i(d) {
            return qs(d, t)
        }
        if (0 < Ja.length) {
            qs(Ja[0], t);
            for (var a = 1; a < Ja.length; a++) {
                var c = Ja[a];
                c.blockedOn === t && (c.blockedOn = null)
            }
        }
        for (ji !== null && qs(ji, t),
        Gi !== null && qs(Gi, t),
        Wi !== null && qs(Wi, t),
        Xs.forEach(i),
        Ys.forEach(i),
        a = 0; a < Xi.length; a++)
            c = Xi[a],
            c.blockedOn === t && (c.blockedOn = null);
        for (; 0 < Xi.length && (a = Xi[0],
        a.blockedOn === null); )
            cf(a),
            a.blockedOn === null && Xi.shift()
    }
    var Qr = C.ReactCurrentBatchConfig
      , $a = !0;
    function wg(t, i, a, c) {
        var d = pt
          , h = Qr.transition;
        Qr.transition = null;
        try {
            pt = 1,
            kl(t, i, a, c)
        } finally {
            pt = d,
            Qr.transition = h
        }
    }
    function Mg(t, i, a, c) {
        var d = pt
          , h = Qr.transition;
        Qr.transition = null;
        try {
            pt = 4,
            kl(t, i, a, c)
        } finally {
            pt = d,
            Qr.transition = h
        }
    }
    function kl(t, i, a, c) {
        if ($a) {
            var d = Bl(t, i, a, c);
            if (d === null)
                ic(t, i, c, Ka, a),
                lf(t, c);
            else if (yg(d, t, i, a, c))
                c.stopPropagation();
            else if (lf(t, c),
            i & 4 && -1 < xg.indexOf(t)) {
                for (; d !== null; ) {
                    var h = la(d);
                    if (h !== null && rf(h),
                    h = Bl(t, i, a, c),
                    h === null && ic(t, i, c, Ka, a),
                    h === d)
                        break;
                    d = h
                }
                d !== null && c.stopPropagation()
            } else
                ic(t, i, c, null, a)
        }
    }
    var Ka = null;
    function Bl(t, i, a, c) {
        if (Ka = null,
        t = G(c),
        t = wr(t),
        t !== null)
            if (i = Ei(t),
            i === null)
                t = null;
            else if (a = i.tag,
            a === 13) {
                if (t = Ga(i),
                t !== null)
                    return t;
                t = null
            } else if (a === 3) {
                if (i.stateNode.current.memoizedState.isDehydrated)
                    return i.tag === 3 ? i.stateNode.containerInfo : null;
                t = null
            } else
                i !== t && (t = null);
        return Ka = t,
        null
    }
    function df(t) {
        switch (t) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (we()) {
            case be:
                return 1;
            case He:
                return 4;
            case Ie:
            case nt:
                return 16;
            case rt:
                return 536870912;
            default:
                return 16
            }
        default:
            return 16
        }
    }
    var Yi = null
      , Hl = null
      , Qa = null;
    function ff() {
        if (Qa)
            return Qa;
        var t, i = Hl, a = i.length, c, d = "value"in Yi ? Yi.value : Yi.textContent, h = d.length;
        for (t = 0; t < a && i[t] === d[t]; t++)
            ;
        var w = a - t;
        for (c = 1; c <= w && i[a - c] === d[h - c]; c++)
            ;
        return Qa = d.slice(t, 1 < c ? 1 - c : void 0)
    }
    function Za(t) {
        var i = t.keyCode;
        return "charCode"in t ? (t = t.charCode,
        t === 0 && i === 13 && (t = 13)) : t = i,
        t === 10 && (t = 13),
        32 <= t || t === 13 ? t : 0
    }
    function eo() {
        return !0
    }
    function hf() {
        return !1
    }
    function On(t) {
        function i(a, c, d, h, w) {
            this._reactName = a,
            this._targetInst = d,
            this.type = c,
            this.nativeEvent = h,
            this.target = w,
            this.currentTarget = null;
            for (var D in t)
                t.hasOwnProperty(D) && (a = t[D],
                this[D] = a ? a(h) : h[D]);
            return this.isDefaultPrevented = (h.defaultPrevented != null ? h.defaultPrevented : h.returnValue === !1) ? eo : hf,
            this.isPropagationStopped = hf,
            this
        }
        return re(i.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var a = this.nativeEvent;
                a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1),
                this.isDefaultPrevented = eo)
            },
            stopPropagation: function() {
                var a = this.nativeEvent;
                a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0),
                this.isPropagationStopped = eo)
            },
            persist: function() {},
            isPersistent: eo
        }),
        i
    }
    var Zr = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(t) {
            return t.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, Vl = On(Zr), Ks = re({}, Zr, {
        view: 0,
        detail: 0
    }), Eg = On(Ks), jl, Gl, Qs, to = re({}, Ks, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: Xl,
        button: 0,
        buttons: 0,
        relatedTarget: function(t) {
            return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
        },
        movementX: function(t) {
            return "movementX"in t ? t.movementX : (t !== Qs && (Qs && t.type === "mousemove" ? (jl = t.screenX - Qs.screenX,
            Gl = t.screenY - Qs.screenY) : Gl = jl = 0,
            Qs = t),
            jl)
        },
        movementY: function(t) {
            return "movementY"in t ? t.movementY : Gl
        }
    }), pf = On(to), Tg = re({}, to, {
        dataTransfer: 0
    }), Ag = On(Tg), Cg = re({}, Ks, {
        relatedTarget: 0
    }), Wl = On(Cg), Rg = re({}, Zr, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), bg = On(Rg), Lg = re({}, Zr, {
        clipboardData: function(t) {
            return "clipboardData"in t ? t.clipboardData : window.clipboardData
        }
    }), Pg = On(Lg), Ng = re({}, Zr, {
        data: 0
    }), mf = On(Ng), Dg = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, Ig = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, Ug = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function Fg(t) {
        var i = this.nativeEvent;
        return i.getModifierState ? i.getModifierState(t) : (t = Ug[t]) ? !!i[t] : !1
    }
    function Xl() {
        return Fg
    }
    var Og = re({}, Ks, {
        key: function(t) {
            if (t.key) {
                var i = Dg[t.key] || t.key;
                if (i !== "Unidentified")
                    return i
            }
            return t.type === "keypress" ? (t = Za(t),
            t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? Ig[t.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: Xl,
        charCode: function(t) {
            return t.type === "keypress" ? Za(t) : 0
        },
        keyCode: function(t) {
            return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
        },
        which: function(t) {
            return t.type === "keypress" ? Za(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
        }
    })
      , zg = On(Og)
      , kg = re({}, to, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , gf = On(kg)
      , Bg = re({}, Ks, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Xl
    })
      , Hg = On(Bg)
      , Vg = re({}, Zr, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , jg = On(Vg)
      , Gg = re({}, to, {
        deltaX: function(t) {
            return "deltaX"in t ? t.deltaX : "wheelDeltaX"in t ? -t.wheelDeltaX : 0
        },
        deltaY: function(t) {
            return "deltaY"in t ? t.deltaY : "wheelDeltaY"in t ? -t.wheelDeltaY : "wheelDelta"in t ? -t.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , Wg = On(Gg)
      , Xg = [9, 13, 27, 32]
      , Yl = f && "CompositionEvent"in window
      , Zs = null;
    f && "documentMode"in document && (Zs = document.documentMode);
    var Yg = f && "TextEvent"in window && !Zs
      , _f = f && (!Yl || Zs && 8 < Zs && 11 >= Zs)
      , vf = " "
      , xf = !1;
    function yf(t, i) {
        switch (t) {
        case "keyup":
            return Xg.indexOf(i.keyCode) !== -1;
        case "keydown":
            return i.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function Sf(t) {
        return t = t.detail,
        typeof t == "object" && "data"in t ? t.data : null
    }
    var es = !1;
    function Jg(t, i) {
        switch (t) {
        case "compositionend":
            return Sf(i);
        case "keypress":
            return i.which !== 32 ? null : (xf = !0,
            vf);
        case "textInput":
            return t = i.data,
            t === vf && xf ? null : t;
        default:
            return null
        }
    }
    function qg(t, i) {
        if (es)
            return t === "compositionend" || !Yl && yf(t, i) ? (t = ff(),
            Qa = Hl = Yi = null,
            es = !1,
            t) : null;
        switch (t) {
        case "paste":
            return null;
        case "keypress":
            if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
                if (i.char && 1 < i.char.length)
                    return i.char;
                if (i.which)
                    return String.fromCharCode(i.which)
            }
            return null;
        case "compositionend":
            return _f && i.locale !== "ko" ? null : i.data;
        default:
            return null
        }
    }
    var $g = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function wf(t) {
        var i = t && t.nodeName && t.nodeName.toLowerCase();
        return i === "input" ? !!$g[t.type] : i === "textarea"
    }
    function Mf(t, i, a, c) {
        he(c),
        i = ao(i, "onChange"),
        0 < i.length && (a = new Vl("onChange","change",null,a,c),
        t.push({
            event: a,
            listeners: i
        }))
    }
    var ea = null
      , ta = null;
    function Kg(t) {
        Hf(t, 0)
    }
    function no(t) {
        var i = ss(t);
        if (gt(i))
            return t
    }
    function Qg(t, i) {
        if (t === "change")
            return i
    }
    var Ef = !1;
    if (f) {
        var Jl;
        if (f) {
            var ql = "oninput"in document;
            if (!ql) {
                var Tf = document.createElement("div");
                Tf.setAttribute("oninput", "return;"),
                ql = typeof Tf.oninput == "function"
            }
            Jl = ql
        } else
            Jl = !1;
        Ef = Jl && (!document.documentMode || 9 < document.documentMode)
    }
    function Af() {
        ea && (ea.detachEvent("onpropertychange", Cf),
        ta = ea = null)
    }
    function Cf(t) {
        if (t.propertyName === "value" && no(ta)) {
            var i = [];
            Mf(i, ta, t, G(t)),
            Gn(Kg, i)
        }
    }
    function Zg(t, i, a) {
        t === "focusin" ? (Af(),
        ea = i,
        ta = a,
        ea.attachEvent("onpropertychange", Cf)) : t === "focusout" && Af()
    }
    function e0(t) {
        if (t === "selectionchange" || t === "keyup" || t === "keydown")
            return no(ta)
    }
    function t0(t, i) {
        if (t === "click")
            return no(i)
    }
    function n0(t, i) {
        if (t === "input" || t === "change")
            return no(i)
    }
    function i0(t, i) {
        return t === i && (t !== 0 || 1 / t === 1 / i) || t !== t && i !== i
    }
    var ti = typeof Object.is == "function" ? Object.is : i0;
    function na(t, i) {
        if (ti(t, i))
            return !0;
        if (typeof t != "object" || t === null || typeof i != "object" || i === null)
            return !1;
        var a = Object.keys(t)
          , c = Object.keys(i);
        if (a.length !== c.length)
            return !1;
        for (c = 0; c < a.length; c++) {
            var d = a[c];
            if (!m.call(i, d) || !ti(t[d], i[d]))
                return !1
        }
        return !0
    }
    function Rf(t) {
        for (; t && t.firstChild; )
            t = t.firstChild;
        return t
    }
    function bf(t, i) {
        var a = Rf(t);
        t = 0;
        for (var c; a; ) {
            if (a.nodeType === 3) {
                if (c = t + a.textContent.length,
                t <= i && c >= i)
                    return {
                        node: a,
                        offset: i - t
                    };
                t = c
            }
            e: {
                for (; a; ) {
                    if (a.nextSibling) {
                        a = a.nextSibling;
                        break e
                    }
                    a = a.parentNode
                }
                a = void 0
            }
            a = Rf(a)
        }
    }
    function Lf(t, i) {
        return t && i ? t === i ? !0 : t && t.nodeType === 3 ? !1 : i && i.nodeType === 3 ? Lf(t, i.parentNode) : "contains"in t ? t.contains(i) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(i) & 16) : !1 : !1
    }
    function Pf() {
        for (var t = window, i = z(); i instanceof t.HTMLIFrameElement; ) {
            try {
                var a = typeof i.contentWindow.location.href == "string"
            } catch {
                a = !1
            }
            if (a)
                t = i.contentWindow;
            else
                break;
            i = z(t.document)
        }
        return i
    }
    function $l(t) {
        var i = t && t.nodeName && t.nodeName.toLowerCase();
        return i && (i === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || i === "textarea" || t.contentEditable === "true")
    }
    function r0(t) {
        var i = Pf()
          , a = t.focusedElem
          , c = t.selectionRange;
        if (i !== a && a && a.ownerDocument && Lf(a.ownerDocument.documentElement, a)) {
            if (c !== null && $l(a)) {
                if (i = c.start,
                t = c.end,
                t === void 0 && (t = i),
                "selectionStart"in a)
                    a.selectionStart = i,
                    a.selectionEnd = Math.min(t, a.value.length);
                else if (t = (i = a.ownerDocument || document) && i.defaultView || window,
                t.getSelection) {
                    t = t.getSelection();
                    var d = a.textContent.length
                      , h = Math.min(c.start, d);
                    c = c.end === void 0 ? h : Math.min(c.end, d),
                    !t.extend && h > c && (d = c,
                    c = h,
                    h = d),
                    d = bf(a, h);
                    var w = bf(a, c);
                    d && w && (t.rangeCount !== 1 || t.anchorNode !== d.node || t.anchorOffset !== d.offset || t.focusNode !== w.node || t.focusOffset !== w.offset) && (i = i.createRange(),
                    i.setStart(d.node, d.offset),
                    t.removeAllRanges(),
                    h > c ? (t.addRange(i),
                    t.extend(w.node, w.offset)) : (i.setEnd(w.node, w.offset),
                    t.addRange(i)))
                }
            }
            for (i = [],
            t = a; t = t.parentNode; )
                t.nodeType === 1 && i.push({
                    element: t,
                    left: t.scrollLeft,
                    top: t.scrollTop
                });
            for (typeof a.focus == "function" && a.focus(),
            a = 0; a < i.length; a++)
                t = i[a],
                t.element.scrollLeft = t.left,
                t.element.scrollTop = t.top
        }
    }
    var s0 = f && "documentMode"in document && 11 >= document.documentMode
      , ts = null
      , Kl = null
      , ia = null
      , Ql = !1;
    function Nf(t, i, a) {
        var c = a.window === a ? a.document : a.nodeType === 9 ? a : a.ownerDocument;
        Ql || ts == null || ts !== z(c) || (c = ts,
        "selectionStart"in c && $l(c) ? c = {
            start: c.selectionStart,
            end: c.selectionEnd
        } : (c = (c.ownerDocument && c.ownerDocument.defaultView || window).getSelection(),
        c = {
            anchorNode: c.anchorNode,
            anchorOffset: c.anchorOffset,
            focusNode: c.focusNode,
            focusOffset: c.focusOffset
        }),
        ia && na(ia, c) || (ia = c,
        c = ao(Kl, "onSelect"),
        0 < c.length && (i = new Vl("onSelect","select",null,i,a),
        t.push({
            event: i,
            listeners: c
        }),
        i.target = ts)))
    }
    function io(t, i) {
        var a = {};
        return a[t.toLowerCase()] = i.toLowerCase(),
        a["Webkit" + t] = "webkit" + i,
        a["Moz" + t] = "moz" + i,
        a
    }
    var ns = {
        animationend: io("Animation", "AnimationEnd"),
        animationiteration: io("Animation", "AnimationIteration"),
        animationstart: io("Animation", "AnimationStart"),
        transitionend: io("Transition", "TransitionEnd")
    }
      , Zl = {}
      , Df = {};
    f && (Df = document.createElement("div").style,
    "AnimationEvent"in window || (delete ns.animationend.animation,
    delete ns.animationiteration.animation,
    delete ns.animationstart.animation),
    "TransitionEvent"in window || delete ns.transitionend.transition);
    function ro(t) {
        if (Zl[t])
            return Zl[t];
        if (!ns[t])
            return t;
        var i = ns[t], a;
        for (a in i)
            if (i.hasOwnProperty(a) && a in Df)
                return Zl[t] = i[a];
        return t
    }
    var If = ro("animationend")
      , Uf = ro("animationiteration")
      , Ff = ro("animationstart")
      , Of = ro("transitionend")
      , zf = new Map
      , kf = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function Ji(t, i) {
        zf.set(t, i),
        l(i, [t])
    }
    for (var ec = 0; ec < kf.length; ec++) {
        var tc = kf[ec]
          , a0 = tc.toLowerCase()
          , o0 = tc[0].toUpperCase() + tc.slice(1);
        Ji(a0, "on" + o0)
    }
    Ji(If, "onAnimationEnd"),
    Ji(Uf, "onAnimationIteration"),
    Ji(Ff, "onAnimationStart"),
    Ji("dblclick", "onDoubleClick"),
    Ji("focusin", "onFocus"),
    Ji("focusout", "onBlur"),
    Ji(Of, "onTransitionEnd"),
    u("onMouseEnter", ["mouseout", "mouseover"]),
    u("onMouseLeave", ["mouseout", "mouseover"]),
    u("onPointerEnter", ["pointerout", "pointerover"]),
    u("onPointerLeave", ["pointerout", "pointerover"]),
    l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var ra = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , l0 = new Set("cancel close invalid load scroll toggle".split(" ").concat(ra));
    function Bf(t, i, a) {
        var c = t.type || "unknown-event";
        t.currentTarget = a,
        ja(c, i, void 0, t),
        t.currentTarget = null
    }
    function Hf(t, i) {
        i = (i & 4) !== 0;
        for (var a = 0; a < t.length; a++) {
            var c = t[a]
              , d = c.event;
            c = c.listeners;
            e: {
                var h = void 0;
                if (i)
                    for (var w = c.length - 1; 0 <= w; w--) {
                        var D = c[w]
                          , B = D.instance
                          , Z = D.currentTarget;
                        if (D = D.listener,
                        B !== h && d.isPropagationStopped())
                            break e;
                        Bf(d, D, Z),
                        h = B
                    }
                else
                    for (w = 0; w < c.length; w++) {
                        if (D = c[w],
                        B = D.instance,
                        Z = D.currentTarget,
                        D = D.listener,
                        B !== h && d.isPropagationStopped())
                            break e;
                        Bf(d, D, Z),
                        h = B
                    }
            }
        }
        if (Mi)
            throw t = $r,
            Mi = !1,
            $r = null,
            t
    }
    function kt(t, i) {
        var a = i[cc];
        a === void 0 && (a = i[cc] = new Set);
        var c = t + "__bubble";
        a.has(c) || (Vf(i, t, 2, !1),
        a.add(c))
    }
    function nc(t, i, a) {
        var c = 0;
        i && (c |= 4),
        Vf(a, t, c, i)
    }
    var so = "_reactListening" + Math.random().toString(36).slice(2);
    function sa(t) {
        if (!t[so]) {
            t[so] = !0,
            r.forEach(function(a) {
                a !== "selectionchange" && (l0.has(a) || nc(a, !1, t),
                nc(a, !0, t))
            });
            var i = t.nodeType === 9 ? t : t.ownerDocument;
            i === null || i[so] || (i[so] = !0,
            nc("selectionchange", !1, i))
        }
    }
    function Vf(t, i, a, c) {
        switch (df(i)) {
        case 1:
            var d = wg;
            break;
        case 4:
            d = Mg;
            break;
        default:
            d = kl
        }
        a = d.bind(null, i, a, t),
        d = void 0,
        !qr || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (d = !0),
        c ? d !== void 0 ? t.addEventListener(i, a, {
            capture: !0,
            passive: d
        }) : t.addEventListener(i, a, !0) : d !== void 0 ? t.addEventListener(i, a, {
            passive: d
        }) : t.addEventListener(i, a, !1)
    }
    function ic(t, i, a, c, d) {
        var h = c;
        if ((i & 1) === 0 && (i & 2) === 0 && c !== null)
            e: for (; ; ) {
                if (c === null)
                    return;
                var w = c.tag;
                if (w === 3 || w === 4) {
                    var D = c.stateNode.containerInfo;
                    if (D === d || D.nodeType === 8 && D.parentNode === d)
                        break;
                    if (w === 4)
                        for (w = c.return; w !== null; ) {
                            var B = w.tag;
                            if ((B === 3 || B === 4) && (B = w.stateNode.containerInfo,
                            B === d || B.nodeType === 8 && B.parentNode === d))
                                return;
                            w = w.return
                        }
                    for (; D !== null; ) {
                        if (w = wr(D),
                        w === null)
                            return;
                        if (B = w.tag,
                        B === 5 || B === 6) {
                            c = h = w;
                            continue e
                        }
                        D = D.parentNode
                    }
                }
                c = c.return
            }
        Gn(function() {
            var Z = h
              , _e = G(a)
              , xe = [];
            e: {
                var ge = zf.get(t);
                if (ge !== void 0) {
                    var Ue = Vl
                      , Ve = t;
                    switch (t) {
                    case "keypress":
                        if (Za(a) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        Ue = zg;
                        break;
                    case "focusin":
                        Ve = "focus",
                        Ue = Wl;
                        break;
                    case "focusout":
                        Ve = "blur",
                        Ue = Wl;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        Ue = Wl;
                        break;
                    case "click":
                        if (a.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        Ue = pf;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        Ue = Ag;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        Ue = Hg;
                        break;
                    case If:
                    case Uf:
                    case Ff:
                        Ue = bg;
                        break;
                    case Of:
                        Ue = jg;
                        break;
                    case "scroll":
                        Ue = Eg;
                        break;
                    case "wheel":
                        Ue = Wg;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        Ue = Pg;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        Ue = gf
                    }
                    var Ge = (i & 4) !== 0
                      , Yt = !Ge && t === "scroll"
                      , q = Ge ? ge !== null ? ge + "Capture" : null : ge;
                    Ge = [];
                    for (var X = Z, K; X !== null; ) {
                        K = X;
                        var Ee = K.stateNode;
                        if (K.tag === 5 && Ee !== null && (K = Ee,
                        q !== null && (Ee = un(X, q),
                        Ee != null && Ge.push(aa(X, Ee, K)))),
                        Yt)
                            break;
                        X = X.return
                    }
                    0 < Ge.length && (ge = new Ue(ge,Ve,null,a,_e),
                    xe.push({
                        event: ge,
                        listeners: Ge
                    }))
                }
            }
            if ((i & 7) === 0) {
                e: {
                    if (ge = t === "mouseover" || t === "pointerover",
                    Ue = t === "mouseout" || t === "pointerout",
                    ge && a !== ct && (Ve = a.relatedTarget || a.fromElement) && (wr(Ve) || Ve[Ti]))
                        break e;
                    if ((Ue || ge) && (ge = _e.window === _e ? _e : (ge = _e.ownerDocument) ? ge.defaultView || ge.parentWindow : window,
                    Ue ? (Ve = a.relatedTarget || a.toElement,
                    Ue = Z,
                    Ve = Ve ? wr(Ve) : null,
                    Ve !== null && (Yt = Ei(Ve),
                    Ve !== Yt || Ve.tag !== 5 && Ve.tag !== 6) && (Ve = null)) : (Ue = null,
                    Ve = Z),
                    Ue !== Ve)) {
                        if (Ge = pf,
                        Ee = "onMouseLeave",
                        q = "onMouseEnter",
                        X = "mouse",
                        (t === "pointerout" || t === "pointerover") && (Ge = gf,
                        Ee = "onPointerLeave",
                        q = "onPointerEnter",
                        X = "pointer"),
                        Yt = Ue == null ? ge : ss(Ue),
                        K = Ve == null ? ge : ss(Ve),
                        ge = new Ge(Ee,X + "leave",Ue,a,_e),
                        ge.target = Yt,
                        ge.relatedTarget = K,
                        Ee = null,
                        wr(_e) === Z && (Ge = new Ge(q,X + "enter",Ve,a,_e),
                        Ge.target = K,
                        Ge.relatedTarget = Yt,
                        Ee = Ge),
                        Yt = Ee,
                        Ue && Ve)
                            t: {
                                for (Ge = Ue,
                                q = Ve,
                                X = 0,
                                K = Ge; K; K = is(K))
                                    X++;
                                for (K = 0,
                                Ee = q; Ee; Ee = is(Ee))
                                    K++;
                                for (; 0 < X - K; )
                                    Ge = is(Ge),
                                    X--;
                                for (; 0 < K - X; )
                                    q = is(q),
                                    K--;
                                for (; X--; ) {
                                    if (Ge === q || q !== null && Ge === q.alternate)
                                        break t;
                                    Ge = is(Ge),
                                    q = is(q)
                                }
                                Ge = null
                            }
                        else
                            Ge = null;
                        Ue !== null && jf(xe, ge, Ue, Ge, !1),
                        Ve !== null && Yt !== null && jf(xe, Yt, Ve, Ge, !0)
                    }
                }
                e: {
                    if (ge = Z ? ss(Z) : window,
                    Ue = ge.nodeName && ge.nodeName.toLowerCase(),
                    Ue === "select" || Ue === "input" && ge.type === "file")
                        var Xe = Qg;
                    else if (wf(ge))
                        if (Ef)
                            Xe = n0;
                        else {
                            Xe = e0;
                            var et = Zg
                        }
                    else
                        (Ue = ge.nodeName) && Ue.toLowerCase() === "input" && (ge.type === "checkbox" || ge.type === "radio") && (Xe = t0);
                    if (Xe && (Xe = Xe(t, Z))) {
                        Mf(xe, Xe, a, _e);
                        break e
                    }
                    et && et(t, ge, Z),
                    t === "focusout" && (et = ge._wrapperState) && et.controlled && ge.type === "number" && Fe(ge, "number", ge.value)
                }
                switch (et = Z ? ss(Z) : window,
                t) {
                case "focusin":
                    (wf(et) || et.contentEditable === "true") && (ts = et,
                    Kl = Z,
                    ia = null);
                    break;
                case "focusout":
                    ia = Kl = ts = null;
                    break;
                case "mousedown":
                    Ql = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Ql = !1,
                    Nf(xe, a, _e);
                    break;
                case "selectionchange":
                    if (s0)
                        break;
                case "keydown":
                case "keyup":
                    Nf(xe, a, _e)
                }
                var tt;
                if (Yl)
                    e: {
                        switch (t) {
                        case "compositionstart":
                            var at = "onCompositionStart";
                            break e;
                        case "compositionend":
                            at = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            at = "onCompositionUpdate";
                            break e
                        }
                        at = void 0
                    }
                else
                    es ? yf(t, a) && (at = "onCompositionEnd") : t === "keydown" && a.keyCode === 229 && (at = "onCompositionStart");
                at && (_f && a.locale !== "ko" && (es || at !== "onCompositionStart" ? at === "onCompositionEnd" && es && (tt = ff()) : (Yi = _e,
                Hl = "value"in Yi ? Yi.value : Yi.textContent,
                es = !0)),
                et = ao(Z, at),
                0 < et.length && (at = new mf(at,t,null,a,_e),
                xe.push({
                    event: at,
                    listeners: et
                }),
                tt ? at.data = tt : (tt = Sf(a),
                tt !== null && (at.data = tt)))),
                (tt = Yg ? Jg(t, a) : qg(t, a)) && (Z = ao(Z, "onBeforeInput"),
                0 < Z.length && (_e = new mf("onBeforeInput","beforeinput",null,a,_e),
                xe.push({
                    event: _e,
                    listeners: Z
                }),
                _e.data = tt))
            }
            Hf(xe, i)
        })
    }
    function aa(t, i, a) {
        return {
            instance: t,
            listener: i,
            currentTarget: a
        }
    }
    function ao(t, i) {
        for (var a = i + "Capture", c = []; t !== null; ) {
            var d = t
              , h = d.stateNode;
            d.tag === 5 && h !== null && (d = h,
            h = un(t, a),
            h != null && c.unshift(aa(t, h, d)),
            h = un(t, i),
            h != null && c.push(aa(t, h, d))),
            t = t.return
        }
        return c
    }
    function is(t) {
        if (t === null)
            return null;
        do
            t = t.return;
        while (t && t.tag !== 5);
        return t || null
    }
    function jf(t, i, a, c, d) {
        for (var h = i._reactName, w = []; a !== null && a !== c; ) {
            var D = a
              , B = D.alternate
              , Z = D.stateNode;
            if (B !== null && B === c)
                break;
            D.tag === 5 && Z !== null && (D = Z,
            d ? (B = un(a, h),
            B != null && w.unshift(aa(a, B, D))) : d || (B = un(a, h),
            B != null && w.push(aa(a, B, D)))),
            a = a.return
        }
        w.length !== 0 && t.push({
            event: i,
            listeners: w
        })
    }
    var c0 = /\r\n?/g
      , u0 = /\u0000|\uFFFD/g;
    function Gf(t) {
        return (typeof t == "string" ? t : "" + t).replace(c0, `
`).replace(u0, "")
    }
    function oo(t, i, a) {
        if (i = Gf(i),
        Gf(t) !== i && a)
            throw Error(n(425))
    }
    function lo() {}
    var rc = null
      , sc = null;
    function ac(t, i) {
        return t === "textarea" || t === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null
    }
    var oc = typeof setTimeout == "function" ? setTimeout : void 0
      , d0 = typeof clearTimeout == "function" ? clearTimeout : void 0
      , Wf = typeof Promise == "function" ? Promise : void 0
      , f0 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Wf < "u" ? function(t) {
        return Wf.resolve(null).then(t).catch(h0)
    }
    : oc;
    function h0(t) {
        setTimeout(function() {
            throw t
        })
    }
    function lc(t, i) {
        var a = i
          , c = 0;
        do {
            var d = a.nextSibling;
            if (t.removeChild(a),
            d && d.nodeType === 8)
                if (a = d.data,
                a === "/$") {
                    if (c === 0) {
                        t.removeChild(d),
                        $s(i);
                        return
                    }
                    c--
                } else
                    a !== "$" && a !== "$?" && a !== "$!" || c++;
            a = d
        } while (a);
        $s(i)
    }
    function qi(t) {
        for (; t != null; t = t.nextSibling) {
            var i = t.nodeType;
            if (i === 1 || i === 3)
                break;
            if (i === 8) {
                if (i = t.data,
                i === "$" || i === "$!" || i === "$?")
                    break;
                if (i === "/$")
                    return null
            }
        }
        return t
    }
    function Xf(t) {
        t = t.previousSibling;
        for (var i = 0; t; ) {
            if (t.nodeType === 8) {
                var a = t.data;
                if (a === "$" || a === "$!" || a === "$?") {
                    if (i === 0)
                        return t;
                    i--
                } else
                    a === "/$" && i++
            }
            t = t.previousSibling
        }
        return null
    }
    var rs = Math.random().toString(36).slice(2)
      , pi = "__reactFiber$" + rs
      , oa = "__reactProps$" + rs
      , Ti = "__reactContainer$" + rs
      , cc = "__reactEvents$" + rs
      , p0 = "__reactListeners$" + rs
      , m0 = "__reactHandles$" + rs;
    function wr(t) {
        var i = t[pi];
        if (i)
            return i;
        for (var a = t.parentNode; a; ) {
            if (i = a[Ti] || a[pi]) {
                if (a = i.alternate,
                i.child !== null || a !== null && a.child !== null)
                    for (t = Xf(t); t !== null; ) {
                        if (a = t[pi])
                            return a;
                        t = Xf(t)
                    }
                return i
            }
            t = a,
            a = t.parentNode
        }
        return null
    }
    function la(t) {
        return t = t[pi] || t[Ti],
        !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
    }
    function ss(t) {
        if (t.tag === 5 || t.tag === 6)
            return t.stateNode;
        throw Error(n(33))
    }
    function co(t) {
        return t[oa] || null
    }
    var uc = []
      , as = -1;
    function $i(t) {
        return {
            current: t
        }
    }
    function Bt(t) {
        0 > as || (t.current = uc[as],
        uc[as] = null,
        as--)
    }
    function Ft(t, i) {
        as++,
        uc[as] = t.current,
        t.current = i
    }
    var Ki = {}
      , hn = $i(Ki)
      , Tn = $i(!1)
      , Mr = Ki;
    function os(t, i) {
        var a = t.type.contextTypes;
        if (!a)
            return Ki;
        var c = t.stateNode;
        if (c && c.__reactInternalMemoizedUnmaskedChildContext === i)
            return c.__reactInternalMemoizedMaskedChildContext;
        var d = {}, h;
        for (h in a)
            d[h] = i[h];
        return c && (t = t.stateNode,
        t.__reactInternalMemoizedUnmaskedChildContext = i,
        t.__reactInternalMemoizedMaskedChildContext = d),
        d
    }
    function An(t) {
        return t = t.childContextTypes,
        t != null
    }
    function uo() {
        Bt(Tn),
        Bt(hn)
    }
    function Yf(t, i, a) {
        if (hn.current !== Ki)
            throw Error(n(168));
        Ft(hn, i),
        Ft(Tn, a)
    }
    function Jf(t, i, a) {
        var c = t.stateNode;
        if (i = i.childContextTypes,
        typeof c.getChildContext != "function")
            return a;
        c = c.getChildContext();
        for (var d in c)
            if (!(d in i))
                throw Error(n(108, pe(t) || "Unknown", d));
        return re({}, a, c)
    }
    function fo(t) {
        return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Ki,
        Mr = hn.current,
        Ft(hn, t),
        Ft(Tn, Tn.current),
        !0
    }
    function qf(t, i, a) {
        var c = t.stateNode;
        if (!c)
            throw Error(n(169));
        a ? (t = Jf(t, i, Mr),
        c.__reactInternalMemoizedMergedChildContext = t,
        Bt(Tn),
        Bt(hn),
        Ft(hn, t)) : Bt(Tn),
        Ft(Tn, a)
    }
    var Ai = null
      , ho = !1
      , dc = !1;
    function $f(t) {
        Ai === null ? Ai = [t] : Ai.push(t)
    }
    function g0(t) {
        ho = !0,
        $f(t)
    }
    function Qi() {
        if (!dc && Ai !== null) {
            dc = !0;
            var t = 0
              , i = pt;
            try {
                var a = Ai;
                for (pt = 1; t < a.length; t++) {
                    var c = a[t];
                    do
                        c = c(!0);
                    while (c !== null)
                }
                Ai = null,
                ho = !1
            } catch (d) {
                throw Ai !== null && (Ai = Ai.slice(t + 1)),
                A(be, Qi),
                d
            } finally {
                pt = i,
                dc = !1
            }
        }
        return null
    }
    var ls = []
      , cs = 0
      , po = null
      , mo = 0
      , Wn = []
      , Xn = 0
      , Er = null
      , Ci = 1
      , Ri = "";
    function Tr(t, i) {
        ls[cs++] = mo,
        ls[cs++] = po,
        po = t,
        mo = i
    }
    function Kf(t, i, a) {
        Wn[Xn++] = Ci,
        Wn[Xn++] = Ri,
        Wn[Xn++] = Er,
        Er = t;
        var c = Ci;
        t = Ri;
        var d = 32 - St(c) - 1;
        c &= ~(1 << d),
        a += 1;
        var h = 32 - St(i) + d;
        if (30 < h) {
            var w = d - d % 5;
            h = (c & (1 << w) - 1).toString(32),
            c >>= w,
            d -= w,
            Ci = 1 << 32 - St(i) + d | a << d | c,
            Ri = h + t
        } else
            Ci = 1 << h | a << d | c,
            Ri = t
    }
    function fc(t) {
        t.return !== null && (Tr(t, 1),
        Kf(t, 1, 0))
    }
    function hc(t) {
        for (; t === po; )
            po = ls[--cs],
            ls[cs] = null,
            mo = ls[--cs],
            ls[cs] = null;
        for (; t === Er; )
            Er = Wn[--Xn],
            Wn[Xn] = null,
            Ri = Wn[--Xn],
            Wn[Xn] = null,
            Ci = Wn[--Xn],
            Wn[Xn] = null
    }
    var zn = null
      , kn = null
      , Ht = !1
      , ni = null;
    function Qf(t, i) {
        var a = $n(5, null, null, 0);
        a.elementType = "DELETED",
        a.stateNode = i,
        a.return = t,
        i = t.deletions,
        i === null ? (t.deletions = [a],
        t.flags |= 16) : i.push(a)
    }
    function Zf(t, i) {
        switch (t.tag) {
        case 5:
            var a = t.type;
            return i = i.nodeType !== 1 || a.toLowerCase() !== i.nodeName.toLowerCase() ? null : i,
            i !== null ? (t.stateNode = i,
            zn = t,
            kn = qi(i.firstChild),
            !0) : !1;
        case 6:
            return i = t.pendingProps === "" || i.nodeType !== 3 ? null : i,
            i !== null ? (t.stateNode = i,
            zn = t,
            kn = null,
            !0) : !1;
        case 13:
            return i = i.nodeType !== 8 ? null : i,
            i !== null ? (a = Er !== null ? {
                id: Ci,
                overflow: Ri
            } : null,
            t.memoizedState = {
                dehydrated: i,
                treeContext: a,
                retryLane: 1073741824
            },
            a = $n(18, null, null, 0),
            a.stateNode = i,
            a.return = t,
            t.child = a,
            zn = t,
            kn = null,
            !0) : !1;
        default:
            return !1
        }
    }
    function pc(t) {
        return (t.mode & 1) !== 0 && (t.flags & 128) === 0
    }
    function mc(t) {
        if (Ht) {
            var i = kn;
            if (i) {
                var a = i;
                if (!Zf(t, i)) {
                    if (pc(t))
                        throw Error(n(418));
                    i = qi(a.nextSibling);
                    var c = zn;
                    i && Zf(t, i) ? Qf(c, a) : (t.flags = t.flags & -4097 | 2,
                    Ht = !1,
                    zn = t)
                }
            } else {
                if (pc(t))
                    throw Error(n(418));
                t.flags = t.flags & -4097 | 2,
                Ht = !1,
                zn = t
            }
        }
    }
    function eh(t) {
        for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
            t = t.return;
        zn = t
    }
    function go(t) {
        if (t !== zn)
            return !1;
        if (!Ht)
            return eh(t),
            Ht = !0,
            !1;
        var i;
        if ((i = t.tag !== 3) && !(i = t.tag !== 5) && (i = t.type,
        i = i !== "head" && i !== "body" && !ac(t.type, t.memoizedProps)),
        i && (i = kn)) {
            if (pc(t))
                throw th(),
                Error(n(418));
            for (; i; )
                Qf(t, i),
                i = qi(i.nextSibling)
        }
        if (eh(t),
        t.tag === 13) {
            if (t = t.memoizedState,
            t = t !== null ? t.dehydrated : null,
            !t)
                throw Error(n(317));
            e: {
                for (t = t.nextSibling,
                i = 0; t; ) {
                    if (t.nodeType === 8) {
                        var a = t.data;
                        if (a === "/$") {
                            if (i === 0) {
                                kn = qi(t.nextSibling);
                                break e
                            }
                            i--
                        } else
                            a !== "$" && a !== "$!" && a !== "$?" || i++
                    }
                    t = t.nextSibling
                }
                kn = null
            }
        } else
            kn = zn ? qi(t.stateNode.nextSibling) : null;
        return !0
    }
    function th() {
        for (var t = kn; t; )
            t = qi(t.nextSibling)
    }
    function us() {
        kn = zn = null,
        Ht = !1
    }
    function gc(t) {
        ni === null ? ni = [t] : ni.push(t)
    }
    var _0 = C.ReactCurrentBatchConfig;
    function ca(t, i, a) {
        if (t = a.ref,
        t !== null && typeof t != "function" && typeof t != "object") {
            if (a._owner) {
                if (a = a._owner,
                a) {
                    if (a.tag !== 1)
                        throw Error(n(309));
                    var c = a.stateNode
                }
                if (!c)
                    throw Error(n(147, t));
                var d = c
                  , h = "" + t;
                return i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === h ? i.ref : (i = function(w) {
                    var D = d.refs;
                    w === null ? delete D[h] : D[h] = w
                }
                ,
                i._stringRef = h,
                i)
            }
            if (typeof t != "string")
                throw Error(n(284));
            if (!a._owner)
                throw Error(n(290, t))
        }
        return t
    }
    function _o(t, i) {
        throw t = Object.prototype.toString.call(i),
        Error(n(31, t === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : t))
    }
    function nh(t) {
        var i = t._init;
        return i(t._payload)
    }
    function ih(t) {
        function i(q, X) {
            if (t) {
                var K = q.deletions;
                K === null ? (q.deletions = [X],
                q.flags |= 16) : K.push(X)
            }
        }
        function a(q, X) {
            if (!t)
                return null;
            for (; X !== null; )
                i(q, X),
                X = X.sibling;
            return null
        }
        function c(q, X) {
            for (q = new Map; X !== null; )
                X.key !== null ? q.set(X.key, X) : q.set(X.index, X),
                X = X.sibling;
            return q
        }
        function d(q, X) {
            return q = ar(q, X),
            q.index = 0,
            q.sibling = null,
            q
        }
        function h(q, X, K) {
            return q.index = K,
            t ? (K = q.alternate,
            K !== null ? (K = K.index,
            K < X ? (q.flags |= 2,
            X) : K) : (q.flags |= 2,
            X)) : (q.flags |= 1048576,
            X)
        }
        function w(q) {
            return t && q.alternate === null && (q.flags |= 2),
            q
        }
        function D(q, X, K, Ee) {
            return X === null || X.tag !== 6 ? (X = ou(K, q.mode, Ee),
            X.return = q,
            X) : (X = d(X, K),
            X.return = q,
            X)
        }
        function B(q, X, K, Ee) {
            var Xe = K.type;
            return Xe === F ? _e(q, X, K.props.children, Ee, K.key) : X !== null && (X.elementType === Xe || typeof Xe == "object" && Xe !== null && Xe.$$typeof === ae && nh(Xe) === X.type) ? (Ee = d(X, K.props),
            Ee.ref = ca(q, X, K),
            Ee.return = q,
            Ee) : (Ee = Ho(K.type, K.key, K.props, null, q.mode, Ee),
            Ee.ref = ca(q, X, K),
            Ee.return = q,
            Ee)
        }
        function Z(q, X, K, Ee) {
            return X === null || X.tag !== 4 || X.stateNode.containerInfo !== K.containerInfo || X.stateNode.implementation !== K.implementation ? (X = lu(K, q.mode, Ee),
            X.return = q,
            X) : (X = d(X, K.children || []),
            X.return = q,
            X)
        }
        function _e(q, X, K, Ee, Xe) {
            return X === null || X.tag !== 7 ? (X = Dr(K, q.mode, Ee, Xe),
            X.return = q,
            X) : (X = d(X, K),
            X.return = q,
            X)
        }
        function xe(q, X, K) {
            if (typeof X == "string" && X !== "" || typeof X == "number")
                return X = ou("" + X, q.mode, K),
                X.return = q,
                X;
            if (typeof X == "object" && X !== null) {
                switch (X.$$typeof) {
                case H:
                    return K = Ho(X.type, X.key, X.props, null, q.mode, K),
                    K.ref = ca(q, null, X),
                    K.return = q,
                    K;
                case k:
                    return X = lu(X, q.mode, K),
                    X.return = q,
                    X;
                case ae:
                    var Ee = X._init;
                    return xe(q, Ee(X._payload), K)
                }
                if (lt(X) || ue(X))
                    return X = Dr(X, q.mode, K, null),
                    X.return = q,
                    X;
                _o(q, X)
            }
            return null
        }
        function ge(q, X, K, Ee) {
            var Xe = X !== null ? X.key : null;
            if (typeof K == "string" && K !== "" || typeof K == "number")
                return Xe !== null ? null : D(q, X, "" + K, Ee);
            if (typeof K == "object" && K !== null) {
                switch (K.$$typeof) {
                case H:
                    return K.key === Xe ? B(q, X, K, Ee) : null;
                case k:
                    return K.key === Xe ? Z(q, X, K, Ee) : null;
                case ae:
                    return Xe = K._init,
                    ge(q, X, Xe(K._payload), Ee)
                }
                if (lt(K) || ue(K))
                    return Xe !== null ? null : _e(q, X, K, Ee, null);
                _o(q, K)
            }
            return null
        }
        function Ue(q, X, K, Ee, Xe) {
            if (typeof Ee == "string" && Ee !== "" || typeof Ee == "number")
                return q = q.get(K) || null,
                D(X, q, "" + Ee, Xe);
            if (typeof Ee == "object" && Ee !== null) {
                switch (Ee.$$typeof) {
                case H:
                    return q = q.get(Ee.key === null ? K : Ee.key) || null,
                    B(X, q, Ee, Xe);
                case k:
                    return q = q.get(Ee.key === null ? K : Ee.key) || null,
                    Z(X, q, Ee, Xe);
                case ae:
                    var et = Ee._init;
                    return Ue(q, X, K, et(Ee._payload), Xe)
                }
                if (lt(Ee) || ue(Ee))
                    return q = q.get(K) || null,
                    _e(X, q, Ee, Xe, null);
                _o(X, Ee)
            }
            return null
        }
        function Ve(q, X, K, Ee) {
            for (var Xe = null, et = null, tt = X, at = X = 0, rn = null; tt !== null && at < K.length; at++) {
                tt.index > at ? (rn = tt,
                tt = null) : rn = tt.sibling;
                var Mt = ge(q, tt, K[at], Ee);
                if (Mt === null) {
                    tt === null && (tt = rn);
                    break
                }
                t && tt && Mt.alternate === null && i(q, tt),
                X = h(Mt, X, at),
                et === null ? Xe = Mt : et.sibling = Mt,
                et = Mt,
                tt = rn
            }
            if (at === K.length)
                return a(q, tt),
                Ht && Tr(q, at),
                Xe;
            if (tt === null) {
                for (; at < K.length; at++)
                    tt = xe(q, K[at], Ee),
                    tt !== null && (X = h(tt, X, at),
                    et === null ? Xe = tt : et.sibling = tt,
                    et = tt);
                return Ht && Tr(q, at),
                Xe
            }
            for (tt = c(q, tt); at < K.length; at++)
                rn = Ue(tt, q, at, K[at], Ee),
                rn !== null && (t && rn.alternate !== null && tt.delete(rn.key === null ? at : rn.key),
                X = h(rn, X, at),
                et === null ? Xe = rn : et.sibling = rn,
                et = rn);
            return t && tt.forEach(function(or) {
                return i(q, or)
            }),
            Ht && Tr(q, at),
            Xe
        }
        function Ge(q, X, K, Ee) {
            var Xe = ue(K);
            if (typeof Xe != "function")
                throw Error(n(150));
            if (K = Xe.call(K),
            K == null)
                throw Error(n(151));
            for (var et = Xe = null, tt = X, at = X = 0, rn = null, Mt = K.next(); tt !== null && !Mt.done; at++,
            Mt = K.next()) {
                tt.index > at ? (rn = tt,
                tt = null) : rn = tt.sibling;
                var or = ge(q, tt, Mt.value, Ee);
                if (or === null) {
                    tt === null && (tt = rn);
                    break
                }
                t && tt && or.alternate === null && i(q, tt),
                X = h(or, X, at),
                et === null ? Xe = or : et.sibling = or,
                et = or,
                tt = rn
            }
            if (Mt.done)
                return a(q, tt),
                Ht && Tr(q, at),
                Xe;
            if (tt === null) {
                for (; !Mt.done; at++,
                Mt = K.next())
                    Mt = xe(q, Mt.value, Ee),
                    Mt !== null && (X = h(Mt, X, at),
                    et === null ? Xe = Mt : et.sibling = Mt,
                    et = Mt);
                return Ht && Tr(q, at),
                Xe
            }
            for (tt = c(q, tt); !Mt.done; at++,
            Mt = K.next())
                Mt = Ue(tt, q, at, Mt.value, Ee),
                Mt !== null && (t && Mt.alternate !== null && tt.delete(Mt.key === null ? at : Mt.key),
                X = h(Mt, X, at),
                et === null ? Xe = Mt : et.sibling = Mt,
                et = Mt);
            return t && tt.forEach(function($0) {
                return i(q, $0)
            }),
            Ht && Tr(q, at),
            Xe
        }
        function Yt(q, X, K, Ee) {
            if (typeof K == "object" && K !== null && K.type === F && K.key === null && (K = K.props.children),
            typeof K == "object" && K !== null) {
                switch (K.$$typeof) {
                case H:
                    e: {
                        for (var Xe = K.key, et = X; et !== null; ) {
                            if (et.key === Xe) {
                                if (Xe = K.type,
                                Xe === F) {
                                    if (et.tag === 7) {
                                        a(q, et.sibling),
                                        X = d(et, K.props.children),
                                        X.return = q,
                                        q = X;
                                        break e
                                    }
                                } else if (et.elementType === Xe || typeof Xe == "object" && Xe !== null && Xe.$$typeof === ae && nh(Xe) === et.type) {
                                    a(q, et.sibling),
                                    X = d(et, K.props),
                                    X.ref = ca(q, et, K),
                                    X.return = q,
                                    q = X;
                                    break e
                                }
                                a(q, et);
                                break
                            } else
                                i(q, et);
                            et = et.sibling
                        }
                        K.type === F ? (X = Dr(K.props.children, q.mode, Ee, K.key),
                        X.return = q,
                        q = X) : (Ee = Ho(K.type, K.key, K.props, null, q.mode, Ee),
                        Ee.ref = ca(q, X, K),
                        Ee.return = q,
                        q = Ee)
                    }
                    return w(q);
                case k:
                    e: {
                        for (et = K.key; X !== null; ) {
                            if (X.key === et)
                                if (X.tag === 4 && X.stateNode.containerInfo === K.containerInfo && X.stateNode.implementation === K.implementation) {
                                    a(q, X.sibling),
                                    X = d(X, K.children || []),
                                    X.return = q,
                                    q = X;
                                    break e
                                } else {
                                    a(q, X);
                                    break
                                }
                            else
                                i(q, X);
                            X = X.sibling
                        }
                        X = lu(K, q.mode, Ee),
                        X.return = q,
                        q = X
                    }
                    return w(q);
                case ae:
                    return et = K._init,
                    Yt(q, X, et(K._payload), Ee)
                }
                if (lt(K))
                    return Ve(q, X, K, Ee);
                if (ue(K))
                    return Ge(q, X, K, Ee);
                _o(q, K)
            }
            return typeof K == "string" && K !== "" || typeof K == "number" ? (K = "" + K,
            X !== null && X.tag === 6 ? (a(q, X.sibling),
            X = d(X, K),
            X.return = q,
            q = X) : (a(q, X),
            X = ou(K, q.mode, Ee),
            X.return = q,
            q = X),
            w(q)) : a(q, X)
        }
        return Yt
    }
    var ds = ih(!0)
      , rh = ih(!1)
      , vo = $i(null)
      , xo = null
      , fs = null
      , _c = null;
    function vc() {
        _c = fs = xo = null
    }
    function xc(t) {
        var i = vo.current;
        Bt(vo),
        t._currentValue = i
    }
    function yc(t, i, a) {
        for (; t !== null; ) {
            var c = t.alternate;
            if ((t.childLanes & i) !== i ? (t.childLanes |= i,
            c !== null && (c.childLanes |= i)) : c !== null && (c.childLanes & i) !== i && (c.childLanes |= i),
            t === a)
                break;
            t = t.return
        }
    }
    function hs(t, i) {
        xo = t,
        _c = fs = null,
        t = t.dependencies,
        t !== null && t.firstContext !== null && ((t.lanes & i) !== 0 && (Cn = !0),
        t.firstContext = null)
    }
    function Yn(t) {
        var i = t._currentValue;
        if (_c !== t)
            if (t = {
                context: t,
                memoizedValue: i,
                next: null
            },
            fs === null) {
                if (xo === null)
                    throw Error(n(308));
                fs = t,
                xo.dependencies = {
                    lanes: 0,
                    firstContext: t
                }
            } else
                fs = fs.next = t;
        return i
    }
    var Ar = null;
    function Sc(t) {
        Ar === null ? Ar = [t] : Ar.push(t)
    }
    function sh(t, i, a, c) {
        var d = i.interleaved;
        return d === null ? (a.next = a,
        Sc(i)) : (a.next = d.next,
        d.next = a),
        i.interleaved = a,
        bi(t, c)
    }
    function bi(t, i) {
        t.lanes |= i;
        var a = t.alternate;
        for (a !== null && (a.lanes |= i),
        a = t,
        t = t.return; t !== null; )
            t.childLanes |= i,
            a = t.alternate,
            a !== null && (a.childLanes |= i),
            a = t,
            t = t.return;
        return a.tag === 3 ? a.stateNode : null
    }
    var Zi = !1;
    function wc(t) {
        t.updateQueue = {
            baseState: t.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function ah(t, i) {
        t = t.updateQueue,
        i.updateQueue === t && (i.updateQueue = {
            baseState: t.baseState,
            firstBaseUpdate: t.firstBaseUpdate,
            lastBaseUpdate: t.lastBaseUpdate,
            shared: t.shared,
            effects: t.effects
        })
    }
    function Li(t, i) {
        return {
            eventTime: t,
            lane: i,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function er(t, i, a) {
        var c = t.updateQueue;
        if (c === null)
            return null;
        if (c = c.shared,
        (wt & 2) !== 0) {
            var d = c.pending;
            return d === null ? i.next = i : (i.next = d.next,
            d.next = i),
            c.pending = i,
            bi(t, a)
        }
        return d = c.interleaved,
        d === null ? (i.next = i,
        Sc(c)) : (i.next = d.next,
        d.next = i),
        c.interleaved = i,
        bi(t, a)
    }
    function yo(t, i, a) {
        if (i = i.updateQueue,
        i !== null && (i = i.shared,
        (a & 4194240) !== 0)) {
            var c = i.lanes;
            c &= t.pendingLanes,
            a |= c,
            i.lanes = a,
            Sr(t, a)
        }
    }
    function oh(t, i) {
        var a = t.updateQueue
          , c = t.alternate;
        if (c !== null && (c = c.updateQueue,
        a === c)) {
            var d = null
              , h = null;
            if (a = a.firstBaseUpdate,
            a !== null) {
                do {
                    var w = {
                        eventTime: a.eventTime,
                        lane: a.lane,
                        tag: a.tag,
                        payload: a.payload,
                        callback: a.callback,
                        next: null
                    };
                    h === null ? d = h = w : h = h.next = w,
                    a = a.next
                } while (a !== null);
                h === null ? d = h = i : h = h.next = i
            } else
                d = h = i;
            a = {
                baseState: c.baseState,
                firstBaseUpdate: d,
                lastBaseUpdate: h,
                shared: c.shared,
                effects: c.effects
            },
            t.updateQueue = a;
            return
        }
        t = a.lastBaseUpdate,
        t === null ? a.firstBaseUpdate = i : t.next = i,
        a.lastBaseUpdate = i
    }
    function So(t, i, a, c) {
        var d = t.updateQueue;
        Zi = !1;
        var h = d.firstBaseUpdate
          , w = d.lastBaseUpdate
          , D = d.shared.pending;
        if (D !== null) {
            d.shared.pending = null;
            var B = D
              , Z = B.next;
            B.next = null,
            w === null ? h = Z : w.next = Z,
            w = B;
            var _e = t.alternate;
            _e !== null && (_e = _e.updateQueue,
            D = _e.lastBaseUpdate,
            D !== w && (D === null ? _e.firstBaseUpdate = Z : D.next = Z,
            _e.lastBaseUpdate = B))
        }
        if (h !== null) {
            var xe = d.baseState;
            w = 0,
            _e = Z = B = null,
            D = h;
            do {
                var ge = D.lane
                  , Ue = D.eventTime;
                if ((c & ge) === ge) {
                    _e !== null && (_e = _e.next = {
                        eventTime: Ue,
                        lane: 0,
                        tag: D.tag,
                        payload: D.payload,
                        callback: D.callback,
                        next: null
                    });
                    e: {
                        var Ve = t
                          , Ge = D;
                        switch (ge = i,
                        Ue = a,
                        Ge.tag) {
                        case 1:
                            if (Ve = Ge.payload,
                            typeof Ve == "function") {
                                xe = Ve.call(Ue, xe, ge);
                                break e
                            }
                            xe = Ve;
                            break e;
                        case 3:
                            Ve.flags = Ve.flags & -65537 | 128;
                        case 0:
                            if (Ve = Ge.payload,
                            ge = typeof Ve == "function" ? Ve.call(Ue, xe, ge) : Ve,
                            ge == null)
                                break e;
                            xe = re({}, xe, ge);
                            break e;
                        case 2:
                            Zi = !0
                        }
                    }
                    D.callback !== null && D.lane !== 0 && (t.flags |= 64,
                    ge = d.effects,
                    ge === null ? d.effects = [D] : ge.push(D))
                } else
                    Ue = {
                        eventTime: Ue,
                        lane: ge,
                        tag: D.tag,
                        payload: D.payload,
                        callback: D.callback,
                        next: null
                    },
                    _e === null ? (Z = _e = Ue,
                    B = xe) : _e = _e.next = Ue,
                    w |= ge;
                if (D = D.next,
                D === null) {
                    if (D = d.shared.pending,
                    D === null)
                        break;
                    ge = D,
                    D = ge.next,
                    ge.next = null,
                    d.lastBaseUpdate = ge,
                    d.shared.pending = null
                }
            } while (!0);
            if (_e === null && (B = xe),
            d.baseState = B,
            d.firstBaseUpdate = Z,
            d.lastBaseUpdate = _e,
            i = d.shared.interleaved,
            i !== null) {
                d = i;
                do
                    w |= d.lane,
                    d = d.next;
                while (d !== i)
            } else
                h === null && (d.shared.lanes = 0);
            br |= w,
            t.lanes = w,
            t.memoizedState = xe
        }
    }
    function lh(t, i, a) {
        if (t = i.effects,
        i.effects = null,
        t !== null)
            for (i = 0; i < t.length; i++) {
                var c = t[i]
                  , d = c.callback;
                if (d !== null) {
                    if (c.callback = null,
                    c = a,
                    typeof d != "function")
                        throw Error(n(191, d));
                    d.call(c)
                }
            }
    }
    var ua = {}
      , mi = $i(ua)
      , da = $i(ua)
      , fa = $i(ua);
    function Cr(t) {
        if (t === ua)
            throw Error(n(174));
        return t
    }
    function Mc(t, i) {
        switch (Ft(fa, i),
        Ft(da, t),
        Ft(mi, ua),
        t = i.nodeType,
        t) {
        case 9:
        case 11:
            i = (i = i.documentElement) ? i.namespaceURI : ve(null, "");
            break;
        default:
            t = t === 8 ? i.parentNode : i,
            i = t.namespaceURI || null,
            t = t.tagName,
            i = ve(i, t)
        }
        Bt(mi),
        Ft(mi, i)
    }
    function ps() {
        Bt(mi),
        Bt(da),
        Bt(fa)
    }
    function ch(t) {
        Cr(fa.current);
        var i = Cr(mi.current)
          , a = ve(i, t.type);
        i !== a && (Ft(da, t),
        Ft(mi, a))
    }
    function Ec(t) {
        da.current === t && (Bt(mi),
        Bt(da))
    }
    var jt = $i(0);
    function wo(t) {
        for (var i = t; i !== null; ) {
            if (i.tag === 13) {
                var a = i.memoizedState;
                if (a !== null && (a = a.dehydrated,
                a === null || a.data === "$?" || a.data === "$!"))
                    return i
            } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
                if ((i.flags & 128) !== 0)
                    return i
            } else if (i.child !== null) {
                i.child.return = i,
                i = i.child;
                continue
            }
            if (i === t)
                break;
            for (; i.sibling === null; ) {
                if (i.return === null || i.return === t)
                    return null;
                i = i.return
            }
            i.sibling.return = i.return,
            i = i.sibling
        }
        return null
    }
    var Tc = [];
    function Ac() {
        for (var t = 0; t < Tc.length; t++)
            Tc[t]._workInProgressVersionPrimary = null;
        Tc.length = 0
    }
    var Mo = C.ReactCurrentDispatcher
      , Cc = C.ReactCurrentBatchConfig
      , Rr = 0
      , Gt = null
      , Kt = null
      , tn = null
      , Eo = !1
      , ha = !1
      , pa = 0
      , v0 = 0;
    function pn() {
        throw Error(n(321))
    }
    function Rc(t, i) {
        if (i === null)
            return !1;
        for (var a = 0; a < i.length && a < t.length; a++)
            if (!ti(t[a], i[a]))
                return !1;
        return !0
    }
    function bc(t, i, a, c, d, h) {
        if (Rr = h,
        Gt = i,
        i.memoizedState = null,
        i.updateQueue = null,
        i.lanes = 0,
        Mo.current = t === null || t.memoizedState === null ? w0 : M0,
        t = a(c, d),
        ha) {
            h = 0;
            do {
                if (ha = !1,
                pa = 0,
                25 <= h)
                    throw Error(n(301));
                h += 1,
                tn = Kt = null,
                i.updateQueue = null,
                Mo.current = E0,
                t = a(c, d)
            } while (ha)
        }
        if (Mo.current = Co,
        i = Kt !== null && Kt.next !== null,
        Rr = 0,
        tn = Kt = Gt = null,
        Eo = !1,
        i)
            throw Error(n(300));
        return t
    }
    function Lc() {
        var t = pa !== 0;
        return pa = 0,
        t
    }
    function gi() {
        var t = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return tn === null ? Gt.memoizedState = tn = t : tn = tn.next = t,
        tn
    }
    function Jn() {
        if (Kt === null) {
            var t = Gt.alternate;
            t = t !== null ? t.memoizedState : null
        } else
            t = Kt.next;
        var i = tn === null ? Gt.memoizedState : tn.next;
        if (i !== null)
            tn = i,
            Kt = t;
        else {
            if (t === null)
                throw Error(n(310));
            Kt = t,
            t = {
                memoizedState: Kt.memoizedState,
                baseState: Kt.baseState,
                baseQueue: Kt.baseQueue,
                queue: Kt.queue,
                next: null
            },
            tn === null ? Gt.memoizedState = tn = t : tn = tn.next = t
        }
        return tn
    }
    function ma(t, i) {
        return typeof i == "function" ? i(t) : i
    }
    function Pc(t) {
        var i = Jn()
          , a = i.queue;
        if (a === null)
            throw Error(n(311));
        a.lastRenderedReducer = t;
        var c = Kt
          , d = c.baseQueue
          , h = a.pending;
        if (h !== null) {
            if (d !== null) {
                var w = d.next;
                d.next = h.next,
                h.next = w
            }
            c.baseQueue = d = h,
            a.pending = null
        }
        if (d !== null) {
            h = d.next,
            c = c.baseState;
            var D = w = null
              , B = null
              , Z = h;
            do {
                var _e = Z.lane;
                if ((Rr & _e) === _e)
                    B !== null && (B = B.next = {
                        lane: 0,
                        action: Z.action,
                        hasEagerState: Z.hasEagerState,
                        eagerState: Z.eagerState,
                        next: null
                    }),
                    c = Z.hasEagerState ? Z.eagerState : t(c, Z.action);
                else {
                    var xe = {
                        lane: _e,
                        action: Z.action,
                        hasEagerState: Z.hasEagerState,
                        eagerState: Z.eagerState,
                        next: null
                    };
                    B === null ? (D = B = xe,
                    w = c) : B = B.next = xe,
                    Gt.lanes |= _e,
                    br |= _e
                }
                Z = Z.next
            } while (Z !== null && Z !== h);
            B === null ? w = c : B.next = D,
            ti(c, i.memoizedState) || (Cn = !0),
            i.memoizedState = c,
            i.baseState = w,
            i.baseQueue = B,
            a.lastRenderedState = c
        }
        if (t = a.interleaved,
        t !== null) {
            d = t;
            do
                h = d.lane,
                Gt.lanes |= h,
                br |= h,
                d = d.next;
            while (d !== t)
        } else
            d === null && (a.lanes = 0);
        return [i.memoizedState, a.dispatch]
    }
    function Nc(t) {
        var i = Jn()
          , a = i.queue;
        if (a === null)
            throw Error(n(311));
        a.lastRenderedReducer = t;
        var c = a.dispatch
          , d = a.pending
          , h = i.memoizedState;
        if (d !== null) {
            a.pending = null;
            var w = d = d.next;
            do
                h = t(h, w.action),
                w = w.next;
            while (w !== d);
            ti(h, i.memoizedState) || (Cn = !0),
            i.memoizedState = h,
            i.baseQueue === null && (i.baseState = h),
            a.lastRenderedState = h
        }
        return [h, c]
    }
    function uh() {}
    function dh(t, i) {
        var a = Gt
          , c = Jn()
          , d = i()
          , h = !ti(c.memoizedState, d);
        if (h && (c.memoizedState = d,
        Cn = !0),
        c = c.queue,
        Dc(ph.bind(null, a, c, t), [t]),
        c.getSnapshot !== i || h || tn !== null && tn.memoizedState.tag & 1) {
            if (a.flags |= 2048,
            ga(9, hh.bind(null, a, c, d, i), void 0, null),
            nn === null)
                throw Error(n(349));
            (Rr & 30) !== 0 || fh(a, i, d)
        }
        return d
    }
    function fh(t, i, a) {
        t.flags |= 16384,
        t = {
            getSnapshot: i,
            value: a
        },
        i = Gt.updateQueue,
        i === null ? (i = {
            lastEffect: null,
            stores: null
        },
        Gt.updateQueue = i,
        i.stores = [t]) : (a = i.stores,
        a === null ? i.stores = [t] : a.push(t))
    }
    function hh(t, i, a, c) {
        i.value = a,
        i.getSnapshot = c,
        mh(i) && gh(t)
    }
    function ph(t, i, a) {
        return a(function() {
            mh(i) && gh(t)
        })
    }
    function mh(t) {
        var i = t.getSnapshot;
        t = t.value;
        try {
            var a = i();
            return !ti(t, a)
        } catch {
            return !0
        }
    }
    function gh(t) {
        var i = bi(t, 1);
        i !== null && ai(i, t, 1, -1)
    }
    function _h(t) {
        var i = gi();
        return typeof t == "function" && (t = t()),
        i.memoizedState = i.baseState = t,
        t = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: ma,
            lastRenderedState: t
        },
        i.queue = t,
        t = t.dispatch = S0.bind(null, Gt, t),
        [i.memoizedState, t]
    }
    function ga(t, i, a, c) {
        return t = {
            tag: t,
            create: i,
            destroy: a,
            deps: c,
            next: null
        },
        i = Gt.updateQueue,
        i === null ? (i = {
            lastEffect: null,
            stores: null
        },
        Gt.updateQueue = i,
        i.lastEffect = t.next = t) : (a = i.lastEffect,
        a === null ? i.lastEffect = t.next = t : (c = a.next,
        a.next = t,
        t.next = c,
        i.lastEffect = t)),
        t
    }
    function vh() {
        return Jn().memoizedState
    }
    function To(t, i, a, c) {
        var d = gi();
        Gt.flags |= t,
        d.memoizedState = ga(1 | i, a, void 0, c === void 0 ? null : c)
    }
    function Ao(t, i, a, c) {
        var d = Jn();
        c = c === void 0 ? null : c;
        var h = void 0;
        if (Kt !== null) {
            var w = Kt.memoizedState;
            if (h = w.destroy,
            c !== null && Rc(c, w.deps)) {
                d.memoizedState = ga(i, a, h, c);
                return
            }
        }
        Gt.flags |= t,
        d.memoizedState = ga(1 | i, a, h, c)
    }
    function xh(t, i) {
        return To(8390656, 8, t, i)
    }
    function Dc(t, i) {
        return Ao(2048, 8, t, i)
    }
    function yh(t, i) {
        return Ao(4, 2, t, i)
    }
    function Sh(t, i) {
        return Ao(4, 4, t, i)
    }
    function wh(t, i) {
        if (typeof i == "function")
            return t = t(),
            i(t),
            function() {
                i(null)
            }
            ;
        if (i != null)
            return t = t(),
            i.current = t,
            function() {
                i.current = null
            }
    }
    function Mh(t, i, a) {
        return a = a != null ? a.concat([t]) : null,
        Ao(4, 4, wh.bind(null, i, t), a)
    }
    function Ic() {}
    function Eh(t, i) {
        var a = Jn();
        i = i === void 0 ? null : i;
        var c = a.memoizedState;
        return c !== null && i !== null && Rc(i, c[1]) ? c[0] : (a.memoizedState = [t, i],
        t)
    }
    function Th(t, i) {
        var a = Jn();
        i = i === void 0 ? null : i;
        var c = a.memoizedState;
        return c !== null && i !== null && Rc(i, c[1]) ? c[0] : (t = t(),
        a.memoizedState = [t, i],
        t)
    }
    function Ah(t, i, a) {
        return (Rr & 21) === 0 ? (t.baseState && (t.baseState = !1,
        Cn = !0),
        t.memoizedState = a) : (ti(a, i) || (a = Sn(),
        Gt.lanes |= a,
        br |= a,
        t.baseState = !0),
        i)
    }
    function x0(t, i) {
        var a = pt;
        pt = a !== 0 && 4 > a ? a : 4,
        t(!0);
        var c = Cc.transition;
        Cc.transition = {};
        try {
            t(!1),
            i()
        } finally {
            pt = a,
            Cc.transition = c
        }
    }
    function Ch() {
        return Jn().memoizedState
    }
    function y0(t, i, a) {
        var c = rr(t);
        if (a = {
            lane: c,
            action: a,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Rh(t))
            bh(i, a);
        else if (a = sh(t, i, a, c),
        a !== null) {
            var d = Mn();
            ai(a, t, c, d),
            Lh(a, i, c)
        }
    }
    function S0(t, i, a) {
        var c = rr(t)
          , d = {
            lane: c,
            action: a,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (Rh(t))
            bh(i, d);
        else {
            var h = t.alternate;
            if (t.lanes === 0 && (h === null || h.lanes === 0) && (h = i.lastRenderedReducer,
            h !== null))
                try {
                    var w = i.lastRenderedState
                      , D = h(w, a);
                    if (d.hasEagerState = !0,
                    d.eagerState = D,
                    ti(D, w)) {
                        var B = i.interleaved;
                        B === null ? (d.next = d,
                        Sc(i)) : (d.next = B.next,
                        B.next = d),
                        i.interleaved = d;
                        return
                    }
                } catch {} finally {}
            a = sh(t, i, d, c),
            a !== null && (d = Mn(),
            ai(a, t, c, d),
            Lh(a, i, c))
        }
    }
    function Rh(t) {
        var i = t.alternate;
        return t === Gt || i !== null && i === Gt
    }
    function bh(t, i) {
        ha = Eo = !0;
        var a = t.pending;
        a === null ? i.next = i : (i.next = a.next,
        a.next = i),
        t.pending = i
    }
    function Lh(t, i, a) {
        if ((a & 4194240) !== 0) {
            var c = i.lanes;
            c &= t.pendingLanes,
            a |= c,
            i.lanes = a,
            Sr(t, a)
        }
    }
    var Co = {
        readContext: Yn,
        useCallback: pn,
        useContext: pn,
        useEffect: pn,
        useImperativeHandle: pn,
        useInsertionEffect: pn,
        useLayoutEffect: pn,
        useMemo: pn,
        useReducer: pn,
        useRef: pn,
        useState: pn,
        useDebugValue: pn,
        useDeferredValue: pn,
        useTransition: pn,
        useMutableSource: pn,
        useSyncExternalStore: pn,
        useId: pn,
        unstable_isNewReconciler: !1
    }
      , w0 = {
        readContext: Yn,
        useCallback: function(t, i) {
            return gi().memoizedState = [t, i === void 0 ? null : i],
            t
        },
        useContext: Yn,
        useEffect: xh,
        useImperativeHandle: function(t, i, a) {
            return a = a != null ? a.concat([t]) : null,
            To(4194308, 4, wh.bind(null, i, t), a)
        },
        useLayoutEffect: function(t, i) {
            return To(4194308, 4, t, i)
        },
        useInsertionEffect: function(t, i) {
            return To(4, 2, t, i)
        },
        useMemo: function(t, i) {
            var a = gi();
            return i = i === void 0 ? null : i,
            t = t(),
            a.memoizedState = [t, i],
            t
        },
        useReducer: function(t, i, a) {
            var c = gi();
            return i = a !== void 0 ? a(i) : i,
            c.memoizedState = c.baseState = i,
            t = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: t,
                lastRenderedState: i
            },
            c.queue = t,
            t = t.dispatch = y0.bind(null, Gt, t),
            [c.memoizedState, t]
        },
        useRef: function(t) {
            var i = gi();
            return t = {
                current: t
            },
            i.memoizedState = t
        },
        useState: _h,
        useDebugValue: Ic,
        useDeferredValue: function(t) {
            return gi().memoizedState = t
        },
        useTransition: function() {
            var t = _h(!1)
              , i = t[0];
            return t = x0.bind(null, t[1]),
            gi().memoizedState = t,
            [i, t]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(t, i, a) {
            var c = Gt
              , d = gi();
            if (Ht) {
                if (a === void 0)
                    throw Error(n(407));
                a = a()
            } else {
                if (a = i(),
                nn === null)
                    throw Error(n(349));
                (Rr & 30) !== 0 || fh(c, i, a)
            }
            d.memoizedState = a;
            var h = {
                value: a,
                getSnapshot: i
            };
            return d.queue = h,
            xh(ph.bind(null, c, h, t), [t]),
            c.flags |= 2048,
            ga(9, hh.bind(null, c, h, a, i), void 0, null),
            a
        },
        useId: function() {
            var t = gi()
              , i = nn.identifierPrefix;
            if (Ht) {
                var a = Ri
                  , c = Ci;
                a = (c & ~(1 << 32 - St(c) - 1)).toString(32) + a,
                i = ":" + i + "R" + a,
                a = pa++,
                0 < a && (i += "H" + a.toString(32)),
                i += ":"
            } else
                a = v0++,
                i = ":" + i + "r" + a.toString(32) + ":";
            return t.memoizedState = i
        },
        unstable_isNewReconciler: !1
    }
      , M0 = {
        readContext: Yn,
        useCallback: Eh,
        useContext: Yn,
        useEffect: Dc,
        useImperativeHandle: Mh,
        useInsertionEffect: yh,
        useLayoutEffect: Sh,
        useMemo: Th,
        useReducer: Pc,
        useRef: vh,
        useState: function() {
            return Pc(ma)
        },
        useDebugValue: Ic,
        useDeferredValue: function(t) {
            var i = Jn();
            return Ah(i, Kt.memoizedState, t)
        },
        useTransition: function() {
            var t = Pc(ma)[0]
              , i = Jn().memoizedState;
            return [t, i]
        },
        useMutableSource: uh,
        useSyncExternalStore: dh,
        useId: Ch,
        unstable_isNewReconciler: !1
    }
      , E0 = {
        readContext: Yn,
        useCallback: Eh,
        useContext: Yn,
        useEffect: Dc,
        useImperativeHandle: Mh,
        useInsertionEffect: yh,
        useLayoutEffect: Sh,
        useMemo: Th,
        useReducer: Nc,
        useRef: vh,
        useState: function() {
            return Nc(ma)
        },
        useDebugValue: Ic,
        useDeferredValue: function(t) {
            var i = Jn();
            return Kt === null ? i.memoizedState = t : Ah(i, Kt.memoizedState, t)
        },
        useTransition: function() {
            var t = Nc(ma)[0]
              , i = Jn().memoizedState;
            return [t, i]
        },
        useMutableSource: uh,
        useSyncExternalStore: dh,
        useId: Ch,
        unstable_isNewReconciler: !1
    };
    function ii(t, i) {
        if (t && t.defaultProps) {
            i = re({}, i),
            t = t.defaultProps;
            for (var a in t)
                i[a] === void 0 && (i[a] = t[a]);
            return i
        }
        return i
    }
    function Uc(t, i, a, c) {
        i = t.memoizedState,
        a = a(c, i),
        a = a == null ? i : re({}, i, a),
        t.memoizedState = a,
        t.lanes === 0 && (t.updateQueue.baseState = a)
    }
    var Ro = {
        isMounted: function(t) {
            return (t = t._reactInternals) ? Ei(t) === t : !1
        },
        enqueueSetState: function(t, i, a) {
            t = t._reactInternals;
            var c = Mn()
              , d = rr(t)
              , h = Li(c, d);
            h.payload = i,
            a != null && (h.callback = a),
            i = er(t, h, d),
            i !== null && (ai(i, t, d, c),
            yo(i, t, d))
        },
        enqueueReplaceState: function(t, i, a) {
            t = t._reactInternals;
            var c = Mn()
              , d = rr(t)
              , h = Li(c, d);
            h.tag = 1,
            h.payload = i,
            a != null && (h.callback = a),
            i = er(t, h, d),
            i !== null && (ai(i, t, d, c),
            yo(i, t, d))
        },
        enqueueForceUpdate: function(t, i) {
            t = t._reactInternals;
            var a = Mn()
              , c = rr(t)
              , d = Li(a, c);
            d.tag = 2,
            i != null && (d.callback = i),
            i = er(t, d, c),
            i !== null && (ai(i, t, c, a),
            yo(i, t, c))
        }
    };
    function Ph(t, i, a, c, d, h, w) {
        return t = t.stateNode,
        typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(c, h, w) : i.prototype && i.prototype.isPureReactComponent ? !na(a, c) || !na(d, h) : !0
    }
    function Nh(t, i, a) {
        var c = !1
          , d = Ki
          , h = i.contextType;
        return typeof h == "object" && h !== null ? h = Yn(h) : (d = An(i) ? Mr : hn.current,
        c = i.contextTypes,
        h = (c = c != null) ? os(t, d) : Ki),
        i = new i(a,h),
        t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null,
        i.updater = Ro,
        t.stateNode = i,
        i._reactInternals = t,
        c && (t = t.stateNode,
        t.__reactInternalMemoizedUnmaskedChildContext = d,
        t.__reactInternalMemoizedMaskedChildContext = h),
        i
    }
    function Dh(t, i, a, c) {
        t = i.state,
        typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(a, c),
        typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(a, c),
        i.state !== t && Ro.enqueueReplaceState(i, i.state, null)
    }
    function Fc(t, i, a, c) {
        var d = t.stateNode;
        d.props = a,
        d.state = t.memoizedState,
        d.refs = {},
        wc(t);
        var h = i.contextType;
        typeof h == "object" && h !== null ? d.context = Yn(h) : (h = An(i) ? Mr : hn.current,
        d.context = os(t, h)),
        d.state = t.memoizedState,
        h = i.getDerivedStateFromProps,
        typeof h == "function" && (Uc(t, i, h, a),
        d.state = t.memoizedState),
        typeof i.getDerivedStateFromProps == "function" || typeof d.getSnapshotBeforeUpdate == "function" || typeof d.UNSAFE_componentWillMount != "function" && typeof d.componentWillMount != "function" || (i = d.state,
        typeof d.componentWillMount == "function" && d.componentWillMount(),
        typeof d.UNSAFE_componentWillMount == "function" && d.UNSAFE_componentWillMount(),
        i !== d.state && Ro.enqueueReplaceState(d, d.state, null),
        So(t, a, d, c),
        d.state = t.memoizedState),
        typeof d.componentDidMount == "function" && (t.flags |= 4194308)
    }
    function ms(t, i) {
        try {
            var a = ""
              , c = i;
            do
                a += Q(c),
                c = c.return;
            while (c);
            var d = a
        } catch (h) {
            d = `
Error generating stack: ` + h.message + `
` + h.stack
        }
        return {
            value: t,
            source: i,
            stack: d,
            digest: null
        }
    }
    function Oc(t, i, a) {
        return {
            value: t,
            source: null,
            stack: a ?? null,
            digest: i ?? null
        }
    }
    function zc(t, i) {
        try {
            console.error(i.value)
        } catch (a) {
            setTimeout(function() {
                throw a
            })
        }
    }
    var T0 = typeof WeakMap == "function" ? WeakMap : Map;
    function Ih(t, i, a) {
        a = Li(-1, a),
        a.tag = 3,
        a.payload = {
            element: null
        };
        var c = i.value;
        return a.callback = function() {
            Uo || (Uo = !0,
            Zc = c),
            zc(t, i)
        }
        ,
        a
    }
    function Uh(t, i, a) {
        a = Li(-1, a),
        a.tag = 3;
        var c = t.type.getDerivedStateFromError;
        if (typeof c == "function") {
            var d = i.value;
            a.payload = function() {
                return c(d)
            }
            ,
            a.callback = function() {
                zc(t, i)
            }
        }
        var h = t.stateNode;
        return h !== null && typeof h.componentDidCatch == "function" && (a.callback = function() {
            zc(t, i),
            typeof c != "function" && (nr === null ? nr = new Set([this]) : nr.add(this));
            var w = i.stack;
            this.componentDidCatch(i.value, {
                componentStack: w !== null ? w : ""
            })
        }
        ),
        a
    }
    function Fh(t, i, a) {
        var c = t.pingCache;
        if (c === null) {
            c = t.pingCache = new T0;
            var d = new Set;
            c.set(i, d)
        } else
            d = c.get(i),
            d === void 0 && (d = new Set,
            c.set(i, d));
        d.has(a) || (d.add(a),
        t = k0.bind(null, t, i, a),
        i.then(t, t))
    }
    function Oh(t) {
        do {
            var i;
            if ((i = t.tag === 13) && (i = t.memoizedState,
            i = i !== null ? i.dehydrated !== null : !0),
            i)
                return t;
            t = t.return
        } while (t !== null);
        return null
    }
    function zh(t, i, a, c, d) {
        return (t.mode & 1) === 0 ? (t === i ? t.flags |= 65536 : (t.flags |= 128,
        a.flags |= 131072,
        a.flags &= -52805,
        a.tag === 1 && (a.alternate === null ? a.tag = 17 : (i = Li(-1, 1),
        i.tag = 2,
        er(a, i, 1))),
        a.lanes |= 1),
        t) : (t.flags |= 65536,
        t.lanes = d,
        t)
    }
    var A0 = C.ReactCurrentOwner
      , Cn = !1;
    function wn(t, i, a, c) {
        i.child = t === null ? rh(i, null, a, c) : ds(i, t.child, a, c)
    }
    function kh(t, i, a, c, d) {
        a = a.render;
        var h = i.ref;
        return hs(i, d),
        c = bc(t, i, a, c, h, d),
        a = Lc(),
        t !== null && !Cn ? (i.updateQueue = t.updateQueue,
        i.flags &= -2053,
        t.lanes &= ~d,
        Pi(t, i, d)) : (Ht && a && fc(i),
        i.flags |= 1,
        wn(t, i, c, d),
        i.child)
    }
    function Bh(t, i, a, c, d) {
        if (t === null) {
            var h = a.type;
            return typeof h == "function" && !au(h) && h.defaultProps === void 0 && a.compare === null && a.defaultProps === void 0 ? (i.tag = 15,
            i.type = h,
            Hh(t, i, h, c, d)) : (t = Ho(a.type, null, c, i, i.mode, d),
            t.ref = i.ref,
            t.return = i,
            i.child = t)
        }
        if (h = t.child,
        (t.lanes & d) === 0) {
            var w = h.memoizedProps;
            if (a = a.compare,
            a = a !== null ? a : na,
            a(w, c) && t.ref === i.ref)
                return Pi(t, i, d)
        }
        return i.flags |= 1,
        t = ar(h, c),
        t.ref = i.ref,
        t.return = i,
        i.child = t
    }
    function Hh(t, i, a, c, d) {
        if (t !== null) {
            var h = t.memoizedProps;
            if (na(h, c) && t.ref === i.ref)
                if (Cn = !1,
                i.pendingProps = c = h,
                (t.lanes & d) !== 0)
                    (t.flags & 131072) !== 0 && (Cn = !0);
                else
                    return i.lanes = t.lanes,
                    Pi(t, i, d)
        }
        return kc(t, i, a, c, d)
    }
    function Vh(t, i, a) {
        var c = i.pendingProps
          , d = c.children
          , h = t !== null ? t.memoizedState : null;
        if (c.mode === "hidden")
            if ((i.mode & 1) === 0)
                i.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                Ft(_s, Bn),
                Bn |= a;
            else {
                if ((a & 1073741824) === 0)
                    return t = h !== null ? h.baseLanes | a : a,
                    i.lanes = i.childLanes = 1073741824,
                    i.memoizedState = {
                        baseLanes: t,
                        cachePool: null,
                        transitions: null
                    },
                    i.updateQueue = null,
                    Ft(_s, Bn),
                    Bn |= t,
                    null;
                i.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                c = h !== null ? h.baseLanes : a,
                Ft(_s, Bn),
                Bn |= c
            }
        else
            h !== null ? (c = h.baseLanes | a,
            i.memoizedState = null) : c = a,
            Ft(_s, Bn),
            Bn |= c;
        return wn(t, i, d, a),
        i.child
    }
    function jh(t, i) {
        var a = i.ref;
        (t === null && a !== null || t !== null && t.ref !== a) && (i.flags |= 512,
        i.flags |= 2097152)
    }
    function kc(t, i, a, c, d) {
        var h = An(a) ? Mr : hn.current;
        return h = os(i, h),
        hs(i, d),
        a = bc(t, i, a, c, h, d),
        c = Lc(),
        t !== null && !Cn ? (i.updateQueue = t.updateQueue,
        i.flags &= -2053,
        t.lanes &= ~d,
        Pi(t, i, d)) : (Ht && c && fc(i),
        i.flags |= 1,
        wn(t, i, a, d),
        i.child)
    }
    function Gh(t, i, a, c, d) {
        if (An(a)) {
            var h = !0;
            fo(i)
        } else
            h = !1;
        if (hs(i, d),
        i.stateNode === null)
            Lo(t, i),
            Nh(i, a, c),
            Fc(i, a, c, d),
            c = !0;
        else if (t === null) {
            var w = i.stateNode
              , D = i.memoizedProps;
            w.props = D;
            var B = w.context
              , Z = a.contextType;
            typeof Z == "object" && Z !== null ? Z = Yn(Z) : (Z = An(a) ? Mr : hn.current,
            Z = os(i, Z));
            var _e = a.getDerivedStateFromProps
              , xe = typeof _e == "function" || typeof w.getSnapshotBeforeUpdate == "function";
            xe || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (D !== c || B !== Z) && Dh(i, w, c, Z),
            Zi = !1;
            var ge = i.memoizedState;
            w.state = ge,
            So(i, c, w, d),
            B = i.memoizedState,
            D !== c || ge !== B || Tn.current || Zi ? (typeof _e == "function" && (Uc(i, a, _e, c),
            B = i.memoizedState),
            (D = Zi || Ph(i, a, D, c, ge, B, Z)) ? (xe || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (typeof w.componentWillMount == "function" && w.componentWillMount(),
            typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount()),
            typeof w.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof w.componentDidMount == "function" && (i.flags |= 4194308),
            i.memoizedProps = c,
            i.memoizedState = B),
            w.props = c,
            w.state = B,
            w.context = Z,
            c = D) : (typeof w.componentDidMount == "function" && (i.flags |= 4194308),
            c = !1)
        } else {
            w = i.stateNode,
            ah(t, i),
            D = i.memoizedProps,
            Z = i.type === i.elementType ? D : ii(i.type, D),
            w.props = Z,
            xe = i.pendingProps,
            ge = w.context,
            B = a.contextType,
            typeof B == "object" && B !== null ? B = Yn(B) : (B = An(a) ? Mr : hn.current,
            B = os(i, B));
            var Ue = a.getDerivedStateFromProps;
            (_e = typeof Ue == "function" || typeof w.getSnapshotBeforeUpdate == "function") || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (D !== xe || ge !== B) && Dh(i, w, c, B),
            Zi = !1,
            ge = i.memoizedState,
            w.state = ge,
            So(i, c, w, d);
            var Ve = i.memoizedState;
            D !== xe || ge !== Ve || Tn.current || Zi ? (typeof Ue == "function" && (Uc(i, a, Ue, c),
            Ve = i.memoizedState),
            (Z = Zi || Ph(i, a, Z, c, ge, Ve, B) || !1) ? (_e || typeof w.UNSAFE_componentWillUpdate != "function" && typeof w.componentWillUpdate != "function" || (typeof w.componentWillUpdate == "function" && w.componentWillUpdate(c, Ve, B),
            typeof w.UNSAFE_componentWillUpdate == "function" && w.UNSAFE_componentWillUpdate(c, Ve, B)),
            typeof w.componentDidUpdate == "function" && (i.flags |= 4),
            typeof w.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof w.componentDidUpdate != "function" || D === t.memoizedProps && ge === t.memoizedState || (i.flags |= 4),
            typeof w.getSnapshotBeforeUpdate != "function" || D === t.memoizedProps && ge === t.memoizedState || (i.flags |= 1024),
            i.memoizedProps = c,
            i.memoizedState = Ve),
            w.props = c,
            w.state = Ve,
            w.context = B,
            c = Z) : (typeof w.componentDidUpdate != "function" || D === t.memoizedProps && ge === t.memoizedState || (i.flags |= 4),
            typeof w.getSnapshotBeforeUpdate != "function" || D === t.memoizedProps && ge === t.memoizedState || (i.flags |= 1024),
            c = !1)
        }
        return Bc(t, i, a, c, h, d)
    }
    function Bc(t, i, a, c, d, h) {
        jh(t, i);
        var w = (i.flags & 128) !== 0;
        if (!c && !w)
            return d && qf(i, a, !1),
            Pi(t, i, h);
        c = i.stateNode,
        A0.current = i;
        var D = w && typeof a.getDerivedStateFromError != "function" ? null : c.render();
        return i.flags |= 1,
        t !== null && w ? (i.child = ds(i, t.child, null, h),
        i.child = ds(i, null, D, h)) : wn(t, i, D, h),
        i.memoizedState = c.state,
        d && qf(i, a, !0),
        i.child
    }
    function Wh(t) {
        var i = t.stateNode;
        i.pendingContext ? Yf(t, i.pendingContext, i.pendingContext !== i.context) : i.context && Yf(t, i.context, !1),
        Mc(t, i.containerInfo)
    }
    function Xh(t, i, a, c, d) {
        return us(),
        gc(d),
        i.flags |= 256,
        wn(t, i, a, c),
        i.child
    }
    var Hc = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function Vc(t) {
        return {
            baseLanes: t,
            cachePool: null,
            transitions: null
        }
    }
    function Yh(t, i, a) {
        var c = i.pendingProps, d = jt.current, h = !1, w = (i.flags & 128) !== 0, D;
        if ((D = w) || (D = t !== null && t.memoizedState === null ? !1 : (d & 2) !== 0),
        D ? (h = !0,
        i.flags &= -129) : (t === null || t.memoizedState !== null) && (d |= 1),
        Ft(jt, d & 1),
        t === null)
            return mc(i),
            t = i.memoizedState,
            t !== null && (t = t.dehydrated,
            t !== null) ? ((i.mode & 1) === 0 ? i.lanes = 1 : t.data === "$!" ? i.lanes = 8 : i.lanes = 1073741824,
            null) : (w = c.children,
            t = c.fallback,
            h ? (c = i.mode,
            h = i.child,
            w = {
                mode: "hidden",
                children: w
            },
            (c & 1) === 0 && h !== null ? (h.childLanes = 0,
            h.pendingProps = w) : h = Vo(w, c, 0, null),
            t = Dr(t, c, a, null),
            h.return = i,
            t.return = i,
            h.sibling = t,
            i.child = h,
            i.child.memoizedState = Vc(a),
            i.memoizedState = Hc,
            t) : jc(i, w));
        if (d = t.memoizedState,
        d !== null && (D = d.dehydrated,
        D !== null))
            return C0(t, i, w, c, D, d, a);
        if (h) {
            h = c.fallback,
            w = i.mode,
            d = t.child,
            D = d.sibling;
            var B = {
                mode: "hidden",
                children: c.children
            };
            return (w & 1) === 0 && i.child !== d ? (c = i.child,
            c.childLanes = 0,
            c.pendingProps = B,
            i.deletions = null) : (c = ar(d, B),
            c.subtreeFlags = d.subtreeFlags & 14680064),
            D !== null ? h = ar(D, h) : (h = Dr(h, w, a, null),
            h.flags |= 2),
            h.return = i,
            c.return = i,
            c.sibling = h,
            i.child = c,
            c = h,
            h = i.child,
            w = t.child.memoizedState,
            w = w === null ? Vc(a) : {
                baseLanes: w.baseLanes | a,
                cachePool: null,
                transitions: w.transitions
            },
            h.memoizedState = w,
            h.childLanes = t.childLanes & ~a,
            i.memoizedState = Hc,
            c
        }
        return h = t.child,
        t = h.sibling,
        c = ar(h, {
            mode: "visible",
            children: c.children
        }),
        (i.mode & 1) === 0 && (c.lanes = a),
        c.return = i,
        c.sibling = null,
        t !== null && (a = i.deletions,
        a === null ? (i.deletions = [t],
        i.flags |= 16) : a.push(t)),
        i.child = c,
        i.memoizedState = null,
        c
    }
    function jc(t, i) {
        return i = Vo({
            mode: "visible",
            children: i
        }, t.mode, 0, null),
        i.return = t,
        t.child = i
    }
    function bo(t, i, a, c) {
        return c !== null && gc(c),
        ds(i, t.child, null, a),
        t = jc(i, i.pendingProps.children),
        t.flags |= 2,
        i.memoizedState = null,
        t
    }
    function C0(t, i, a, c, d, h, w) {
        if (a)
            return i.flags & 256 ? (i.flags &= -257,
            c = Oc(Error(n(422))),
            bo(t, i, w, c)) : i.memoizedState !== null ? (i.child = t.child,
            i.flags |= 128,
            null) : (h = c.fallback,
            d = i.mode,
            c = Vo({
                mode: "visible",
                children: c.children
            }, d, 0, null),
            h = Dr(h, d, w, null),
            h.flags |= 2,
            c.return = i,
            h.return = i,
            c.sibling = h,
            i.child = c,
            (i.mode & 1) !== 0 && ds(i, t.child, null, w),
            i.child.memoizedState = Vc(w),
            i.memoizedState = Hc,
            h);
        if ((i.mode & 1) === 0)
            return bo(t, i, w, null);
        if (d.data === "$!") {
            if (c = d.nextSibling && d.nextSibling.dataset,
            c)
                var D = c.dgst;
            return c = D,
            h = Error(n(419)),
            c = Oc(h, c, void 0),
            bo(t, i, w, c)
        }
        if (D = (w & t.childLanes) !== 0,
        Cn || D) {
            if (c = nn,
            c !== null) {
                switch (w & -w) {
                case 4:
                    d = 2;
                    break;
                case 16:
                    d = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    d = 32;
                    break;
                case 536870912:
                    d = 268435456;
                    break;
                default:
                    d = 0
                }
                d = (d & (c.suspendedLanes | w)) !== 0 ? 0 : d,
                d !== 0 && d !== h.retryLane && (h.retryLane = d,
                bi(t, d),
                ai(c, t, d, -1))
            }
            return su(),
            c = Oc(Error(n(421))),
            bo(t, i, w, c)
        }
        return d.data === "$?" ? (i.flags |= 128,
        i.child = t.child,
        i = B0.bind(null, t),
        d._reactRetry = i,
        null) : (t = h.treeContext,
        kn = qi(d.nextSibling),
        zn = i,
        Ht = !0,
        ni = null,
        t !== null && (Wn[Xn++] = Ci,
        Wn[Xn++] = Ri,
        Wn[Xn++] = Er,
        Ci = t.id,
        Ri = t.overflow,
        Er = i),
        i = jc(i, c.children),
        i.flags |= 4096,
        i)
    }
    function Jh(t, i, a) {
        t.lanes |= i;
        var c = t.alternate;
        c !== null && (c.lanes |= i),
        yc(t.return, i, a)
    }
    function Gc(t, i, a, c, d) {
        var h = t.memoizedState;
        h === null ? t.memoizedState = {
            isBackwards: i,
            rendering: null,
            renderingStartTime: 0,
            last: c,
            tail: a,
            tailMode: d
        } : (h.isBackwards = i,
        h.rendering = null,
        h.renderingStartTime = 0,
        h.last = c,
        h.tail = a,
        h.tailMode = d)
    }
     function qh(t, i, a) {
        var c = i.pendingProps
          , d = c.revealOrder
          , h = c.tail;
        if (wn(t, i, c.children, a),
        c = jt.current,
        (c & 2) !== 0)
            c = c & 1 | 2,
            i.flags |= 128;
        else {
            if (t !== null && (t.flags & 128) !== 0)
                e: for (t = i.child; t !== null; ) {
                    if (t.tag === 13)
                        t.memoizedState !== null && Jh(t, a, i);
                    else if (t.tag === 19)
                        Jh(t, a, i);
                    else if (t.child !== null) {
                        t.child.return = t,
                        t = t.child;
                        continue
                    }
                    if (t === i)
                        break e;
                    for (; t.sibling === null; ) {
                        if (t.return === null || t.return === i)
                            break e;
                        t = t.return
                    }
                    t.sibling.return = t.return,
                    t = t.sibling
                }
            c &= 1
        }
        if (Ft(jt, c),
        (i.mode & 1) === 0)
            i.memoizedState = null;
        else
            switch (d) {
            case "forwards":
                for (a = i.child,
                d = null; a !== null; )
                    t = a.alternate,
                    t !== null && wo(t) === null && (d = a),
                    a = a.sibling;
                a = d,
                a === null ? (d = i.child,
                i.child = null) : (d = a.sibling,
                a.sibling = null),
                Gc(i, !1, d, a, h);
                break;
            case "backwards":
                for (a = null,
                d = i.child,
                i.child = null; d !== null; ) {
                    if (t = d.alternate,
                    t !== null && wo(t) === null) {
                        i.child = d;
                        break
                    }
                    t = d.sibling,
                    d.sibling = a,
                    a = d,
                    d = t
                }
                Gc(i, !0, a, null, h);
                break;
            case "together":
                Gc(i, !1, null, null, void 0);
                break;
            default:
                i.memoizedState = null
            }
        return i.child
    }
    function Lo(t, i) {
        (i.mode & 1) === 0 && t !== null && (t.alternate = null,
        i.alternate = null,
        i.flags |= 2)
    }
    function Pi(t, i, a) {
        if (t !== null && (i.dependencies = t.dependencies),
        br |= i.lanes,
        (a & i.childLanes) === 0)
            return null;
        if (t !== null && i.child !== t.child)
            throw Error(n(153));
        if (i.child !== null) {
            for (t = i.child,
            a = ar(t, t.pendingProps),
            i.child = a,
            a.return = i; t.sibling !== null; )
                t = t.sibling,
                a = a.sibling = ar(t, t.pendingProps),
                a.return = i;
            a.sibling = null
        }
        return i.child
    }
    function R0(t, i, a) {
        switch (i.tag) {
        case 3:
            Wh(i),
            us();
            break;
        case 5:
            ch(i);
            break;
        case 1:
            An(i.type) && fo(i);
            break;
        case 4:
            Mc(i, i.stateNode.containerInfo);
            break;
        case 10:
            var c = i.type._context
              , d = i.memoizedProps.value;
            Ft(vo, c._currentValue),
            c._currentValue = d;
            break;
        case 13:
            if (c = i.memoizedState,
            c !== null)
                return c.dehydrated !== null ? (Ft(jt, jt.current & 1),
                i.flags |= 128,
                null) : (a & i.child.childLanes) !== 0 ? Yh(t, i, a) : (Ft(jt, jt.current & 1),
                t = Pi(t, i, a),
                t !== null ? t.sibling : null);
            Ft(jt, jt.current & 1);
            break;
        case 19:
            if (c = (a & i.childLanes) !== 0,
            (t.flags & 128) !== 0) {
                if (c)
                    return qh(t, i, a);
                i.flags |= 128
            }
            if (d = i.memoizedState,
            d !== null && (d.rendering = null,
            d.tail = null,
            d.lastEffect = null),
            Ft(jt, jt.current),
            c)
                break;
            return null;
        case 22:
        case 23:
            return i.lanes = 0,
            Vh(t, i, a)
        }
        return Pi(t, i, a)
    }
    var $h, Wc, Kh, Qh;
    $h = function(t, i) {
        for (var a = i.child; a !== null; ) {
            if (a.tag === 5 || a.tag === 6)
                t.appendChild(a.stateNode);
            else if (a.tag !== 4 && a.child !== null) {
                a.child.return = a,
                a = a.child;
                continue
            }
            if (a === i)
                break;
            for (; a.sibling === null; ) {
                if (a.return === null || a.return === i)
                    return;
                a = a.return
            }
            a.sibling.return = a.return,
            a = a.sibling
        }
    }
    ,
    Wc = function() {}
    ,
    Kh = function(t, i, a, c) {
        var d = t.memoizedProps;
        if (d !== c) {
            t = i.stateNode,
            Cr(mi.current);
            var h = null;
            switch (a) {
            case "input":
                d = Tt(t, d),
                c = Tt(t, c),
                h = [];
                break;
            case "select":
                d = re({}, d, {
                    value: void 0
                }),
                c = re({}, c, {
                    value: void 0
                }),
                h = [];
                break;
            case "textarea":
                d = zt(t, d),
                c = zt(t, c),
                h = [];
                break;
            default:
                typeof d.onClick != "function" && typeof c.onClick == "function" && (t.onclick = lo)
            }
            We(a, c);
            var w;
            a = null;
            for (Z in d)
                if (!c.hasOwnProperty(Z) && d.hasOwnProperty(Z) && d[Z] != null)
                    if (Z === "style") {
                        var D = d[Z];
                        for (w in D)
                            D.hasOwnProperty(w) && (a || (a = {}),
                            a[w] = "")
                    } else
                        Z !== "dangerouslySetInnerHTML" && Z !== "children" && Z !== "suppressContentEditableWarning" && Z !== "suppressHydrationWarning" && Z !== "autoFocus" && (o.hasOwnProperty(Z) ? h || (h = []) : (h = h || []).push(Z, null));
            for (Z in c) {
                var B = c[Z];
                if (D = d?.[Z],
                c.hasOwnProperty(Z) && B !== D && (B != null || D != null))
                    if (Z === "style")
                        if (D) {
                            for (w in D)
                                !D.hasOwnProperty(w) || B && B.hasOwnProperty(w) || (a || (a = {}),
                                a[w] = "");
                            for (w in B)
                                B.hasOwnProperty(w) && D[w] !== B[w] && (a || (a = {}),
                                a[w] = B[w])
                        } else
                            a || (h || (h = []),
                            h.push(Z, a)),
                            a = B;
                    else
                        Z === "dangerouslySetInnerHTML" ? (B = B ? B.__html : void 0,
                        D = D ? D.__html : void 0,
                        B != null && D !== B && (h = h || []).push(Z, B)) : Z === "children" ? typeof B != "string" && typeof B != "number" || (h = h || []).push(Z, "" + B) : Z !== "suppressContentEditableWarning" && Z !== "suppressHydrationWarning" && (o.hasOwnProperty(Z) ? (B != null && Z === "onScroll" && kt("scroll", t),
                        h || D === B || (h = [])) : (h = h || []).push(Z, B))
            }
            a && (h = h || []).push("style", a);
            var Z = h;
            (i.updateQueue = Z) && (i.flags |= 4)
        }
    }
    ,
    Qh = function(t, i, a, c) {
        a !== c && (i.flags |= 4)
    }
    ;
    function _a(t, i) {
        if (!Ht)
            switch (t.tailMode) {
            case "hidden":
                i = t.tail;
                for (var a = null; i !== null; )
                    i.alternate !== null && (a = i),
                    i = i.sibling;
                a === null ? t.tail = null : a.sibling = null;
                break;
            case "collapsed":
                a = t.tail;
                for (var c = null; a !== null; )
                    a.alternate !== null && (c = a),
                    a = a.sibling;
                c === null ? i || t.tail === null ? t.tail = null : t.tail.sibling = null : c.sibling = null
            }
    }
    function mn(t) {
        var i = t.alternate !== null && t.alternate.child === t.child
          , a = 0
          , c = 0;
        if (i)
            for (var d = t.child; d !== null; )
                a |= d.lanes | d.childLanes,
                c |= d.subtreeFlags & 14680064,
                c |= d.flags & 14680064,
                d.return = t,
                d = d.sibling;
        else
            for (d = t.child; d !== null; )
                a |= d.lanes | d.childLanes,
                c |= d.subtreeFlags,
                c |= d.flags,
                d.return = t,
                d = d.sibling;
        return t.subtreeFlags |= c,
        t.childLanes = a,
        i
    }
    function b0(t, i, a) {
        var c = i.pendingProps;
        switch (hc(i),
        i.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return mn(i),
            null;
        case 1:
            return An(i.type) && uo(),
            mn(i),
            null;
        case 3:
            return c = i.stateNode,
            ps(),
            Bt(Tn),
            Bt(hn),
            Ac(),
            c.pendingContext && (c.context = c.pendingContext,
            c.pendingContext = null),
            (t === null || t.child === null) && (go(i) ? i.flags |= 4 : t === null || t.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024,
            ni !== null && (nu(ni),
            ni = null))),
            Wc(t, i),
            mn(i),
            null;
        case 5:
            Ec(i);
            var d = Cr(fa.current);
            if (a = i.type,
            t !== null && i.stateNode != null)
                Kh(t, i, a, c, d),
                t.ref !== i.ref && (i.flags |= 512,
                i.flags |= 2097152);
            else {
                if (!c) {
                    if (i.stateNode === null)
                        throw Error(n(166));
                    return mn(i),
                    null
                }
                if (t = Cr(mi.current),
                go(i)) {
                    c = i.stateNode,
                    a = i.type;
                    var h = i.memoizedProps;
                    switch (c[pi] = i,
                    c[oa] = h,
                    t = (i.mode & 1) !== 0,
                    a) {
                    case "dialog":
                        kt("cancel", c),
                        kt("close", c);
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        kt("load", c);
                        break;
                    case "video":
                    case "audio":
                        for (d = 0; d < ra.length; d++)
                            kt(ra[d], c);
                        break;
                    case "source":
                        kt("error", c);
                        break;
                    case "img":
                    case "image":
                    case "link":
                        kt("error", c),
                        kt("load", c);
                        break;
                    case "details":
                        kt("toggle", c);
                        break;
                    case "input":
                        Qe(c, h),
                        kt("invalid", c);
                        break;
                    case "select":
                        c._wrapperState = {
                            wasMultiple: !!h.multiple
                        },
                        kt("invalid", c);
                        break;
                    case "textarea":
                        P(c, h),
                        kt("invalid", c)
                    }
                    We(a, h),
                    d = null;
                    for (var w in h)
                        if (h.hasOwnProperty(w)) {
                            var D = h[w];
                            w === "children" ? typeof D == "string" ? c.textContent !== D && (h.suppressHydrationWarning !== !0 && oo(c.textContent, D, t),
                            d = ["children", D]) : typeof D == "number" && c.textContent !== "" + D && (h.suppressHydrationWarning !== !0 && oo(c.textContent, D, t),
                            d = ["children", "" + D]) : o.hasOwnProperty(w) && D != null && w === "onScroll" && kt("scroll", c)
                        }
                    switch (a) {
                    case "input":
                        Ut(c),
                        Nt(c, h, !0);
                        break;
                    case "textarea":
                        Ut(c),
                        $(c);
                        break;
                    case "select":
                    case "option":
                        break;
                    default:
                        typeof h.onClick == "function" && (c.onclick = lo)
                    }
                    c = d,
                    i.updateQueue = c,
                    c !== null && (i.flags |= 4)
                } else {
                    w = d.nodeType === 9 ? d : d.ownerDocument,
                    t === "http://www.w3.org/1999/xhtml" && (t = fe(a)),
                    t === "http://www.w3.org/1999/xhtml" ? a === "script" ? (t = w.createElement("div"),
                    t.innerHTML = "<script><\/script>",
                    t = t.removeChild(t.firstChild)) : typeof c.is == "string" ? t = w.createElement(a, {
                        is: c.is
                    }) : (t = w.createElement(a),
                    a === "select" && (w = t,
                    c.multiple ? w.multiple = !0 : c.size && (w.size = c.size))) : t = w.createElementNS(t, a),
                    t[pi] = i,
                    t[oa] = c,
                    $h(t, i, !1, !1),
                    i.stateNode = t;
                    e: {
                        switch (w = Re(a, c),
                        a) {
                        case "dialog":
                            kt("cancel", t),
                            kt("close", t),
                            d = c;
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            kt("load", t),
                            d = c;
                            break;
                        case "video":
                        case "audio":
                            for (d = 0; d < ra.length; d++)
                                kt(ra[d], t);
                            d = c;
                            break;
                        case "source":
                            kt("error", t),
                            d = c;
                            break;
                        case "img":
                        case "image":
                        case "link":
                            kt("error", t),
                            kt("load", t),
                            d = c;
                            break;
                        case "details":
                            kt("toggle", t),
                            d = c;
                            break;
                        case "input":
                            Qe(t, c),
                            d = Tt(t, c),
                            kt("invalid", t);
                            break;
                        case "option":
                            d = c;
                            break;
                        case "select":
                            t._wrapperState = {
                                wasMultiple: !!c.multiple
                            },
                            d = re({}, c, {
                                value: void 0
                            }),
                            kt("invalid", t);
                            break;
                        case "textarea":
                            P(t, c),
                            d = zt(t, c),
                            kt("invalid", t);
                            break;
                        default:
                            d = c
                        }
                        We(a, d),
                        D = d;
                        for (h in D)
                            if (D.hasOwnProperty(h)) {
                                var B = D[h];
                                h === "style" ? Ne(t, B) : h === "dangerouslySetInnerHTML" ? (B = B ? B.__html : void 0,
                                B != null && Ye(t, B)) : h === "children" ? typeof B == "string" ? (a !== "textarea" || B !== "") && Te(t, B) : typeof B == "number" && Te(t, "" + B) : h !== "suppressContentEditableWarning" && h !== "suppressHydrationWarning" && h !== "autoFocus" && (o.hasOwnProperty(h) ? B != null && h === "onScroll" && kt("scroll", t) : B != null && L(t, h, B, w))
                            }
                        switch (a) {
                        case "input":
                            Ut(t),
                            Nt(t, c, !1);
                            break;
                        case "textarea":
                            Ut(t),
                            $(t);
                            break;
                        case "option":
                            c.value != null && t.setAttribute("value", "" + Ce(c.value));
                            break;
                        case "select":
                            t.multiple = !!c.multiple,
                            h = c.value,
                            h != null ? Ot(t, !!c.multiple, h, !1) : c.defaultValue != null && Ot(t, !!c.multiple, c.defaultValue, !0);
                            break;
                        default:
                            typeof d.onClick == "function" && (t.onclick = lo)
                        }
                        switch (a) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                            c = !!c.autoFocus;
                            break e;
                        case "img":
                            c = !0;
                            break e;
                        default:
                            c = !1
                        }
                    }
                    c && (i.flags |= 4)
                }
                i.ref !== null && (i.flags |= 512,
                i.flags |= 2097152)
            }
            return mn(i),
            null;
        case 6:
            if (t && i.stateNode != null)
                Qh(t, i, t.memoizedProps, c);
            else {
                if (typeof c != "string" && i.stateNode === null)
                    throw Error(n(166));
                if (a = Cr(fa.current),
                Cr(mi.current),
                go(i)) {
                    if (c = i.stateNode,
                    a = i.memoizedProps,
                    c[pi] = i,
                    (h = c.nodeValue !== a) && (t = zn,
                    t !== null))
                        switch (t.tag) {
                        case 3:
                            oo(c.nodeValue, a, (t.mode & 1) !== 0);
                            break;
                        case 5:
                            t.memoizedProps.suppressHydrationWarning !== !0 && oo(c.nodeValue, a, (t.mode & 1) !== 0)
                        }
                    h && (i.flags |= 4)
                } else
                    c = (a.nodeType === 9 ? a : a.ownerDocument).createTextNode(c),
                    c[pi] = i,
                    i.stateNode = c
            }
            return mn(i),
            null;
        case 13:
            if (Bt(jt),
            c = i.memoizedState,
            t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
                if (Ht && kn !== null && (i.mode & 1) !== 0 && (i.flags & 128) === 0)
                    th(),
                    us(),
                    i.flags |= 98560,
                    h = !1;
                else if (h = go(i),
                c !== null && c.dehydrated !== null) {
                    if (t === null) {
                        if (!h)
                            throw Error(n(318));
                        if (h = i.memoizedState,
                        h = h !== null ? h.dehydrated : null,
                        !h)
                            throw Error(n(317));
                        h[pi] = i
                    } else
                        us(),
                        (i.flags & 128) === 0 && (i.memoizedState = null),
                        i.flags |= 4;
                    mn(i),
                    h = !1
                } else
                    ni !== null && (nu(ni),
                    ni = null),
                    h = !0;
                if (!h)
                    return i.flags & 65536 ? i : null
            }
            return (i.flags & 128) !== 0 ? (i.lanes = a,
            i) : (c = c !== null,
            c !== (t !== null && t.memoizedState !== null) && c && (i.child.flags |= 8192,
            (i.mode & 1) !== 0 && (t === null || (jt.current & 1) !== 0 ? Qt === 0 && (Qt = 3) : su())),
            i.updateQueue !== null && (i.flags |= 4),
            mn(i),
            null);
        case 4:
            return ps(),
            Wc(t, i),
            t === null && sa(i.stateNode.containerInfo),
            mn(i),
            null;
        case 10:
            return xc(i.type._context),
            mn(i),
            null;
        case 17:
            return An(i.type) && uo(),
            mn(i),
            null;
        case 19:
            if (Bt(jt),
            h = i.memoizedState,
            h === null)
                return mn(i),
                null;
            if (c = (i.flags & 128) !== 0,
            w = h.rendering,
            w === null)
                if (c)
                    _a(h, !1);
                else {
                    if (Qt !== 0 || t !== null && (t.flags & 128) !== 0)
                        for (t = i.child; t !== null; ) {
                            if (w = wo(t),
                            w !== null) {
                                for (i.flags |= 128,
                                _a(h, !1),
                                c = w.updateQueue,
                                c !== null && (i.updateQueue = c,
                                i.flags |= 4),
                                i.subtreeFlags = 0,
                                c = a,
                                a = i.child; a !== null; )
                                    h = a,
                                    t = c,
                                    h.flags &= 14680066,
                                    w = h.alternate,
                                    w === null ? (h.childLanes = 0,
                                    h.lanes = t,
                                    h.child = null,
                                    h.subtreeFlags = 0,
                                    h.memoizedProps = null,
                                    h.memoizedState = null,
                                    h.updateQueue = null,
                                    h.dependencies = null,
                                    h.stateNode = null) : (h.childLanes = w.childLanes,
                                    h.lanes = w.lanes,
                                    h.child = w.child,
                                    h.subtreeFlags = 0,
                                    h.deletions = null,
                                    h.memoizedProps = w.memoizedProps,
                                    h.memoizedState = w.memoizedState,
                                    h.updateQueue = w.updateQueue,
                                    h.type = w.type,
                                    t = w.dependencies,
                                    h.dependencies = t === null ? null : {
                                        lanes: t.lanes,
                                        firstContext: t.firstContext
                                    }),
                                    a = a.sibling;
                                return Ft(jt, jt.current & 1 | 2),
                                i.child
                            }
                            t = t.sibling
                        }
                    h.tail !== null && W() > vs && (i.flags |= 128,
                    c = !0,
                    _a(h, !1),
                    i.lanes = 4194304)
                }
            else {
                if (!c)
                    if (t = wo(w),
                    t !== null) {
                        if (i.flags |= 128,
                        c = !0,
                        a = t.updateQueue,
                        a !== null && (i.updateQueue = a,
                        i.flags |= 4),
                        _a(h, !0),
                        h.tail === null && h.tailMode === "hidden" && !w.alternate && !Ht)
                            return mn(i),
                            null
                    } else
                        2 * W() - h.renderingStartTime > vs && a !== 1073741824 && (i.flags |= 128,
                        c = !0,
                        _a(h, !1),
                        i.lanes = 4194304);
                h.isBackwards ? (w.sibling = i.child,
                i.child = w) : (a = h.last,
                a !== null ? a.sibling = w : i.child = w,
                h.last = w)
            }
            return h.tail !== null ? (i = h.tail,
            h.rendering = i,
            h.tail = i.sibling,
            h.renderingStartTime = W(),
            i.sibling = null,
            a = jt.current,
            Ft(jt, c ? a & 1 | 2 : a & 1),
            i) : (mn(i),
            null);
        case 22:
        case 23:
            return ru(),
            c = i.memoizedState !== null,
            t !== null && t.memoizedState !== null !== c && (i.flags |= 8192),
            c && (i.mode & 1) !== 0 ? (Bn & 1073741824) !== 0 && (mn(i),
            i.subtreeFlags & 6 && (i.flags |= 8192)) : mn(i),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(n(156, i.tag))
    }
    function L0(t, i) {
        switch (hc(i),
        i.tag) {
        case 1:
            return An(i.type) && uo(),
            t = i.flags,
            t & 65536 ? (i.flags = t & -65537 | 128,
            i) : null;
        case 3:
            return ps(),
            Bt(Tn),
            Bt(hn),
            Ac(),
            t = i.flags,
            (t & 65536) !== 0 && (t & 128) === 0 ? (i.flags = t & -65537 | 128,
            i) : null;
        case 5:
            return Ec(i),
            null;
        case 13:
            if (Bt(jt),
            t = i.memoizedState,
            t !== null && t.dehydrated !== null) {
                if (i.alternate === null)
                    throw Error(n(340));
                us()
            }
            return t = i.flags,
            t & 65536 ? (i.flags = t & -65537 | 128,
            i) : null;
        case 19:
            return Bt(jt),
            null;
        case 4:
            return ps(),
            null;
        case 10:
            return xc(i.type._context),
            null;
        case 22:
        case 23:
            return ru(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var Po = !1
      , gn = !1
      , P0 = typeof WeakSet == "function" ? WeakSet : Set
      , Oe = null;
    function gs(t, i) {
        var a = t.ref;
        if (a !== null)
            if (typeof a == "function")
                try {
                    a(null)
                } catch (c) {
                    Wt(t, i, c)
                }
            else
                a.current = null
    }
    function Xc(t, i, a) {
        try {
            a()
        } catch (c) {
            Wt(t, i, c)
        }
    }
    var Zh = !1;
    function N0(t, i) {
        if (rc = $a,
        t = Pf(),
        $l(t)) {
            if ("selectionStart"in t)
                var a = {
                    start: t.selectionStart,
                    end: t.selectionEnd
                };
            else
                e: {
                    a = (a = t.ownerDocument) && a.defaultView || window;
                    var c = a.getSelection && a.getSelection();
                    if (c && c.rangeCount !== 0) {
                        a = c.anchorNode;
                        var d = c.anchorOffset
                          , h = c.focusNode;
                        c = c.focusOffset;
                        try {
                            a.nodeType,
                            h.nodeType
                        } catch {
                            a = null;
                            break e
                        }
                        var w = 0
                          , D = -1
                          , B = -1
                          , Z = 0
                          , _e = 0
                          , xe = t
                          , ge = null;
                        t: for (; ; ) {
                            for (var Ue; xe !== a || d !== 0 && xe.nodeType !== 3 || (D = w + d),
                            xe !== h || c !== 0 && xe.nodeType !== 3 || (B = w + c),
                            xe.nodeType === 3 && (w += xe.nodeValue.length),
                            (Ue = xe.firstChild) !== null; )
                                ge = xe,
                                xe = Ue;
                            for (; ; ) {
                                if (xe === t)
                                    break t;
                                if (ge === a && ++Z === d && (D = w),
                                ge === h && ++_e === c && (B = w),
                                (Ue = xe.nextSibling) !== null)
                                    break;
                                xe = ge,
                                ge = xe.parentNode
                            }
                            xe = Ue
                        }
                        a = D === -1 || B === -1 ? null : {
                            start: D,
                            end: B
                        }
                    } else
                        a = null
                }
            a = a || {
                start: 0,
                end: 0
            }
        } else
            a = null;
        for (sc = {
            focusedElem: t,
            selectionRange: a
        },
        $a = !1,
        Oe = i; Oe !== null; )
            if (i = Oe,
            t = i.child,
            (i.subtreeFlags & 1028) !== 0 && t !== null)
                t.return = i,
                Oe = t;
            else
                for (; Oe !== null; ) {
                    i = Oe;
                    try {
                        var Ve = i.alternate;
                        if ((i.flags & 1024) !== 0)
                            switch (i.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (Ve !== null) {
                                    var Ge = Ve.memoizedProps
                                      , Yt = Ve.memoizedState
                                      , q = i.stateNode
                                      , X = q.getSnapshotBeforeUpdate(i.elementType === i.type ? Ge : ii(i.type, Ge), Yt);
                                    q.__reactInternalSnapshotBeforeUpdate = X
                                }
                                break;
                            case 3:
                                var K = i.stateNode.containerInfo;
                                K.nodeType === 1 ? K.textContent = "" : K.nodeType === 9 && K.documentElement && K.removeChild(K.documentElement);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(n(163))
                            }
                    } catch (Ee) {
                        Wt(i, i.return, Ee)
                    }
                    if (t = i.sibling,
                    t !== null) {
                        t.return = i.return,
                        Oe = t;
                        break
                    }
                    Oe = i.return
                }
        return Ve = Zh,
        Zh = !1,
        Ve
    }
    function va(t, i, a) {
        var c = i.updateQueue;
        if (c = c !== null ? c.lastEffect : null,
        c !== null) {
            var d = c = c.next;
            do {
                if ((d.tag & t) === t) {
                    var h = d.destroy;
                    d.destroy = void 0,
                    h !== void 0 && Xc(i, a, h)
                }
                d = d.next
            } while (d !== c)
        }
    }
    function No(t, i) {
        if (i = i.updateQueue,
        i = i !== null ? i.lastEffect : null,
        i !== null) {
            var a = i = i.next;
            do {
                if ((a.tag & t) === t) {
                    var c = a.create;
                    a.destroy = c()
                }
                a = a.next
            } while (a !== i)
        }
    }
    function Yc(t) {
        var i = t.ref;
        if (i !== null) {
            var a = t.stateNode;
            switch (t.tag) {
            case 5:
                t = a;
                break;
            default:
                t = a
            }
            typeof i == "function" ? i(t) : i.current = t
        }
    }
    function ep(t) {
        var i = t.alternate;
        i !== null && (t.alternate = null,
        ep(i)),
        t.child = null,
        t.deletions = null,
        t.sibling = null,
        t.tag === 5 && (i = t.stateNode,
        i !== null && (delete i[pi],
        delete i[oa],
        delete i[cc],
        delete i[p0],
        delete i[m0])),
        t.stateNode = null,
        t.return = null,
        t.dependencies = null,
        t.memoizedProps = null,
        t.memoizedState = null,
        t.pendingProps = null,
        t.stateNode = null,
        t.updateQueue = null
    }
    function tp(t) {
        return t.tag === 5 || t.tag === 3 || t.tag === 4
    }
    function np(t) {
        e: for (; ; ) {
            for (; t.sibling === null; ) {
                if (t.return === null || tp(t.return))
                    return null;
                t = t.return
            }
            for (t.sibling.return = t.return,
            t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
                if (t.flags & 2 || t.child === null || t.tag === 4)
                    continue e;
                t.child.return = t,
                t = t.child
            }
            if (!(t.flags & 2))
                return t.stateNode
        }
    }
    function Jc(t, i, a) {
        var c = t.tag;
        if (c === 5 || c === 6)
            t = t.stateNode,
            i ? a.nodeType === 8 ? a.parentNode.insertBefore(t, i) : a.insertBefore(t, i) : (a.nodeType === 8 ? (i = a.parentNode,
            i.insertBefore(t, a)) : (i = a,
            i.appendChild(t)),
            a = a._reactRootContainer,
            a != null || i.onclick !== null || (i.onclick = lo));
        else if (c !== 4 && (t = t.child,
        t !== null))
            for (Jc(t, i, a),
            t = t.sibling; t !== null; )
                Jc(t, i, a),
                t = t.sibling
    }
    function qc(t, i, a) {
        var c = t.tag;
        if (c === 5 || c === 6)
            t = t.stateNode,
            i ? a.insertBefore(t, i) : a.appendChild(t);
        else if (c !== 4 && (t = t.child,
        t !== null))
            for (qc(t, i, a),
            t = t.sibling; t !== null; )
                qc(t, i, a),
                t = t.sibling
    }
    var an = null
      , ri = !1;
    function tr(t, i, a) {
        for (a = a.child; a !== null; )
            ip(t, i, a),
            a = a.sibling
    }
    function ip(t, i, a) {
        if (st && typeof st.onCommitFiberUnmount == "function")
            try {
                st.onCommitFiberUnmount($e, a)
            } catch {}
        switch (a.tag) {
        case 5:
            gn || gs(a, i);
        case 6:
            var c = an
              , d = ri;
            an = null,
            tr(t, i, a),
            an = c,
            ri = d,
            an !== null && (ri ? (t = an,
            a = a.stateNode,
            t.nodeType === 8 ? t.parentNode.removeChild(a) : t.removeChild(a)) : an.removeChild(a.stateNode));
            break;
        case 18:
            an !== null && (ri ? (t = an,
            a = a.stateNode,
            t.nodeType === 8 ? lc(t.parentNode, a) : t.nodeType === 1 && lc(t, a),
            $s(t)) : lc(an, a.stateNode));
            break;
        case 4:
            c = an,
            d = ri,
            an = a.stateNode.containerInfo,
            ri = !0,
            tr(t, i, a),
            an = c,
            ri = d;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!gn && (c = a.updateQueue,
            c !== null && (c = c.lastEffect,
            c !== null))) {
                d = c = c.next;
                do {
                    var h = d
                      , w = h.destroy;
                    h = h.tag,
                    w !== void 0 && ((h & 2) !== 0 || (h & 4) !== 0) && Xc(a, i, w),
                    d = d.next
                } while (d !== c)
            }
            tr(t, i, a);
            break;
        case 1:
            if (!gn && (gs(a, i),
            c = a.stateNode,
            typeof c.componentWillUnmount == "function"))
                try {
                    c.props = a.memoizedProps,
                    c.state = a.memoizedState,
                    c.componentWillUnmount()
                } catch (D) {
                    Wt(a, i, D)
                }
            tr(t, i, a);
            break;
        case 21:
            tr(t, i, a);
            break;
        case 22:
            a.mode & 1 ? (gn = (c = gn) || a.memoizedState !== null,
            tr(t, i, a),
            gn = c) : tr(t, i, a);
            break;
        default:
            tr(t, i, a)
        }
    }
    function rp(t) {
        var i = t.updateQueue;
        if (i !== null) {
            t.updateQueue = null;
            var a = t.stateNode;
            a === null && (a = t.stateNode = new P0),
            i.forEach(function(c) {
                var d = H0.bind(null, t, c);
                a.has(c) || (a.add(c),
                c.then(d, d))
            })
        }
    }
    function si(t, i) {
        var a = i.deletions;
        if (a !== null)
            for (var c = 0; c < a.length; c++) {
                var d = a[c];
                try {
                    var h = t
                      , w = i
                      , D = w;
                    e: for (; D !== null; ) {
                        switch (D.tag) {
                        case 5:
                            an = D.stateNode,
                            ri = !1;
                            break e;
                        case 3:
                            an = D.stateNode.containerInfo,
                            ri = !0;
                            break e;
                        case 4:
                            an = D.stateNode.containerInfo,
                            ri = !0;
                            break e
                        }
                        D = D.return
                    }
                    if (an === null)
                        throw Error(n(160));
                    ip(h, w, d),
                    an = null,
                    ri = !1;
                    var B = d.alternate;
                    B !== null && (B.return = null),
                    d.return = null
                } catch (Z) {
                    Wt(d, i, Z)
                }
            }
        if (i.subtreeFlags & 12854)
            for (i = i.child; i !== null; )
                sp(i, t),
                i = i.sibling
    }
    function sp(t, i) {
        var a = t.alternate
          , c = t.flags;
        switch (t.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (si(i, t),
            _i(t),
            c & 4) {
                try {
                    va(3, t, t.return),
                    No(3, t)
                } catch (Ge) {
                    Wt(t, t.return, Ge)
                }
                try {
                    va(5, t, t.return)
                } catch (Ge) {
                    Wt(t, t.return, Ge)
                }
            }
            break;
        case 1:
            si(i, t),
            _i(t),
            c & 512 && a !== null && gs(a, a.return);
            break;
        case 5:
            if (si(i, t),
            _i(t),
            c & 512 && a !== null && gs(a, a.return),
            t.flags & 32) {
                var d = t.stateNode;
                try {
                    Te(d, "")
                } catch (Ge) {
                    Wt(t, t.return, Ge)
                }
            }
            if (c & 4 && (d = t.stateNode,
            d != null)) {
                var h = t.memoizedProps
                  , w = a !== null ? a.memoizedProps : h
                  , D = t.type
                  , B = t.updateQueue;
                if (t.updateQueue = null,
                B !== null)
                    try {
                        D === "input" && h.type === "radio" && h.name != null && xt(d, h),
                        Re(D, w);
                        var Z = Re(D, h);
                        for (w = 0; w < B.length; w += 2) {
                            var _e = B[w]
                              , xe = B[w + 1];
                            _e === "style" ? Ne(d, xe) : _e === "dangerouslySetInnerHTML" ? Ye(d, xe) : _e === "children" ? Te(d, xe) : L(d, _e, xe, Z)
                        }
                        switch (D) {
                        case "input":
                            qe(d, h);
                            break;
                        case "textarea":
                            M(d, h);
                            break;
                        case "select":
                            var ge = d._wrapperState.wasMultiple;
                            d._wrapperState.wasMultiple = !!h.multiple;
                            var Ue = h.value;
                            Ue != null ? Ot(d, !!h.multiple, Ue, !1) : ge !== !!h.multiple && (h.defaultValue != null ? Ot(d, !!h.multiple, h.defaultValue, !0) : Ot(d, !!h.multiple, h.multiple ? [] : "", !1))
                        }
                        d[oa] = h
                    } catch (Ge) {
                        Wt(t, t.return, Ge)
                    }
            }
            break;
        case 6:
            if (si(i, t),
            _i(t),
            c & 4) {
                if (t.stateNode === null)
                    throw Error(n(162));
                d = t.stateNode,
                h = t.memoizedProps;
                try {
                    d.nodeValue = h
                } catch (Ge) {
                    Wt(t, t.return, Ge)
                }
            }
            break;
        case 3:
            if (si(i, t),
            _i(t),
            c & 4 && a !== null && a.memoizedState.isDehydrated)
                try {
                    $s(i.containerInfo)
                } catch (Ge) {
                    Wt(t, t.return, Ge)
                }
            break;
        case 4:
            si(i, t),
            _i(t);
            break;
        case 13:
            si(i, t),
            _i(t),
            d = t.child,
            d.flags & 8192 && (h = d.memoizedState !== null,
            d.stateNode.isHidden = h,
            !h || d.alternate !== null && d.alternate.memoizedState !== null || (Qc = W())),
            c & 4 && rp(t);
            break;
        case 22:
            if (_e = a !== null && a.memoizedState !== null,
            t.mode & 1 ? (gn = (Z = gn) || _e,
            si(i, t),
            gn = Z) : si(i, t),
            _i(t),
            c & 8192) {
                if (Z = t.memoizedState !== null,
                (t.stateNode.isHidden = Z) && !_e && (t.mode & 1) !== 0)
                    for (Oe = t,
                    _e = t.child; _e !== null; ) {
                        for (xe = Oe = _e; Oe !== null; ) {
                            switch (ge = Oe,
                            Ue = ge.child,
                            ge.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                va(4, ge, ge.return);
                                break;
                            case 1:
                                gs(ge, ge.return);
                                var Ve = ge.stateNode;
                                if (typeof Ve.componentWillUnmount == "function") {
                                    c = ge,
                                    a = ge.return;
                                    try {
                                        i = c,
                                        Ve.props = i.memoizedProps,
                                        Ve.state = i.memoizedState,
                                        Ve.componentWillUnmount()
                                    } catch (Ge) {
                                        Wt(c, a, Ge)
                                    }
                                }
                                break;
                            case 5:
                                gs(ge, ge.return);
                                break;
                            case 22:
                                if (ge.memoizedState !== null) {
                                    lp(xe);
                                    continue
                                }
                            }
                            Ue !== null ? (Ue.return = ge,
                            Oe = Ue) : lp(xe)
                        }
                        _e = _e.sibling
                    }
                e: for (_e = null,
                xe = t; ; ) {
                    if (xe.tag === 5) {
                        if (_e === null) {
                            _e = xe;
                            try {
                                d = xe.stateNode,
                                Z ? (h = d.style,
                                typeof h.setProperty == "function" ? h.setProperty("display", "none", "important") : h.display = "none") : (D = xe.stateNode,
                                B = xe.memoizedProps.style,
                                w = B != null && B.hasOwnProperty("display") ? B.display : null,
                                D.style.display = Me("display", w))
                            } catch (Ge) {
                                Wt(t, t.return, Ge)
                            }
                        }
                    } else if (xe.tag === 6) {
                        if (_e === null)
                            try {
                                xe.stateNode.nodeValue = Z ? "" : xe.memoizedProps
                            } catch (Ge) {
                                Wt(t, t.return, Ge)
                            }
                    } else if ((xe.tag !== 22 && xe.tag !== 23 || xe.memoizedState === null || xe === t) && xe.child !== null) {
                        xe.child.return = xe,
                        xe = xe.child;
                        continue
                    }
                    if (xe === t)
                        break e;
                    for (; xe.sibling === null; ) {
                        if (xe.return === null || xe.return === t)
                            break e;
                        _e === xe && (_e = null),
                        xe = xe.return
                    }
                    _e === xe && (_e = null),
                    xe.sibling.return = xe.return,
                    xe = xe.sibling
                }
            }
            break;
        case 19:
            si(i, t),
            _i(t),
            c & 4 && rp(t);
            break;
        case 21:
            break;
        default:
            si(i, t),
            _i(t)
        }
    }
    function _i(t) {
        var i = t.flags;
        if (i & 2) {
            try {
                e: {
                    for (var a = t.return; a !== null; ) {
                        if (tp(a)) {
                            var c = a;
                            break e
                        }
                        a = a.return
                    }
                    throw Error(n(160))
                }
                switch (c.tag) {
                case 5:
                    var d = c.stateNode;
                    c.flags & 32 && (Te(d, ""),
                    c.flags &= -33);
                    var h = np(t);
                    qc(t, h, d);
                    break;
                case 3:
                case 4:
                    var w = c.stateNode.containerInfo
                      , D = np(t);
                    Jc(t, D, w);
                    break;
                default:
                    throw Error(n(161))
                }
            } catch (B) {
                Wt(t, t.return, B)
            }
            t.flags &= -3
        }
        i & 4096 && (t.flags &= -4097)
    }
    function D0(t, i, a) {
        Oe = t,
        ap(t)
    }
    function ap(t, i, a) {
        for (var c = (t.mode & 1) !== 0; Oe !== null; ) {
            var d = Oe
              , h = d.child;
            if (d.tag === 22 && c) {
                var w = d.memoizedState !== null || Po;
                if (!w) {
                    var D = d.alternate
                      , B = D !== null && D.memoizedState !== null || gn;
                    D = Po;
                    var Z = gn;
                    if (Po = w,
                    (gn = B) && !Z)
                        for (Oe = d; Oe !== null; )
                            w = Oe,
                            B = w.child,
                            w.tag === 22 && w.memoizedState !== null ? cp(d) : B !== null ? (B.return = w,
                            Oe = B) : cp(d);
                    for (; h !== null; )
                        Oe = h,
                        ap(h),
                        h = h.sibling;
                    Oe = d,
                    Po = D,
                    gn = Z
                }
                op(t)
            } else
                (d.subtreeFlags & 8772) !== 0 && h !== null ? (h.return = d,
                Oe = h) : op(t)
        }
    }
    function op(t) {
        for (; Oe !== null; ) {
            var i = Oe;
            if ((i.flags & 8772) !== 0) {
                var a = i.alternate;
                try {
                    if ((i.flags & 8772) !== 0)
                        switch (i.tag) {
                        case 0:
                        case 11:
                        case 15:
                            gn || No(5, i);
                            break;
                        case 1:
                            var c = i.stateNode;
                            if (i.flags & 4 && !gn)
                                if (a === null)
                                    c.componentDidMount();
                                else {
                                    var d = i.elementType === i.type ? a.memoizedProps : ii(i.type, a.memoizedProps);
                                    c.componentDidUpdate(d, a.memoizedState, c.__reactInternalSnapshotBeforeUpdate)
                                }
                            var h = i.updateQueue;
                            h !== null && lh(i, h, c);
                            break;
                        case 3:
                            var w = i.updateQueue;
                            if (w !== null) {
                                if (a = null,
                                i.child !== null)
                                    switch (i.child.tag) {
                                    case 5:
                                        a = i.child.stateNode;
                                        break;
                                    case 1:
                                        a = i.child.stateNode
                                    }
                                lh(i, w, a)
                            }
                            break;
                        case 5:
                            var D = i.stateNode;
                            if (a === null && i.flags & 4) {
                                a = D;
                                var B = i.memoizedProps;
                                switch (i.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    B.autoFocus && a.focus();
                                    break;
                                case "img":
                                    B.src && (a.src = B.src)
                                }
                            }
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (i.memoizedState === null) {
                                var Z = i.alternate;
                                if (Z !== null) {
                                    var _e = Z.memoizedState;
                                    if (_e !== null) {
                                        var xe = _e.dehydrated;
                                        xe !== null && $s(xe)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                        case 25:
                            break;
                        default:
                            throw Error(n(163))
                        }
                    gn || i.flags & 512 && Yc(i)
                } catch (ge) {
                    Wt(i, i.return, ge)
                }
            }
            if (i === t) {
                Oe = null;
                break
            }
            if (a = i.sibling,
            a !== null) {
                a.return = i.return,
                Oe = a;
                break
            }
            Oe = i.return
        }
    }
    function lp(t) {
        for (; Oe !== null; ) {
            var i = Oe;
            if (i === t) {
                Oe = null;
                break
            }
            var a = i.sibling;
            if (a !== null) {
                a.return = i.return,
                Oe = a;
                break
            }
            Oe = i.return
        }
    }
    function cp(t) {
        for (; Oe !== null; ) {
            var i = Oe;
            try {
                switch (i.tag) {
                case 0:
                case 11:
                case 15:
                    var a = i.return;
                    try {
                        No(4, i)
                    } catch (B) {
                        Wt(i, a, B)
                    }
                    break;
                case 1:
                    var c = i.stateNode;
                    if (typeof c.componentDidMount == "function") {
                        var d = i.return;
                        try {
                            c.componentDidMount()
                        } catch (B) {
                            Wt(i, d, B)
                        }
                    }
                    var h = i.return;
                    try {
                        Yc(i)
                    } catch (B) {
                        Wt(i, h, B)
                    }
                    break;
                case 5:
                    var w = i.return;
                    try {
                        Yc(i)
                    } catch (B) {
                        Wt(i, w, B)
                    }
                }
            } catch (B) {
                Wt(i, i.return, B)
            }
            if (i === t) {
                Oe = null;
                break
            }
            var D = i.sibling;
            if (D !== null) {
                D.return = i.return,
                Oe = D;
                break
            }
            Oe = i.return
        }
    }
    var I0 = Math.ceil
      , Do = C.ReactCurrentDispatcher
      , $c = C.ReactCurrentOwner
      , qn = C.ReactCurrentBatchConfig
      , wt = 0
      , nn = null
      , Jt = null
      , on = 0
      , Bn = 0
      , _s = $i(0)
      , Qt = 0
      , xa = null
      , br = 0
      , Io = 0
      , Kc = 0
      , ya = null
      , Rn = null
      , Qc = 0
      , vs = 1 / 0
      , Ni = null
      , Uo = !1
      , Zc = null
      , nr = null
      , Fo = !1
      , ir = null
      , Oo = 0
      , Sa = 0
      , eu = null
      , zo = -1
      , ko = 0;
    function Mn() {
        return (wt & 6) !== 0 ? W() : zo !== -1 ? zo : zo = W()
    }
    function rr(t) {
        return (t.mode & 1) === 0 ? 1 : (wt & 2) !== 0 && on !== 0 ? on & -on : _0.transition !== null ? (ko === 0 && (ko = Sn()),
        ko) : (t = pt,
        t !== 0 || (t = window.event,
        t = t === void 0 ? 16 : df(t.type)),
        t)
    }
    function ai(t, i, a, c) {
        if (50 < Sa)
            throw Sa = 0,
            eu = null,
            Error(n(185));
        Xt(t, a, c),
        ((wt & 2) === 0 || t !== nn) && (t === nn && ((wt & 2) === 0 && (Io |= a),
        Qt === 4 && sr(t, on)),
        bn(t, c),
        a === 1 && wt === 0 && (i.mode & 1) === 0 && (vs = W() + 500,
        ho && Qi()))
    }
    function bn(t, i) {
        var a = t.callbackNode;
        yr(t, i);
        var c = ei(t, t === nn ? on : 0);
        if (c === 0)
            a !== null && Y(a),
            t.callbackNode = null,
            t.callbackPriority = 0;
        else if (i = c & -c,
        t.callbackPriority !== i) {
            if (a != null && Y(a),
            i === 1)
                t.tag === 0 ? g0(dp.bind(null, t)) : $f(dp.bind(null, t)),
                f0(function() {
                    (wt & 6) === 0 && Qi()
                }),
                a = null;
            else {
                switch (nf(c)) {
                case 1:
                    a = be;
                    break;
                case 4:
                    a = He;
                    break;
                case 16:
                    a = Ie;
                    break;
                case 536870912:
                    a = rt;
                    break;
                default:
                    a = Ie
                }
                a = xp(a, up.bind(null, t))
            }
            t.callbackPriority = i,
            t.callbackNode = a
        }
    }
    function up(t, i) {
        if (zo = -1,
        ko = 0,
        (wt & 6) !== 0)
            throw Error(n(327));
        var a = t.callbackNode;
        if (xs() && t.callbackNode !== a)
            return null;
        var c = ei(t, t === nn ? on : 0);
        if (c === 0)
            return null;
        if ((c & 30) !== 0 || (c & t.expiredLanes) !== 0 || i)
            i = Bo(t, c);
        else {
            i = c;
            var d = wt;
            wt |= 2;
            var h = hp();
            (nn !== t || on !== i) && (Ni = null,
            vs = W() + 500,
            Pr(t, i));
            do
                try {
                    O0();
                    break
                } catch (D) {
                    fp(t, D)
                }
            while (!0);
            vc(),
            Do.current = h,
            wt = d,
            Jt !== null ? i = 0 : (nn = null,
            on = 0,
            i = Qt)
        }
        if (i !== 0) {
            if (i === 2 && (d = It(t),
            d !== 0 && (c = d,
            i = tu(t, d))),
            i === 1)
                throw a = xa,
                Pr(t, 0),
                sr(t, c),
                bn(t, W()),
                a;
            if (i === 6)
                sr(t, c);
            else {
                if (d = t.current.alternate,
                (c & 30) === 0 && !U0(d) && (i = Bo(t, c),
                i === 2 && (h = It(t),
                h !== 0 && (c = h,
                i = tu(t, h))),
                i === 1))
                    throw a = xa,
                    Pr(t, 0),
                    sr(t, c),
                    bn(t, W()),
                    a;
                switch (t.finishedWork = d,
                t.finishedLanes = c,
                i) {
                case 0:
                case 1:
                    throw Error(n(345));
                case 2:
                    Nr(t, Rn, Ni);
                    break;
                case 3:
                    if (sr(t, c),
                    (c & 130023424) === c && (i = Qc + 500 - W(),
                    10 < i)) {
                        if (ei(t, 0) !== 0)
                            break;
                        if (d = t.suspendedLanes,
                        (d & c) !== c) {
                            Mn(),
                            t.pingedLanes |= t.suspendedLanes & d;
                            break
                        }
                        t.timeoutHandle = oc(Nr.bind(null, t, Rn, Ni), i);
                        break
                    }
                    Nr(t, Rn, Ni);
                    break;
                case 4:
                    if (sr(t, c),
                    (c & 4194240) === c)
                        break;
                    for (i = t.eventTimes,
                    d = -1; 0 < c; ) {
                        var w = 31 - St(c);
                        h = 1 << w,
                        w = i[w],
                        w > d && (d = w),
                        c &= ~h
                    }
                    if (c = d,
                    c = W() - c,
                    c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * I0(c / 1960)) - c,
                    10 < c) {
                        t.timeoutHandle = oc(Nr.bind(null, t, Rn, Ni), c);
                        break
                    }
                    Nr(t, Rn, Ni);
                    break;
                case 5:
                    Nr(t, Rn, Ni);
                    break;
                default:
                    throw Error(n(329))
                }
            }
        }
        return bn(t, W()),
        t.callbackNode === a ? up.bind(null, t) : null
    }
    function tu(t, i) {
        var a = ya;
        return t.current.memoizedState.isDehydrated && (Pr(t, i).flags |= 256),
        t = Bo(t, i),
        t !== 2 && (i = Rn,
        Rn = a,
        i !== null && nu(i)),
        t
    }
    function nu(t) {
        Rn === null ? Rn = t : Rn.push.apply(Rn, t)
    }
    function U0(t) {
        for (var i = t; ; ) {
            if (i.flags & 16384) {
                var a = i.updateQueue;
                if (a !== null && (a = a.stores,
                a !== null))
                    for (var c = 0; c < a.length; c++) {
                        var d = a[c]
                          , h = d.getSnapshot;
                        d = d.value;
                        try {
                            if (!ti(h(), d))
                                return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (a = i.child,
            i.subtreeFlags & 16384 && a !== null)
                a.return = i,
                i = a;
            else {
                if (i === t)
                    break;
                for (; i.sibling === null; ) {
                    if (i.return === null || i.return === t)
                        return !0;
                    i = i.return
                }
                i.sibling.return = i.return,
                i = i.sibling
            }
        }
        return !0
    }
    function sr(t, i) {
        for (i &= ~Kc,
        i &= ~Io,
        t.suspendedLanes |= i,
        t.pingedLanes &= ~i,
        t = t.expirationTimes; 0 < i; ) {
            var a = 31 - St(i)
              , c = 1 << a;
            t[a] = -1,
            i &= ~c
        }
    }
    function dp(t) {
        if ((wt & 6) !== 0)
            throw Error(n(327));
        xs();
        var i = ei(t, 0);
        if ((i & 1) === 0)
            return bn(t, W()),
            null;
        var a = Bo(t, i);
        if (t.tag !== 0 && a === 2) {
            var c = It(t);
            c !== 0 && (i = c,
            a = tu(t, c))
        }
        if (a === 1)
            throw a = xa,
            Pr(t, 0),
            sr(t, i),
            bn(t, W()),
            a;
        if (a === 6)
            throw Error(n(345));
        return t.finishedWork = t.current.alternate,
        t.finishedLanes = i,
        Nr(t, Rn, Ni),
        bn(t, W()),
        null
    }
    function iu(t, i) {
        var a = wt;
        wt |= 1;
        try {
            return t(i)
        } finally {
            wt = a,
            wt === 0 && (vs = W() + 500,
            ho && Qi())
        }
    }
    function Lr(t) {
        ir !== null && ir.tag === 0 && (wt & 6) === 0 && xs();
        var i = wt;
        wt |= 1;
        var a = qn.transition
          , c = pt;
        try {
            if (qn.transition = null,
            pt = 1,
            t)
                return t()
        } finally {
            pt = c,
            qn.transition = a,
            wt = i,
            (wt & 6) === 0 && Qi()
        }
    }
    function ru() {
        Bn = _s.current,
        Bt(_s)
    }
    function Pr(t, i) {
        t.finishedWork = null,
        t.finishedLanes = 0;
        var a = t.timeoutHandle;
        if (a !== -1 && (t.timeoutHandle = -1,
        d0(a)),
        Jt !== null)
            for (a = Jt.return; a !== null; ) {
                var c = a;
                switch (hc(c),
                c.tag) {
                case 1:
                    c = c.type.childContextTypes,
                    c != null && uo();
                    break;
                case 3:
                    ps(),
                    Bt(Tn),
                    Bt(hn),
                    Ac();
                    break;
                case 5:
                    Ec(c);
                    break;
                case 4:
                    ps();
                    break;
                case 13:
                    Bt(jt);
                    break;
                case 19:
                    Bt(jt);
                    break;
                case 10:
                    xc(c.type._context);
                    break;
                case 22:
                case 23:
                    ru()
                }
                a = a.return
            }
        if (nn = t,
        Jt = t = ar(t.current, null),
        on = Bn = i,
        Qt = 0,
        xa = null,
        Kc = Io = br = 0,
        Rn = ya = null,
        Ar !== null) {
            for (i = 0; i < Ar.length; i++)
                if (a = Ar[i],
                c = a.interleaved,
                c !== null) {
                    a.interleaved = null;
                    var d = c.next
                      , h = a.pending;
                    if (h !== null) {
                        var w = h.next;
                        h.next = d,
                        c.next = w
                    }
                    a.pending = c
                }
            Ar = null
        }
        return t
    }
    function fp(t, i) {
        do {
            var a = Jt;
            try {
                if (vc(),
                Mo.current = Co,
                Eo) {
                    for (var c = Gt.memoizedState; c !== null; ) {
                        var d = c.queue;
                        d !== null && (d.pending = null),
                        c = c.next
                    }
                    Eo = !1
                }
                if (Rr = 0,
                tn = Kt = Gt = null,
                ha = !1,
                pa = 0,
                $c.current = null,
                a === null || a.return === null) {
                    Qt = 1,
                    xa = i,
                    Jt = null;
                    break
                }
                e: {
                    var h = t
                      , w = a.return
                      , D = a
                      , B = i;
                    if (i = on,
                    D.flags |= 32768,
                    B !== null && typeof B == "object" && typeof B.then == "function") {
                        var Z = B
                          , _e = D
                          , xe = _e.tag;
                        if ((_e.mode & 1) === 0 && (xe === 0 || xe === 11 || xe === 15)) {
                            var ge = _e.alternate;
                            ge ? (_e.updateQueue = ge.updateQueue,
                            _e.memoizedState = ge.memoizedState,
                            _e.lanes = ge.lanes) : (_e.updateQueue = null,
                            _e.memoizedState = null)
                        }
                        var Ue = Oh(w);
                        if (Ue !== null) {
                            Ue.flags &= -257,
                            zh(Ue, w, D, h, i),
                            Ue.mode & 1 && Fh(h, Z, i),
                            i = Ue,
                            B = Z;
                            var Ve = i.updateQueue;
                            if (Ve === null) {
                                var Ge = new Set;
                                Ge.add(B),
                                i.updateQueue = Ge
                            } else
                                Ve.add(B);
                            break e
                        } else {
                            if ((i & 1) === 0) {
                                Fh(h, Z, i),
                                su();
                                break e
                            }
                            B = Error(n(426))
                        }
                    } else if (Ht && D.mode & 1) {
                        var Yt = Oh(w);
                        if (Yt !== null) {
                            (Yt.flags & 65536) === 0 && (Yt.flags |= 256),
                            zh(Yt, w, D, h, i),
                            gc(ms(B, D));
                            break e
                        }
                    }
                    h = B = ms(B, D),
                    Qt !== 4 && (Qt = 2),
                    ya === null ? ya = [h] : ya.push(h),
                    h = w;
                    do {
                        switch (h.tag) {
                        case 3:
                            h.flags |= 65536,
                            i &= -i,
                            h.lanes |= i;
                            var q = Ih(h, B, i);
                            oh(h, q);
                            break e;
                        case 1:
                            D = B;
                            var X = h.type
                              , K = h.stateNode;
                            if ((h.flags & 128) === 0 && (typeof X.getDerivedStateFromError == "function" || K !== null && typeof K.componentDidCatch == "function" && (nr === null || !nr.has(K)))) {
                                h.flags |= 65536,
                                i &= -i,
                                h.lanes |= i;
                                var Ee = Uh(h, D, i);
                                oh(h, Ee);
                                break e
                            }
                        }
                        h = h.return
                    } while (h !== null)
                }
                mp(a)
            } catch (Xe) {
                i = Xe,
                Jt === a && a !== null && (Jt = a = a.return);
                continue
            }
            break
        } while (!0)
    }
    function hp() {
        var t = Do.current;
        return Do.current = Co,
        t === null ? Co : t
    }
    function su() {
        (Qt === 0 || Qt === 3 || Qt === 2) && (Qt = 4),
        nn === null || (br & 268435455) === 0 && (Io & 268435455) === 0 || sr(nn, on)
    }
    function Bo(t, i) {
        var a = wt;
        wt |= 2;
        var c = hp();
        (nn !== t || on !== i) && (Ni = null,
        Pr(t, i));
        do
            try {
                F0();
                break
            } catch (d) {
                fp(t, d)
            }
        while (!0);
        if (vc(),
        wt = a,
        Do.current = c,
        Jt !== null)
            throw Error(n(261));
        return nn = null,
        on = 0,
        Qt
    }
    function F0() {
        for (; Jt !== null; )
            pp(Jt)
    }
    function O0() {
        for (; Jt !== null && !ee(); )
            pp(Jt)
    }
    function pp(t) {
        var i = vp(t.alternate, t, Bn);
        t.memoizedProps = t.pendingProps,
        i === null ? mp(t) : Jt = i,
        $c.current = null
    }
    function mp(t) {
        var i = t;
        do {
            var a = i.alternate;
            if (t = i.return,
            (i.flags & 32768) === 0) {
                if (a = b0(a, i, Bn),
                a !== null) {
                    Jt = a;
                    return
                }
            } else {
                if (a = L0(a, i),
                a !== null) {
                    a.flags &= 32767,
                    Jt = a;
                    return
                }
                if (t !== null)
                    t.flags |= 32768,
                    t.subtreeFlags = 0,
                    t.deletions = null;
                else {
                    Qt = 6,
                    Jt = null;
                    return
                }
            }
            if (i = i.sibling,
            i !== null) {
                Jt = i;
                return
            }
            Jt = i = t
        } while (i !== null);
        Qt === 0 && (Qt = 5)
    }
    function Nr(t, i, a) {
        var c = pt
          , d = qn.transition;
        try {
            qn.transition = null,
            pt = 1,
            z0(t, i, a, c)
        } finally {
            qn.transition = d,
            pt = c
        }
        return null
    }
    function z0(t, i, a, c) {
        do
            xs();
        while (ir !== null);
        if ((wt & 6) !== 0)
            throw Error(n(327));
        a = t.finishedWork;
        var d = t.finishedLanes;
        if (a === null)
            return null;
        if (t.finishedWork = null,
        t.finishedLanes = 0,
        a === t.current)
            throw Error(n(177));
        t.callbackNode = null,
        t.callbackPriority = 0;
        var h = a.lanes | a.childLanes;
        if (fn(t, h),
        t === nn && (Jt = nn = null,
        on = 0),
        (a.subtreeFlags & 2064) === 0 && (a.flags & 2064) === 0 || Fo || (Fo = !0,
        xp(Ie, function() {
            return xs(),
            null
        })),
        h = (a.flags & 15990) !== 0,
        (a.subtreeFlags & 15990) !== 0 || h) {
            h = qn.transition,
            qn.transition = null;
            var w = pt;
            pt = 1;
            var D = wt;
            wt |= 4,
            $c.current = null,
            N0(t, a),
            sp(a, t),
            r0(sc),
            $a = !!rc,
            sc = rc = null,
            t.current = a,
            D0(a),
            te(),
            wt = D,
            pt = w,
            qn.transition = h
        } else
            t.current = a;
        if (Fo && (Fo = !1,
        ir = t,
        Oo = d),
        h = t.pendingLanes,
        h === 0 && (nr = null),
        At(a.stateNode),
        bn(t, W()),
        i !== null)
            for (c = t.onRecoverableError,
            a = 0; a < i.length; a++)
                d = i[a],
                c(d.value, {
                    componentStack: d.stack,
                    digest: d.digest
                });
        if (Uo)
            throw Uo = !1,
            t = Zc,
            Zc = null,
            t;
        return (Oo & 1) !== 0 && t.tag !== 0 && xs(),
        h = t.pendingLanes,
        (h & 1) !== 0 ? t === eu ? Sa++ : (Sa = 0,
        eu = t) : Sa = 0,
        Qi(),
        null
    }
    function xs() {
        if (ir !== null) {
            var t = nf(Oo)
              , i = qn.transition
              , a = pt;
            try {
                if (qn.transition = null,
                pt = 16 > t ? 16 : t,
                ir === null)
                    var c = !1;
                else {
                    if (t = ir,
                    ir = null,
                    Oo = 0,
                    (wt & 6) !== 0)
                        throw Error(n(331));
                    var d = wt;
                    for (wt |= 4,
                    Oe = t.current; Oe !== null; ) {
                        var h = Oe
                          , w = h.child;
                        if ((Oe.flags & 16) !== 0) {
                            var D = h.deletions;
                            if (D !== null) {
                                for (var B = 0; B < D.length; B++) {
                                    var Z = D[B];
                                    for (Oe = Z; Oe !== null; ) {
                                        var _e = Oe;
                                        switch (_e.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            va(8, _e, h)
                                        }
                                        var xe = _e.child;
                                        if (xe !== null)
                                            xe.return = _e,
                                            Oe = xe;
                                        else
                                            for (; Oe !== null; ) {
                                                _e = Oe;
                                                var ge = _e.sibling
                                                  , Ue = _e.return;
                                                if (ep(_e),
                                                _e === Z) {
                                                    Oe = null;
                                                    break
                                                }
                                                if (ge !== null) {
                                                    ge.return = Ue,
                                                    Oe = ge;
                                                    break
                                                }
                                                Oe = Ue
                                            }
                                    }
                                }
                                var Ve = h.alternate;
                                if (Ve !== null) {
                                    var Ge = Ve.child;
                                    if (Ge !== null) {
                                        Ve.child = null;
                                        do {
                                            var Yt = Ge.sibling;
                                            Ge.sibling = null,
                                            Ge = Yt
                                        } while (Ge !== null)
                                    }
                                }
                                Oe = h
                            }
                        }
                        if ((h.subtreeFlags & 2064) !== 0 && w !== null)
                            w.return = h,
                            Oe = w;
                        else
                            e: for (; Oe !== null; ) {
                                if (h = Oe,
                                (h.flags & 2048) !== 0)
                                    switch (h.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        va(9, h, h.return)
                                    }
                                var q = h.sibling;
                                if (q !== null) {
                                    q.return = h.return,
                                    Oe = q;
                                    break e
                                }
                                Oe = h.return
                            }
                    }
                    var X = t.current;
                    for (Oe = X; Oe !== null; ) {
                        w = Oe;
                        var K = w.child;
                        if ((w.subtreeFlags & 2064) !== 0 && K !== null)
                            K.return = w,
                            Oe = K;
                        else
                            e: for (w = X; Oe !== null; ) {
                                if (D = Oe,
                                (D.flags & 2048) !== 0)
                                    try {
                                        switch (D.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            No(9, D)
                                        }
                                    } catch (Xe) {
                                        Wt(D, D.return, Xe)
                                    }
                                if (D === w) {
                                    Oe = null;
                                    break e
                                }
                                var Ee = D.sibling;
                                if (Ee !== null) {
                                    Ee.return = D.return,
                                    Oe = Ee;
                                    break e
                                }
                                Oe = D.return
                            }
                    }
                    if (wt = d,
                    Qi(),
                    st && typeof st.onPostCommitFiberRoot == "function")
                        try {
                            st.onPostCommitFiberRoot($e, t)
                        } catch {}
                    c = !0
                }
                return c
            } finally {
                pt = a,
                qn.transition = i
            }
        }
        return !1
    }
    function gp(t, i, a) {
        i = ms(a, i),
        i = Ih(t, i, 1),
        t = er(t, i, 1),
        i = Mn(),
        t !== null && (Xt(t, 1, i),
        bn(t, i))
    }
    function Wt(t, i, a) {
        if (t.tag === 3)
            gp(t, t, a);
        else
            for (; i !== null; ) {
                if (i.tag === 3) {
                    gp(i, t, a);
                    break
                } else if (i.tag === 1) {
                    var c = i.stateNode;
                    if (typeof i.type.getDerivedStateFromError == "function" || typeof c.componentDidCatch == "function" && (nr === null || !nr.has(c))) {
                        t = ms(a, t),
                        t = Uh(i, t, 1),
                        i = er(i, t, 1),
                        t = Mn(),
                        i !== null && (Xt(i, 1, t),
                        bn(i, t));
                        break
                    }
                }
                i = i.return
            }
    }
    function k0(t, i, a) {
        var c = t.pingCache;
        c !== null && c.delete(i),
        i = Mn(),
        t.pingedLanes |= t.suspendedLanes & a,
        nn === t && (on & a) === a && (Qt === 4 || Qt === 3 && (on & 130023424) === on && 500 > W() - Qc ? Pr(t, 0) : Kc |= a),
        bn(t, i)
    }
    function _p(t, i) {
        i === 0 && ((t.mode & 1) === 0 ? i = 1 : (i = ht,
        ht <<= 1,
        (ht & 130023424) === 0 && (ht = 4194304)));
        var a = Mn();
        t = bi(t, i),
        t !== null && (Xt(t, i, a),
        bn(t, a))
    }
    function B0(t) {
        var i = t.memoizedState
          , a = 0;
        i !== null && (a = i.retryLane),
        _p(t, a)
    }
    function H0(t, i) {
        var a = 0;
        switch (t.tag) {
        case 13:
            var c = t.stateNode
              , d = t.memoizedState;
            d !== null && (a = d.retryLane);
            break;
        case 19:
            c = t.stateNode;
            break;
        default:
            throw Error(n(314))
        }
        c !== null && c.delete(i),
        _p(t, a)
    }
    var vp;
    vp = function(t, i, a) {
        if (t !== null)
            if (t.memoizedProps !== i.pendingProps || Tn.current)
                Cn = !0;
            else {
                if ((t.lanes & a) === 0 && (i.flags & 128) === 0)
                    return Cn = !1,
                    R0(t, i, a);
                Cn = (t.flags & 131072) !== 0
            }
        else
            Cn = !1,
            Ht && (i.flags & 1048576) !== 0 && Kf(i, mo, i.index);
        switch (i.lanes = 0,
        i.tag) {
        case 2:
            var c = i.type;
            Lo(t, i),
            t = i.pendingProps;
            var d = os(i, hn.current);
            hs(i, a),
            d = bc(null, i, c, t, d, a);
            var h = Lc();
            return i.flags |= 1,
            typeof d == "object" && d !== null && typeof d.render == "function" && d.$$typeof === void 0 ? (i.tag = 1,
            i.memoizedState = null,
            i.updateQueue = null,
            An(c) ? (h = !0,
            fo(i)) : h = !1,
            i.memoizedState = d.state !== null && d.state !== void 0 ? d.state : null,
            wc(i),
            d.updater = Ro,
            i.stateNode = d,
            d._reactInternals = i,
            Fc(i, c, t, a),
            i = Bc(null, i, c, !0, h, a)) : (i.tag = 0,
            Ht && h && fc(i),
            wn(null, i, d, a),
            i = i.child),
            i;
        case 16:
            c = i.elementType;
            e: {
                switch (Lo(t, i),
                t = i.pendingProps,
                d = c._init,
                c = d(c._payload),
                i.type = c,
                d = i.tag = j0(c),
                t = ii(c, t),
                d) {
                case 0:
                    i = kc(null, i, c, t, a);
                    break e;
                case 1:
                    i = Gh(null, i, c, t, a);
                    break e;
                case 11:
                    i = kh(null, i, c, t, a);
                    break e;
                case 14:
                    i = Bh(null, i, c, ii(c.type, t), a);
                    break e
                }
                throw Error(n(306, c, ""))
            }
            return i;
        case 0:
            return c = i.type,
            d = i.pendingProps,
            d = i.elementType === c ? d : ii(c, d),
            kc(t, i, c, d, a);
        case 1:
            return c = i.type,
            d = i.pendingProps,
            d = i.elementType === c ? d : ii(c, d),
            Gh(t, i, c, d, a);
        case 3:
            e: {
                if (Wh(i),
                t === null)
                    throw Error(n(387));
                c = i.pendingProps,
                h = i.memoizedState,
                d = h.element,
                ah(t, i),
                So(i, c, null, a);
                var w = i.memoizedState;
                if (c = w.element,
                h.isDehydrated)
                    if (h = {
                        element: c,
                        isDehydrated: !1,
                        cache: w.cache,
                        pendingSuspenseBoundaries: w.pendingSuspenseBoundaries,
                        transitions: w.transitions
                    },
                    i.updateQueue.baseState = h,
                    i.memoizedState = h,
                    i.flags & 256) {
                        d = ms(Error(n(423)), i),
                        i = Xh(t, i, c, a, d);
                        break e
                    } else if (c !== d) {
                        d = ms(Error(n(424)), i),
                        i = Xh(t, i, c, a, d);
                        break e
                    } else
                        for (kn = qi(i.stateNode.containerInfo.firstChild),
                        zn = i,
                        Ht = !0,
                        ni = null,
                        a = rh(i, null, c, a),
                        i.child = a; a; )
                            a.flags = a.flags & -3 | 4096,
                            a = a.sibling;
                else {
                    if (us(),
                    c === d) {
                        i = Pi(t, i, a);
                        break e
                    }
                    wn(t, i, c, a)
                }
                i = i.child
            }
            return i;
        case 5:
            return ch(i),
            t === null && mc(i),
            c = i.type,
            d = i.pendingProps,
            h = t !== null ? t.memoizedProps : null,
            w = d.children,
            ac(c, d) ? w = null : h !== null && ac(c, h) && (i.flags |= 32),
            jh(t, i),
            wn(t, i, w, a),
            i.child;
        case 6:
            return t === null && mc(i),
            null;
        case 13:
            return Yh(t, i, a);
        case 4:
            return Mc(i, i.stateNode.containerInfo),
            c = i.pendingProps,
            t === null ? i.child = ds(i, null, c, a) : wn(t, i, c, a),
            i.child;
        case 11:
            return c = i.type,
            d = i.pendingProps,
            d = i.elementType === c ? d : ii(c, d),
            kh(t, i, c, d, a);
        case 7:
            return wn(t, i, i.pendingProps, a),
            i.child;
        case 8:
            return wn(t, i, i.pendingProps.children, a),
            i.child;
        case 12:
            return wn(t, i, i.pendingProps.children, a),
            i.child;
        case 10:
            e: {
                if (c = i.type._context,
                d = i.pendingProps,
                h = i.memoizedProps,
                w = d.value,
                Ft(vo, c._currentValue),
                c._currentValue = w,
                h !== null)
                    if (ti(h.value, w)) {
                        if (h.children === d.children && !Tn.current) {
                            i = Pi(t, i, a);
                            break e
                        }
                    } else
                        for (h = i.child,
                        h !== null && (h.return = i); h !== null; ) {
                            var D = h.dependencies;
                            if (D !== null) {
                                w = h.child;
                                for (var B = D.firstContext; B !== null; ) {
                                    if (B.context === c) {
                                        if (h.tag === 1) {
                                            B = Li(-1, a & -a),
                                            B.tag = 2;
                                            var Z = h.updateQueue;
                                            if (Z !== null) {
                                                Z = Z.shared;
                                                var _e = Z.pending;
                                                _e === null ? B.next = B : (B.next = _e.next,
                                                _e.next = B),
                                                Z.pending = B
                                            }
                                        }
                                        h.lanes |= a,
                                        B = h.alternate,
                                        B !== null && (B.lanes |= a),
                                        yc(h.return, a, i),
                                        D.lanes |= a;
                                        break
                                    }
                                    B = B.next
                                }
                            } else if (h.tag === 10)
                                w = h.type === i.type ? null : h.child;
                            else if (h.tag === 18) {
                                if (w = h.return,
                                w === null)
                                    throw Error(n(341));
                                w.lanes |= a,
                                D = w.alternate,
                                D !== null && (D.lanes |= a),
                                yc(w, a, i),
                                w = h.sibling
                            } else
                                w = h.child;
                            if (w !== null)
                                w.return = h;
                            else
                                for (w = h; w !== null; ) {
                                    if (w === i) {
                                        w = null;
                                        break
                                    }
                                    if (h = w.sibling,
                                    h !== null) {
                                        h.return = w.return,
                                        w = h;
                                        break
                                    }
                                    w = w.return
                                }
                            h = w
                        }
                wn(t, i, d.children, a),
                i = i.child
            }
            return i;
        case 9:
            return d = i.type,
            c = i.pendingProps.children,
            hs(i, a),
            d = Yn(d),
            c = c(d),
            i.flags |= 1,
            wn(t, i, c, a),
            i.child;
        case 14:
            return c = i.type,
            d = ii(c, i.pendingProps),
            d = ii(c.type, d),
            Bh(t, i, c, d, a);
        case 15:
            return Hh(t, i, i.type, i.pendingProps, a);
        case 17:
            return c = i.type,
            d = i.pendingProps,
            d = i.elementType === c ? d : ii(c, d),
            Lo(t, i),
            i.tag = 1,
            An(c) ? (t = !0,
            fo(i)) : t = !1,
            hs(i, a),
            Nh(i, c, d),
            Fc(i, c, d, a),
            Bc(null, i, c, !0, t, a);
        case 19:
            return qh(t, i, a);
        case 22:
            return Vh(t, i, a)
        }
        throw Error(n(156, i.tag))
    }
    ;
    function xp(t, i) {
        return A(t, i)
    }
    function V0(t, i, a, c) {
        this.tag = t,
        this.key = a,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = i,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = c,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function $n(t, i, a, c) {
        return new V0(t,i,a,c)
    }
    function au(t) {
        return t = t.prototype,
        !(!t || !t.isReactComponent)
    }
    function j0(t) {
        if (typeof t == "function")
            return au(t) ? 1 : 0;
        if (t != null) {
            if (t = t.$$typeof,
            t === oe)
                return 11;
            if (t === ne)
                return 14
        }
        return 2
    }
    function ar(t, i) {
        var a = t.alternate;
        return a === null ? (a = $n(t.tag, i, t.key, t.mode),
        a.elementType = t.elementType,
        a.type = t.type,
        a.stateNode = t.stateNode,
        a.alternate = t,
        t.alternate = a) : (a.pendingProps = i,
        a.type = t.type,
        a.flags = 0,
        a.subtreeFlags = 0,
        a.deletions = null),
        a.flags = t.flags & 14680064,
        a.childLanes = t.childLanes,
        a.lanes = t.lanes,
        a.child = t.child,
        a.memoizedProps = t.memoizedProps,
        a.memoizedState = t.memoizedState,
        a.updateQueue = t.updateQueue,
        i = t.dependencies,
        a.dependencies = i === null ? null : {
            lanes: i.lanes,
            firstContext: i.firstContext
        },
        a.sibling = t.sibling,
        a.index = t.index,
        a.ref = t.ref,
        a
    }
    function Ho(t, i, a, c, d, h) {
        var w = 2;
        if (c = t,
        typeof t == "function")
            au(t) && (w = 1);
        else if (typeof t == "string")
            w = 5;
        else
            e: switch (t) {
            case F:
                return Dr(a.children, d, h, i);
            case j:
                w = 8,
                d |= 8;
                break;
            case b:
                return t = $n(12, a, i, d | 2),
                t.elementType = b,
                t.lanes = h,
                t;
            case se:
                return t = $n(13, a, i, d),
                t.elementType = se,
                t.lanes = h,
                t;
            case ce:
                return t = $n(19, a, i, d),
                t.elementType = ce,
                t.lanes = h,
                t;
            case de:
                return Vo(a, d, h, i);
            default:
                if (typeof t == "object" && t !== null)
                    switch (t.$$typeof) {
                    case R:
                        w = 10;
                        break e;
                    case I:
                        w = 9;
                        break e;
                    case oe:
                        w = 11;
                        break e;
                    case ne:
                        w = 14;
                        break e;
                    case ae:
                        w = 16,
                        c = null;
                        break e
                    }
                throw Error(n(130, t == null ? t : typeof t, ""))
            }
        return i = $n(w, a, i, d),
        i.elementType = t,
        i.type = c,
        i.lanes = h,
        i
    }
    function Dr(t, i, a, c) {
        return t = $n(7, t, c, i),
        t.lanes = a,
        t
    }
    function Vo(t, i, a, c) {
        return t = $n(22, t, c, i),
        t.elementType = de,
        t.lanes = a,
        t.stateNode = {
            isHidden: !1
        },
        t
    }
    function ou(t, i, a) {
        return t = $n(6, t, null, i),
        t.lanes = a,
        t
    }
    function lu(t, i, a) {
        return i = $n(4, t.children !== null ? t.children : [], t.key, i),
        i.lanes = a,
        i.stateNode = {
            containerInfo: t.containerInfo,
            pendingChildren: null,
            implementation: t.implementation
        },
        i
    }
    function G0(t, i, a, c, d) {
        this.tag = i,
        this.containerInfo = t,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = dn(0),
        this.expirationTimes = dn(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = dn(0),
        this.identifierPrefix = c,
        this.onRecoverableError = d,
        this.mutableSourceEagerHydrationData = null
    }
    function cu(t, i, a, c, d, h, w, D, B) {
        return t = new G0(t,i,a,D,B),
        i === 1 ? (i = 1,
        h === !0 && (i |= 8)) : i = 0,
        h = $n(3, null, null, i),
        t.current = h,
        h.stateNode = t,
        h.memoizedState = {
            element: c,
            isDehydrated: a,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
        },
        wc(h),
        t
    }
    function W0(t, i, a) {
        var c = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: k,
            key: c == null ? null : "" + c,
            children: t,
            containerInfo: i,
            implementation: a
        }
    }
    function yp(t) {
        if (!t)
            return Ki;
        t = t._reactInternals;
        e: {
            if (Ei(t) !== t || t.tag !== 1)
                throw Error(n(170));
            var i = t;
            do {
                switch (i.tag) {
                case 3:
                    i = i.stateNode.context;
                    break e;
                case 1:
                    if (An(i.type)) {
                        i = i.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                i = i.return
            } while (i !== null);
            throw Error(n(171))
        }
        if (t.tag === 1) {
            var a = t.type;
            if (An(a))
                return Jf(t, a, i)
        }
        return i
    }
    function Sp(t, i, a, c, d, h, w, D, B) {
        return t = cu(a, c, !0, t, d, h, w, D, B),
        t.context = yp(null),
        a = t.current,
        c = Mn(),
        d = rr(a),
        h = Li(c, d),
        h.callback = i ?? null,
        er(a, h, d),
        t.current.lanes = d,
        Xt(t, d, c),
        bn(t, c),
        t
    }
    function jo(t, i, a, c) {
        var d = i.current
          , h = Mn()
          , w = rr(d);
        return a = yp(a),
        i.context === null ? i.context = a : i.pendingContext = a,
        i = Li(h, w),
        i.payload = {
            element: t
        },
        c = c === void 0 ? null : c,
        c !== null && (i.callback = c),
        t = er(d, i, w),
        t !== null && (ai(t, d, w, h),
        yo(t, d, w)),
        w
    }
    function Go(t) {
        if (t = t.current,
        !t.child)
            return null;
        switch (t.child.tag) {
        case 5:
            return t.child.stateNode;
        default:
            return t.child.stateNode
        }
    }
    function wp(t, i) {
        if (t = t.memoizedState,
        t !== null && t.dehydrated !== null) {
            var a = t.retryLane;
            t.retryLane = a !== 0 && a < i ? a : i
        }
    }
    function uu(t, i) {
        wp(t, i),
        (t = t.alternate) && wp(t, i)
    }
    function X0() {
        return null
    }
    var Mp = typeof reportError == "function" ? reportError : function(t) {
        console.error(t)
    }
    ;
    function du(t) {
        this._internalRoot = t
    }
    Wo.prototype.render = du.prototype.render = function(t) {
        var i = this._internalRoot;
        if (i === null)
            throw Error(n(409));
        jo(t, i, null, null)
    }
    ,
    Wo.prototype.unmount = du.prototype.unmount = function() {
        var t = this._internalRoot;
        if (t !== null) {
            this._internalRoot = null;
            var i = t.containerInfo;
            Lr(function() {
                jo(null, t, null, null)
            }),
            i[Ti] = null
        }
    }
    ;
    function Wo(t) {
        this._internalRoot = t
    }
    Wo.prototype.unstable_scheduleHydration = function(t) {
        if (t) {
            var i = af();
            t = {
                blockedOn: null,
                target: t,
                priority: i
            };
            for (var a = 0; a < Xi.length && i !== 0 && i < Xi[a].priority; a++)
                ;
            Xi.splice(a, 0, t),
            a === 0 && cf(t)
        }
    }
    ;
    function fu(t) {
        return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
    }
    function Xo(t) {
        return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
    }
    function Ep() {}
    function Y0(t, i, a, c, d) {
        if (d) {
            if (typeof c == "function") {
                var h = c;
                c = function() {
                    var Z = Go(w);
                    h.call(Z)
                }
            }
            var w = Sp(i, c, t, 0, null, !1, !1, "", Ep);
            return t._reactRootContainer = w,
            t[Ti] = w.current,
            sa(t.nodeType === 8 ? t.parentNode : t),
            Lr(),
            w
        }
        for (; d = t.lastChild; )
            t.removeChild(d);
        if (typeof c == "function") {
            var D = c;
            c = function() {
                var Z = Go(B);
                D.call(Z)
            }
        }
        var B = cu(t, 0, !1, null, null, !1, !1, "", Ep);
        return t._reactRootContainer = B,
        t[Ti] = B.current,
        sa(t.nodeType === 8 ? t.parentNode : t),
        Lr(function() {
            jo(i, B, a, c)
        }),
        B
    }
    function Yo(t, i, a, c, d) {
        var h = a._reactRootContainer;
        if (h) {
            var w = h;
            if (typeof d == "function") {
                var D = d;
                d = function() {
                    var B = Go(w);
                    D.call(B)
                }
            }
            jo(i, w, t, d)
        } else
            w = Y0(a, i, t, d, c);
        return Go(w)
    }
    rf = function(t) {
        switch (t.tag) {
        case 3:
            var i = t.stateNode;
            if (i.current.memoizedState.isDehydrated) {
                var a = $t(i.pendingLanes);
                a !== 0 && (Sr(i, a | 1),
                bn(i, W()),
                (wt & 6) === 0 && (vs = W() + 500,
                Qi()))
            }
            break;
        case 13:
            Lr(function() {
                var c = bi(t, 1);
                if (c !== null) {
                    var d = Mn();
                    ai(c, t, 1, d)
                }
            }),
            uu(t, 1)
        }
    }
    ,
    Ol = function(t) {
        if (t.tag === 13) {
            var i = bi(t, 134217728);
            if (i !== null) {
                var a = Mn();
                ai(i, t, 134217728, a)
            }
            uu(t, 134217728)
        }
    }
    ,
    sf = function(t) {
        if (t.tag === 13) {
            var i = rr(t)
              , a = bi(t, i);
            if (a !== null) {
                var c = Mn();
                ai(a, t, i, c)
            }
            uu(t, i)
        }
    }
    ,
    af = function() {
        return pt
    }
    ,
    of = function(t, i) {
        var a = pt;
        try {
            return pt = t,
            i()
        } finally {
            pt = a
        }
    }
    ,
    Se = function(t, i, a) {
        switch (i) {
        case "input":
            if (qe(t, a),
            i = a.name,
            a.type === "radio" && i != null) {
                for (a = t; a.parentNode; )
                    a = a.parentNode;
                for (a = a.querySelectorAll("input[name=" + JSON.stringify("" + i) + '][type="radio"]'),
                i = 0; i < a.length; i++) {
                    var c = a[i];
                    if (c !== t && c.form === t.form) {
                        var d = co(c);
                        if (!d)
                            throw Error(n(90));
                        gt(c),
                        qe(c, d)
                    }
                }
            }
            break;
        case "textarea":
            M(t, a);
            break;
        case "select":
            i = a.value,
            i != null && Ot(t, !!a.multiple, i, !1)
        }
    }
    ,
    ot = iu,
    Ct = Lr;
    var J0 = {
        usingClientEntryPoint: !1,
        Events: [la, ss, co, he, je, iu]
    }
      , wa = {
        findFiberByHostInstance: wr,
        bundleType: 0,
        version: "18.3.1",
        rendererPackageName: "react-dom"
    }
      , q0 = {
        bundleType: wa.bundleType,
        version: wa.version,
        rendererPackageName: wa.rendererPackageName,
        rendererConfig: wa.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: C.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(t) {
            return t = Xa(t),
            t === null ? null : t.stateNode
        },
        findFiberByHostInstance: wa.findFiberByHostInstance || X0,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var Jo = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!Jo.isDisabled && Jo.supportsFiber)
            try {
                $e = Jo.inject(q0),
                st = Jo
            } catch {}
    }
    return Ln.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = J0,
    Ln.createPortal = function(t, i) {
        var a = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!fu(i))
            throw Error(n(200));
        return W0(t, i, null, a)
    }
    ,
    Ln.createRoot = function(t, i) {
        if (!fu(t))
            throw Error(n(299));
        var a = !1
          , c = ""
          , d = Mp;
        return i != null && (i.unstable_strictMode === !0 && (a = !0),
        i.identifierPrefix !== void 0 && (c = i.identifierPrefix),
        i.onRecoverableError !== void 0 && (d = i.onRecoverableError)),
        i = cu(t, 1, !1, null, null, a, !1, c, d),
        t[Ti] = i.current,
        sa(t.nodeType === 8 ? t.parentNode : t),
        new du(i)
    }
    ,
    Ln.findDOMNode = function(t) {
        if (t == null)
            return null;
        if (t.nodeType === 1)
            return t;
        var i = t._reactInternals;
        if (i === void 0)
            throw typeof t.render == "function" ? Error(n(188)) : (t = Object.keys(t).join(","),
            Error(n(268, t)));
        return t = Xa(i),
        t = t === null ? null : t.stateNode,
        t
    }
    ,
    Ln.flushSync = function(t) {
        return Lr(t)
    }
    ,
    Ln.hydrate = function(t, i, a) {
        if (!Xo(i))
            throw Error(n(200));
        return Yo(null, t, i, !0, a)
    }
    ,
    Ln.hydrateRoot = function(t, i, a) {
        if (!fu(t))
            throw Error(n(405));
        var c = a != null && a.hydratedSources || null
          , d = !1
          , h = ""
          , w = Mp;
        if (a != null && (a.unstable_strictMode === !0 && (d = !0),
        a.identifierPrefix !== void 0 && (h = a.identifierPrefix),
        a.onRecoverableError !== void 0 && (w = a.onRecoverableError)),
        i = Sp(i, null, t, 1, a ?? null, d, !1, h, w),
        t[Ti] = i.current,
        sa(t),
        c)
            for (t = 0; t < c.length; t++)
                a = c[t],
                d = a._getVersion,
                d = d(a._source),
                i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [a, d] : i.mutableSourceEagerHydrationData.push(a, d);
        return new Wo(i)
    }
    ,
    Ln.render = function(t, i, a) {
        if (!Xo(i))
            throw Error(n(200));
        return Yo(null, t, i, !1, a)
    }
    ,
    Ln.unmountComponentAtNode = function(t) {
        if (!Xo(t))
            throw Error(n(40));
        return t._reactRootContainer ? (Lr(function() {
            Yo(null, null, t, !1, function() {
                t._reactRootContainer = null,
                t[Ti] = null
            })
        }),
        !0) : !1
    }
    ,
    Ln.unstable_batchedUpdates = iu,
    Ln.unstable_renderSubtreeIntoContainer = function(t, i, a, c) {
        if (!Xo(a))
            throw Error(n(200));
        if (t == null || t._reactInternals === void 0)
            throw Error(n(38));
        return Yo(t, i, a, !1, c)
    }
    ,
    Ln.version = "18.3.1-next-f1338f8080-20240426",
    Ln
}
var Np;
function i_() {
    if (Np)
        return mu.exports;
    Np = 1;
    function s() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s)
            } catch (e) {
                console.error(e)
            }
    }
    return s(),
    mu.exports = n_(),
    mu.exports
}
var Dp;
function r_() {
    if (Dp)
        return qo;
    Dp = 1;
    var s = i_();
    return qo.createRoot = s.createRoot,
    qo.hydrateRoot = s.hydrateRoot,
    qo
}
var s_ = r_();
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Vd = "179"
  , a_ = 0
  , Ip = 1
  , o_ = 2
  , Hm = 1
  , l_ = 2
  , zi = 3
  , _r = 0
  , Nn = 1
  , ki = 2
  , mr = 0
  , Us = 1
  , Up = 2
  , Fp = 3
  , Op = 4
  , c_ = 5
  , Vr = 100
  , u_ = 101
  , d_ = 102
  , f_ = 103
  , h_ = 104
  , p_ = 200
  , m_ = 201
  , g_ = 202
  , __ = 203
  , Qu = 204
  , Zu = 205
  , v_ = 206
  , x_ = 207
  , y_ = 208
  , S_ = 209
  , w_ = 210
  , M_ = 211
  , E_ = 212
  , T_ = 213
  , A_ = 214
  , ed = 0
  , td = 1
  , nd = 2
  , zs = 3
  , id = 4
  , rd = 5
  , sd = 6
  , ad = 7
  , Vm = 0
  , C_ = 1
  , R_ = 2
  , gr = 0
  , b_ = 1
  , L_ = 2
  , P_ = 3
  , N_ = 4
  , D_ = 5
  , I_ = 6
  , U_ = 7
  , jm = 300
  , ks = 301
  , Bs = 302
  , od = 303
  , ld = 304
  , Dl = 306
  , cd = 1e3
  , Gr = 1001
  , ud = 1002
  , hi = 1003
  , F_ = 1004
  , $o = 1005
  , xi = 1006
  , vu = 1007
  , Wr = 1008
  , Si = 1009
  , Gm = 1010
  , Wm = 1011
  , Na = 1012
  , jd = 1013
  , Xr = 1014
  , Bi = 1015
  , Fa = 1016
  , Gd = 1017
  , Wd = 1018
  , Da = 1020
  , Xm = 35902
  , Ym = 1021
  , Jm = 1022
  , di = 1023
  , Ia = 1026
  , Ua = 1027
  , qm = 1028
  , Xd = 1029
  , $m = 1030
  , Yd = 1031
  , Jd = 1033
  , wl = 33776
  , Ml = 33777
  , El = 33778
  , Tl = 33779
  , dd = 35840
  , fd = 35841
  , hd = 35842
  , pd = 35843
  , md = 36196
  , gd = 37492
  , _d = 37496
  , vd = 37808
  , xd = 37809
  , yd = 37810
  , Sd = 37811
  , wd = 37812
  , Md = 37813
  , Ed = 37814
  , Td = 37815
  , Ad = 37816
  , Cd = 37817
  , Rd = 37818
  , bd = 37819
  , Ld = 37820
  , Pd = 37821
  , Al = 36492
  , Nd = 36494
  , Dd = 36495
  , Km = 36283
  , Id = 36284
  , Ud = 36285
  , Fd = 36286
  , O_ = 3200
  , z_ = 3201
  , Qm = 0
  , k_ = 1
  , pr = ""
  , Qn = "srgb"
  , Hs = "srgb-linear"
  , Rl = "linear"
  , Lt = "srgb"
  , ys = 7680
  , zp = 519
  , B_ = 512
  , H_ = 513
  , V_ = 514
  , Zm = 515
  , j_ = 516
  , G_ = 517
  , W_ = 518
  , X_ = 519
  , kp = 35044
  , Bp = "300 es"
  , yi = 2e3
  , bl = 2001;
class js {
    addEventListener(e, n) {
        this._listeners === void 0 && (this._listeners = {});
        const r = this._listeners;
        r[e] === void 0 && (r[e] = []),
        r[e].indexOf(n) === -1 && r[e].push(n)
    }
    hasEventListener(e, n) {
        const r = this._listeners;
        return r === void 0 ? !1 : r[e] !== void 0 && r[e].indexOf(n) !== -1
    }
    removeEventListener(e, n) {
        const r = this._listeners;
        if (r === void 0)
            return;
        const o = r[e];
        if (o !== void 0) {
            const l = o.indexOf(n);
            l !== -1 && o.splice(l, 1)
        }
    }
    dispatchEvent(e) {
        const n = this._listeners;
        if (n === void 0)
            return;
        const r = n[e.type];
        if (r !== void 0) {
            e.target = this;
            const o = r.slice(0);
            for (let l = 0, u = o.length; l < u; l++)
                o[l].call(this, e);
            e.target = null
        }
    }
}
const _n = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]
  , xu = Math.PI / 180
  , Od = 180 / Math.PI;
function Oa() {
    const s = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , n = Math.random() * 4294967295 | 0
      , r = Math.random() * 4294967295 | 0;
    return (_n[s & 255] + _n[s >> 8 & 255] + _n[s >> 16 & 255] + _n[s >> 24 & 255] + "-" + _n[e & 255] + _n[e >> 8 & 255] + "-" + _n[e >> 16 & 15 | 64] + _n[e >> 24 & 255] + "-" + _n[n & 63 | 128] + _n[n >> 8 & 255] + "-" + _n[n >> 16 & 255] + _n[n >> 24 & 255] + _n[r & 255] + _n[r >> 8 & 255] + _n[r >> 16 & 255] + _n[r >> 24 & 255]).toLowerCase()
}
function _t(s, e, n) {
    return Math.max(e, Math.min(n, s))
}
function Y_(s, e) {
    return (s % e + e) % e
}
function yu(s, e, n) {
    return (1 - n) * s + n * e
}
function Ea(s, e) {
    switch (e.constructor) {
    case Float32Array:
        return s;
    case Uint32Array:
        return s / 4294967295;
    case Uint16Array:
        return s / 65535;
    case Uint8Array:
        return s / 255;
    case Int32Array:
        return Math.max(s / 2147483647, -1);
    case Int16Array:
        return Math.max(s / 32767, -1);
    case Int8Array:
        return Math.max(s / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function Pn(s, e) {
    switch (e.constructor) {
    case Float32Array:
        return s;
    case Uint32Array:
        return Math.round(s * 4294967295);
    case Uint16Array:
        return Math.round(s * 65535);
    case Uint8Array:
        return Math.round(s * 255);
    case Int32Array:
        return Math.round(s * 2147483647);
    case Int16Array:
        return Math.round(s * 32767);
    case Int8Array:
        return Math.round(s * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
class vt {
    constructor(e=0, n=0) {
        vt.prototype.isVector2 = !0,
        this.x = e,
        this.y = n
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, n) {
        return this.x = e,
        this.y = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, n) {
        switch (e) {
        case 0:
            this.x = n;
            break;
        case 1:
            this.y = n;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, n) {
        return this.x = e.x + n.x,
        this.y = e.y + n.y,
        this
    }
    addScaledVector(e, n) {
        return this.x += e.x * n,
        this.y += e.y * n,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, n) {
        return this.x = e.x - n.x,
        this.y = e.y - n.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const n = this.x
          , r = this.y
          , o = e.elements;
        return this.x = o[0] * n + o[3] * r + o[6],
        this.y = o[1] * n + o[4] * r + o[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, n) {
        return this.x = _t(this.x, e.x, n.x),
        this.y = _t(this.y, e.y, n.y),
        this
    }
    clampScalar(e, n) {
        return this.x = _t(this.x, e, n),
        this.y = _t(this.y, e, n),
        this
    }
    clampLength(e, n) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(_t(r, e, n))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const n = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (n === 0)
            return Math.PI / 2;
        const r = this.dot(e) / n;
        return Math.acos(_t(r, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const n = this.x - e.x
          , r = this.y - e.y;
        return n * n + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, n) {
        return this.x += (e.x - this.x) * n,
        this.y += (e.y - this.y) * n,
        this
    }
    lerpVectors(e, n, r) {
        return this.x = e.x + (n.x - e.x) * r,
        this.y = e.y + (n.y - e.y) * r,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, n=0) {
        return this.x = e[n],
        this.y = e[n + 1],
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this.x,
        e[n + 1] = this.y,
        e
    }
    fromBufferAttribute(e, n) {
        return this.x = e.getX(n),
        this.y = e.getY(n),
        this
    }
    rotateAround(e, n) {
        const r = Math.cos(n)
          , o = Math.sin(n)
          , l = this.x - e.x
          , u = this.y - e.y;
        return this.x = l * r - u * o + e.x,
        this.y = l * o + u * r + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class za {
    constructor(e=0, n=0, r=0, o=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = n,
        this._z = r,
        this._w = o
    }
    static slerpFlat(e, n, r, o, l, u, f) {
        let m = r[o + 0]
          , p = r[o + 1]
          , v = r[o + 2]
          , _ = r[o + 3];
        const x = l[u + 0]
          , S = l[u + 1]
          , E = l[u + 2]
          , T = l[u + 3];
        if (f === 0) {
            e[n + 0] = m,
            e[n + 1] = p,
            e[n + 2] = v,
            e[n + 3] = _;
            return
        }
        if (f === 1) {
            e[n + 0] = x,
            e[n + 1] = S,
            e[n + 2] = E,
            e[n + 3] = T;
            return
        }
        if (_ !== T || m !== x || p !== S || v !== E) {
            let y = 1 - f;
            const g = m * x + p * S + v * E + _ * T
              , N = g >= 0 ? 1 : -1
              , L = 1 - g * g;
            if (L > Number.EPSILON) {
                const H = Math.sqrt(L)
                  , k = Math.atan2(H, g * N);
                y = Math.sin(y * k) / H,
                f = Math.sin(f * k) / H
            }
            const C = f * N;
            if (m = m * y + x * C,
            p = p * y + S * C,
            v = v * y + E * C,
            _ = _ * y + T * C,
            y === 1 - f) {
                const H = 1 / Math.sqrt(m * m + p * p + v * v + _ * _);
                m *= H,
                p *= H,
                v *= H,
                _ *= H
            }
        }
        e[n] = m,
        e[n + 1] = p,
        e[n + 2] = v,
        e[n + 3] = _
    }
    static multiplyQuaternionsFlat(e, n, r, o, l, u) {
        const f = r[o]
          , m = r[o + 1]
          , p = r[o + 2]
          , v = r[o + 3]
          , _ = l[u]
          , x = l[u + 1]
          , S = l[u + 2]
          , E = l[u + 3];
        return e[n] = f * E + v * _ + m * S - p * x,
        e[n + 1] = m * E + v * x + p * _ - f * S,
        e[n + 2] = p * E + v * S + f * x - m * _,
        e[n + 3] = v * E - f * _ - m * x - p * S,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, n, r, o) {
        return this._x = e,
        this._y = n,
        this._z = r,
        this._w = o,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, n=!0) {
        const r = e._x
          , o = e._y
          , l = e._z
          , u = e._order
          , f = Math.cos
          , m = Math.sin
          , p = f(r / 2)
          , v = f(o / 2)
          , _ = f(l / 2)
          , x = m(r / 2)
          , S = m(o / 2)
          , E = m(l / 2);
        switch (u) {
        case "XYZ":
            this._x = x * v * _ + p * S * E,
            this._y = p * S * _ - x * v * E,
            this._z = p * v * E + x * S * _,
            this._w = p * v * _ - x * S * E;
            break;
        case "YXZ":
            this._x = x * v * _ + p * S * E,
            this._y = p * S * _ - x * v * E,
            this._z = p * v * E - x * S * _,
            this._w = p * v * _ + x * S * E;
            break;
        case "ZXY":
            this._x = x * v * _ - p * S * E,
            this._y = p * S * _ + x * v * E,
            this._z = p * v * E + x * S * _,
            this._w = p * v * _ - x * S * E;
            break;
        case "ZYX":
            this._x = x * v * _ - p * S * E,
            this._y = p * S * _ + x * v * E,
            this._z = p * v * E - x * S * _,
            this._w = p * v * _ + x * S * E;
            break;
        case "YZX":
            this._x = x * v * _ + p * S * E,
            this._y = p * S * _ + x * v * E,
            this._z = p * v * E - x * S * _,
            this._w = p * v * _ - x * S * E;
            break;
        case "XZY":
            this._x = x * v * _ - p * S * E,
            this._y = p * S * _ - x * v * E,
            this._z = p * v * E + x * S * _,
            this._w = p * v * _ + x * S * E;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + u)
        }
        return n === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, n) {
        const r = n / 2
          , o = Math.sin(r);
        return this._x = e.x * o,
        this._y = e.y * o,
        this._z = e.z * o,
        this._w = Math.cos(r),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const n = e.elements
          , r = n[0]
          , o = n[4]
          , l = n[8]
          , u = n[1]
          , f = n[5]
          , m = n[9]
          , p = n[2]
          , v = n[6]
          , _ = n[10]
          , x = r + f + _;
        if (x > 0) {
            const S = .5 / Math.sqrt(x + 1);
            this._w = .25 / S,
            this._x = (v - m) * S,
            this._y = (l - p) * S,
            this._z = (u - o) * S
        } else if (r > f && r > _) {
            const S = 2 * Math.sqrt(1 + r - f - _);
            this._w = (v - m) / S,
            this._x = .25 * S,
            this._y = (o + u) / S,
            this._z = (l + p) / S
        } else if (f > _) {
            const S = 2 * Math.sqrt(1 + f - r - _);
            this._w = (l - p) / S,
            this._x = (o + u) / S,
            this._y = .25 * S,
            this._z = (m + v) / S
        } else {
            const S = 2 * Math.sqrt(1 + _ - r - f);
            this._w = (u - o) / S,
            this._x = (l + p) / S,
            this._y = (m + v) / S,
            this._z = .25 * S
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, n) {
        let r = e.dot(n) + 1;
        return r < 1e-8 ? (r = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = r) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = r)) : (this._x = e.y * n.z - e.z * n.y,
        this._y = e.z * n.x - e.x * n.z,
        this._z = e.x * n.y - e.y * n.x,
        this._w = r),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(_t(this.dot(e), -1, 1)))
    }
    rotateTowards(e, n) {
        const r = this.angleTo(e);
        if (r === 0)
            return this;
        const o = Math.min(1, n / r);
        return this.slerp(e, o),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, n) {
        const r = e._x
          , o = e._y
          , l = e._z
          , u = e._w
          , f = n._x
          , m = n._y
          , p = n._z
          , v = n._w;
        return this._x = r * v + u * f + o * p - l * m,
        this._y = o * v + u * m + l * f - r * p,
        this._z = l * v + u * p + r * m - o * f,
        this._w = u * v - r * f - o * m - l * p,
        this._onChangeCallback(),
        this
    }
    slerp(e, n) {
        if (n === 0)
            return this;
        if (n === 1)
            return this.copy(e);
        const r = this._x
          , o = this._y
          , l = this._z
          , u = this._w;
        let f = u * e._w + r * e._x + o * e._y + l * e._z;
        if (f < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        f = -f) : this.copy(e),
        f >= 1)
            return this._w = u,
            this._x = r,
            this._y = o,
            this._z = l,
            this;
        const m = 1 - f * f;
        if (m <= Number.EPSILON) {
            const S = 1 - n;
            return this._w = S * u + n * this._w,
            this._x = S * r + n * this._x,
            this._y = S * o + n * this._y,
            this._z = S * l + n * this._z,
            this.normalize(),
            this
        }
        const p = Math.sqrt(m)
          , v = Math.atan2(p, f)
          , _ = Math.sin((1 - n) * v) / p
          , x = Math.sin(n * v) / p;
        return this._w = u * _ + this._w * x,
        this._x = r * _ + this._x * x,
        this._y = o * _ + this._y * x,
        this._z = l * _ + this._z * x,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, n, r) {
        return this.copy(e).slerp(n, r)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , n = 2 * Math.PI * Math.random()
          , r = Math.random()
          , o = Math.sqrt(1 - r)
          , l = Math.sqrt(r);
        return this.set(o * Math.sin(e), o * Math.cos(e), l * Math.sin(n), l * Math.cos(n))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, n=0) {
        return this._x = e[n],
        this._y = e[n + 1],
        this._z = e[n + 2],
        this._w = e[n + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this._x,
        e[n + 1] = this._y,
        e[n + 2] = this._z,
        e[n + 3] = this._w,
        e
    }
    fromBufferAttribute(e, n) {
        return this._x = e.getX(n),
        this._y = e.getY(n),
        this._z = e.getZ(n),
        this._w = e.getW(n),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class J {
    constructor(e=0, n=0, r=0) {
        J.prototype.isVector3 = !0,
        this.x = e,
        this.y = n,
        this.z = r
    }
    set(e, n, r) {
        return r === void 0 && (r = this.z),
        this.x = e,
        this.y = n,
        this.z = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, n) {
        switch (e) {
        case 0:
            this.x = n;
            break;
        case 1:
            this.y = n;
            break;
        case 2:
            this.z = n;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, n) {
        return this.x = e.x + n.x,
        this.y = e.y + n.y,
        this.z = e.z + n.z,
        this
    }
    addScaledVector(e, n) {
        return this.x += e.x * n,
        this.y += e.y * n,
        this.z += e.z * n,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, n) {
        return this.x = e.x - n.x,
        this.y = e.y - n.y,
        this.z = e.z - n.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, n) {
        return this.x = e.x * n.x,
        this.y = e.y * n.y,
        this.z = e.z * n.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(Hp.setFromEuler(e))
    }
    applyAxisAngle(e, n) {
        return this.applyQuaternion(Hp.setFromAxisAngle(e, n))
    }
    applyMatrix3(e) {
        const n = this.x
          , r = this.y
          , o = this.z
          , l = e.elements;
        return this.x = l[0] * n + l[3] * r + l[6] * o,
        this.y = l[1] * n + l[4] * r + l[7] * o,
        this.z = l[2] * n + l[5] * r + l[8] * o,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const n = this.x
          , r = this.y
          , o = this.z
          , l = e.elements
          , u = 1 / (l[3] * n + l[7] * r + l[11] * o + l[15]);
        return this.x = (l[0] * n + l[4] * r + l[8] * o + l[12]) * u,
        this.y = (l[1] * n + l[5] * r + l[9] * o + l[13]) * u,
        this.z = (l[2] * n + l[6] * r + l[10] * o + l[14]) * u,
        this
    }
    applyQuaternion(e) {
        const n = this.x
          , r = this.y
          , o = this.z
          , l = e.x
          , u = e.y
          , f = e.z
          , m = e.w
          , p = 2 * (u * o - f * r)
          , v = 2 * (f * n - l * o)
          , _ = 2 * (l * r - u * n);
        return this.x = n + m * p + u * _ - f * v,
        this.y = r + m * v + f * p - l * _,
        this.z = o + m * _ + l * v - u * p,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const n = this.x
          , r = this.y
          , o = this.z
          , l = e.elements;
        return this.x = l[0] * n + l[4] * r + l[8] * o,
        this.y = l[1] * n + l[5] * r + l[9] * o,
        this.z = l[2] * n + l[6] * r + l[10] * o,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, n) {
        return this.x = _t(this.x, e.x, n.x),
        this.y = _t(this.y, e.y, n.y),
        this.z = _t(this.z, e.z, n.z),
        this
    }
    clampScalar(e, n) {
        return this.x = _t(this.x, e, n),
        this.y = _t(this.y, e, n),
        this.z = _t(this.z, e, n),
        this
    }
    clampLength(e, n) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(_t(r, e, n))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, n) {
        return this.x += (e.x - this.x) * n,
        this.y += (e.y - this.y) * n,
        this.z += (e.z - this.z) * n,
        this
    }
    lerpVectors(e, n, r) {
        return this.x = e.x + (n.x - e.x) * r,
        this.y = e.y + (n.y - e.y) * r,
        this.z = e.z + (n.z - e.z) * r,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, n) {
        const r = e.x
          , o = e.y
          , l = e.z
          , u = n.x
          , f = n.y
          , m = n.z;
        return this.x = o * m - l * f,
        this.y = l * u - r * m,
        this.z = r * f - o * u,
        this
    }
    projectOnVector(e) {
        const n = e.lengthSq();
        if (n === 0)
            return this.set(0, 0, 0);
        const r = e.dot(this) / n;
        return this.copy(e).multiplyScalar(r)
    }
    projectOnPlane(e) {
        return Su.copy(this).projectOnVector(e),
        this.sub(Su)
    }
    reflect(e) {
        return this.sub(Su.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const n = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (n === 0)
            return Math.PI / 2;
        const r = this.dot(e) / n;
        return Math.acos(_t(r, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const n = this.x - e.x
          , r = this.y - e.y
          , o = this.z - e.z;
        return n * n + r * r + o * o
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, n, r) {
        const o = Math.sin(n) * e;
        return this.x = o * Math.sin(r),
        this.y = Math.cos(n) * e,
        this.z = o * Math.cos(r),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, n, r) {
        return this.x = e * Math.sin(n),
        this.y = r,
        this.z = e * Math.cos(n),
        this
    }
    setFromMatrixPosition(e) {
        const n = e.elements;
        return this.x = n[12],
        this.y = n[13],
        this.z = n[14],
        this
    }
    setFromMatrixScale(e) {
        const n = this.setFromMatrixColumn(e, 0).length()
          , r = this.setFromMatrixColumn(e, 1).length()
          , o = this.setFromMatrixColumn(e, 2).length();
        return this.x = n,
        this.y = r,
        this.z = o,
        this
    }
    setFromMatrixColumn(e, n) {
        return this.fromArray(e.elements, n * 4)
    }
    setFromMatrix3Column(e, n) {
        return this.fromArray(e.elements, n * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, n=0) {
        return this.x = e[n],
        this.y = e[n + 1],
        this.z = e[n + 2],
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this.x,
        e[n + 1] = this.y,
        e[n + 2] = this.z,
        e
    }
    fromBufferAttribute(e, n) {
        return this.x = e.getX(n),
        this.y = e.getY(n),
        this.z = e.getZ(n),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , n = Math.random() * 2 - 1
          , r = Math.sqrt(1 - n * n);
        return this.x = r * Math.cos(e),
        this.y = n,
        this.z = r * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const Su = new J
  , Hp = new za;
class ut {
    constructor(e, n, r, o, l, u, f, m, p) {
        ut.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, n, r, o, l, u, f, m, p)
    }
    set(e, n, r, o, l, u, f, m, p) {
        const v = this.elements;
        return v[0] = e,
        v[1] = o,
        v[2] = f,
        v[3] = n,
        v[4] = l,
        v[5] = m,
        v[6] = r,
        v[7] = u,
        v[8] = p,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const n = this.elements
          , r = e.elements;
        return n[0] = r[0],
        n[1] = r[1],
        n[2] = r[2],
        n[3] = r[3],
        n[4] = r[4],
        n[5] = r[5],
        n[6] = r[6],
        n[7] = r[7],
        n[8] = r[8],
        this
    }
    extractBasis(e, n, r) {
        return e.setFromMatrix3Column(this, 0),
        n.setFromMatrix3Column(this, 1),
        r.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const n = e.elements;
        return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, n) {
        const r = e.elements
          , o = n.elements
          , l = this.elements
          , u = r[0]
          , f = r[3]
          , m = r[6]
          , p = r[1]
          , v = r[4]
          , _ = r[7]
          , x = r[2]
          , S = r[5]
          , E = r[8]
          , T = o[0]
          , y = o[3]
          , g = o[6]
          , N = o[1]
          , L = o[4]
          , C = o[7]
          , H = o[2]
          , k = o[5]
          , F = o[8];
        return l[0] = u * T + f * N + m * H,
        l[3] = u * y + f * L + m * k,
        l[6] = u * g + f * C + m * F,
        l[1] = p * T + v * N + _ * H,
        l[4] = p * y + v * L + _ * k,
        l[7] = p * g + v * C + _ * F,
        l[2] = x * T + S * N + E * H,
        l[5] = x * y + S * L + E * k,
        l[8] = x * g + S * C + E * F,
        this
    }
    multiplyScalar(e) {
        const n = this.elements;
        return n[0] *= e,
        n[3] *= e,
        n[6] *= e,
        n[1] *= e,
        n[4] *= e,
        n[7] *= e,
        n[2] *= e,
        n[5] *= e,
        n[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , n = e[0]
          , r = e[1]
          , o = e[2]
          , l = e[3]
          , u = e[4]
          , f = e[5]
          , m = e[6]
          , p = e[7]
          , v = e[8];
        return n * u * v - n * f * p - r * l * v + r * f * m + o * l * p - o * u * m
    }
    invert() {
        const e = this.elements
          , n = e[0]
          , r = e[1]
          , o = e[2]
          , l = e[3]
          , u = e[4]
          , f = e[5]
          , m = e[6]
          , p = e[7]
          , v = e[8]
          , _ = v * u - f * p
          , x = f * m - v * l
          , S = p * l - u * m
          , E = n * _ + r * x + o * S;
        if (E === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const T = 1 / E;
        return e[0] = _ * T,
        e[1] = (o * p - v * r) * T,
        e[2] = (f * r - o * u) * T,
        e[3] = x * T,
        e[4] = (v * n - o * m) * T,
        e[5] = (o * l - f * n) * T,
        e[6] = S * T,
        e[7] = (r * m - p * n) * T,
        e[8] = (u * n - r * l) * T,
        this
    }
    transpose() {
        let e;
        const n = this.elements;
        return e = n[1],
        n[1] = n[3],
        n[3] = e,
        e = n[2],
        n[2] = n[6],
        n[6] = e,
        e = n[5],
        n[5] = n[7],
        n[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const n = this.elements;
        return e[0] = n[0],
        e[1] = n[3],
        e[2] = n[6],
        e[3] = n[1],
        e[4] = n[4],
        e[5] = n[7],
        e[6] = n[2],
        e[7] = n[5],
        e[8] = n[8],
        this
    }
    setUvTransform(e, n, r, o, l, u, f) {
        const m = Math.cos(l)
          , p = Math.sin(l);
        return this.set(r * m, r * p, -r * (m * u + p * f) + u + e, -o * p, o * m, -o * (-p * u + m * f) + f + n, 0, 0, 1),
        this
    }
    scale(e, n) {
        return this.premultiply(wu.makeScale(e, n)),
        this
    }
    rotate(e) {
        return this.premultiply(wu.makeRotation(-e)),
        this
    }
    translate(e, n) {
        return this.premultiply(wu.makeTranslation(e, n)),
        this
    }
    makeTranslation(e, n) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, n, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const n = Math.cos(e)
          , r = Math.sin(e);
        return this.set(n, -r, 0, r, n, 0, 0, 0, 1),
        this
    }
    makeScale(e, n) {
        return this.set(e, 0, 0, 0, n, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const n = this.elements
          , r = e.elements;
        for (let o = 0; o < 9; o++)
            if (n[o] !== r[o])
                return !1;
        return !0
    }
    fromArray(e, n=0) {
        for (let r = 0; r < 9; r++)
            this.elements[r] = e[r + n];
        return this
    }
    toArray(e=[], n=0) {
        const r = this.elements;
        return e[n] = r[0],
        e[n + 1] = r[1],
        e[n + 2] = r[2],
        e[n + 3] = r[3],
        e[n + 4] = r[4],
        e[n + 5] = r[5],
        e[n + 6] = r[6],
        e[n + 7] = r[7],
        e[n + 8] = r[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const wu = new ut;
function eg(s) {
    for (let e = s.length - 1; e >= 0; --e)
        if (s[e] >= 65535)
            return !0;
    return !1
}
function Ll(s) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", s)
}
function J_() {
    const s = Ll("canvas");
    return s.style.display = "block",
    s
}
const Vp = {};
function Fs(s) {
    s in Vp || (Vp[s] = !0,
    console.warn(s))
}
function q_(s, e, n) {
    return new Promise(function(r, o) {
        function l() {
            switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case s.WAIT_FAILED:
                o();
                break;
            case s.TIMEOUT_EXPIRED:
                setTimeout(l, n);
                break;
            default:
                r()
            }
        }
        setTimeout(l, n)
    }
    )
}
const jp = new ut().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
  , Gp = new ut().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
function $_() {
    const s = {
        enabled: !0,
        workingColorSpace: Hs,
        spaces: {},
        convert: function(o, l, u) {
            return this.enabled === !1 || l === u || !l || !u || (this.spaces[l].transfer === Lt && (o.r = Hi(o.r),
            o.g = Hi(o.g),
            o.b = Hi(o.b)),
            this.spaces[l].primaries !== this.spaces[u].primaries && (o.applyMatrix3(this.spaces[l].toXYZ),
            o.applyMatrix3(this.spaces[u].fromXYZ)),
            this.spaces[u].transfer === Lt && (o.r = Os(o.r),
            o.g = Os(o.g),
            o.b = Os(o.b))),
            o
        },
        workingToColorSpace: function(o, l) {
            return this.convert(o, this.workingColorSpace, l)
        },
        colorSpaceToWorking: function(o, l) {
            return this.convert(o, l, this.workingColorSpace)
        },
        getPrimaries: function(o) {
            return this.spaces[o].primaries
        },
        getTransfer: function(o) {
            return o === pr ? Rl : this.spaces[o].transfer
        },
        getLuminanceCoefficients: function(o, l=this.workingColorSpace) {
            return o.fromArray(this.spaces[l].luminanceCoefficients)
        },
        define: function(o) {
            Object.assign(this.spaces, o)
        },
        _getMatrix: function(o, l, u) {
            return o.copy(this.spaces[l].toXYZ).multiply(this.spaces[u].fromXYZ)
        },
        _getDrawingBufferColorSpace: function(o) {
            return this.spaces[o].outputColorSpaceConfig.drawingBufferColorSpace
        },
        _getUnpackColorSpace: function(o=this.workingColorSpace) {
            return this.spaces[o].workingColorSpaceConfig.unpackColorSpace
        },
        fromWorkingColorSpace: function(o, l) {
            return Fs("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),
            s.workingToColorSpace(o, l)
        },
        toWorkingColorSpace: function(o, l) {
            return Fs("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),
            s.colorSpaceToWorking(o, l)
        }
    }
      , e = [.64, .33, .3, .6, .15, .06]
      , n = [.2126, .7152, .0722]
      , r = [.3127, .329];
    return s.define({
        [Hs]: {
            primaries: e,
            whitePoint: r,
            transfer: Rl,
            toXYZ: jp,
            fromXYZ: Gp,
            luminanceCoefficients: n,
            workingColorSpaceConfig: {
                unpackColorSpace: Qn
            },
            outputColorSpaceConfig: {
                drawingBufferColorSpace: Qn
            }
        },
        [Qn]: {
            primaries: e,
            whitePoint: r,
            transfer: Lt,
            toXYZ: jp,
            fromXYZ: Gp,
            luminanceCoefficients: n,
            outputColorSpaceConfig: {
                drawingBufferColorSpace: Qn
            }
        }
    }),
    s
}
const Et = $_();
function Hi(s) {
    return s < .04045 ? s * .0773993808 : Math.pow(s * .9478672986 + .0521327014, 2.4)
}
function Os(s) {
    return s < .0031308 ? s * 12.92 : 1.055 * Math.pow(s, .41666) - .055
}
let Ss;
class K_ {
    static getDataURL(e, n="image/png") {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let r;
        if (e instanceof HTMLCanvasElement)
            r = e;
        else {
            Ss === void 0 && (Ss = Ll("canvas")),
            Ss.width = e.width,
            Ss.height = e.height;
            const o = Ss.getContext("2d");
            e instanceof ImageData ? o.putImageData(e, 0, 0) : o.drawImage(e, 0, 0, e.width, e.height),
            r = Ss
        }
        return r.toDataURL(n)
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const n = Ll("canvas");
            n.width = e.width,
            n.height = e.height;
            const r = n.getContext("2d");
            r.drawImage(e, 0, 0, e.width, e.height);
            const o = r.getImageData(0, 0, e.width, e.height)
              , l = o.data;
            for (let u = 0; u < l.length; u++)
                l[u] = Hi(l[u] / 255) * 255;
            return r.putImageData(o, 0, 0),
            n
        } else if (e.data) {
            const n = e.data.slice(0);
            for (let r = 0; r < n.length; r++)
                n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[r] = Math.floor(Hi(n[r] / 255) * 255) : n[r] = Hi(n[r]);
            return {
                data: n,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let Q_ = 0;
class qd {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: Q_++
        }),
        this.uuid = Oa(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    getSize(e) {
        const n = this.data;
        return n instanceof HTMLVideoElement ? e.set(n.videoWidth, n.videoHeight, 0) : n instanceof VideoFrame ? e.set(n.displayHeight, n.displayWidth, 0) : n !== null ? e.set(n.width, n.height, n.depth || 0) : e.set(0, 0, 0),
        e
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string";
        if (!n && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const r = {
            uuid: this.uuid,
            url: ""
        }
          , o = this.data;
        if (o !== null) {
            let l;
            if (Array.isArray(o)) {
                l = [];
                for (let u = 0, f = o.length; u < f; u++)
                    o[u].isDataTexture ? l.push(Mu(o[u].image)) : l.push(Mu(o[u]))
            } else
                l = Mu(o);
            r.url = l
        }
        return n || (e.images[this.uuid] = r),
        r
    }
}
function Mu(s) {
    return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? K_.getDataURL(s) : s.data ? {
        data: Array.from(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let Z_ = 0;
const Eu = new J;
class Dn extends js {
    constructor(e=Dn.DEFAULT_IMAGE, n=Dn.DEFAULT_MAPPING, r=Gr, o=Gr, l=xi, u=Wr, f=di, m=Si, p=Dn.DEFAULT_ANISOTROPY, v=pr) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: Z_++
        }),
        this.uuid = Oa(),
        this.name = "",
        this.source = new qd(e),
        this.mipmaps = [],
        this.mapping = n,
        this.channel = 0,
        this.wrapS = r,
        this.wrapT = o,
        this.magFilter = l,
        this.minFilter = u,
        this.anisotropy = p,
        this.format = f,
        this.internalFormat = null,
        this.type = m,
        this.offset = new vt(0,0),
        this.repeat = new vt(1,1),
        this.center = new vt(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new ut,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = v,
        this.userData = {},
        this.updateRanges = [],
        this.version = 0,
        this.onUpdate = null,
        this.renderTarget = null,
        this.isRenderTargetTexture = !1,
        this.isArrayTexture = !!(e && e.depth && e.depth > 1),
        this.pmremVersion = 0
    }
    get width() {
        return this.source.getSize(Eu).x
    }
    get height() {
        return this.source.getSize(Eu).y
    }
    get depth() {
        return this.source.getSize(Eu).z
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    addUpdateRange(e, n) {
        this.updateRanges.push({
            start: e,
            count: n
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.renderTarget = e.renderTarget,
        this.isRenderTargetTexture = e.isRenderTargetTexture,
        this.isArrayTexture = e.isArrayTexture,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    setValues(e) {
        for (const n in e) {
            const r = e[n];
            if (r === void 0) {
                console.warn(`THREE.Texture.setValues(): parameter '${n}' has value of undefined.`);
                continue
            }
            const o = this[n];
            if (o === void 0) {
                console.warn(`THREE.Texture.setValues(): property '${n}' does not exist.`);
                continue
            }
            o && r && o.isVector2 && r.isVector2 || o && r && o.isVector3 && r.isVector3 || o && r && o.isMatrix3 && r.isMatrix3 ? o.copy(r) : this[n] = r
        }
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string";
        if (!n && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const r = {
            metadata: {
                version: 4.7,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        n || (e.textures[this.uuid] = r),
        r
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== jm)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case cd:
                e.x = e.x - Math.floor(e.x);
                break;
            case Gr:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case ud:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case cd:
                e.y = e.y - Math.floor(e.y);
                break;
            case Gr:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case ud:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
Dn.DEFAULT_IMAGE = null;
Dn.DEFAULT_MAPPING = jm;
Dn.DEFAULT_ANISOTROPY = 1;
class Pt {
    constructor(e=0, n=0, r=0, o=1) {
        Pt.prototype.isVector4 = !0,
        this.x = e,
        this.y = n,
        this.z = r,
        this.w = o
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, n, r, o) {
        return this.x = e,
        this.y = n,
        this.z = r,
        this.w = o,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, n) {
        switch (e) {
        case 0:
            this.x = n;
            break;
        case 1:
            this.y = n;
            break;
        case 2:
            this.z = n;
            break;
        case 3:
            this.w = n;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, n) {
        return this.x = e.x + n.x,
        this.y = e.y + n.y,
        this.z = e.z + n.z,
        this.w = e.w + n.w,
        this
    }
    addScaledVector(e, n) {
        return this.x += e.x * n,
        this.y += e.y * n,
        this.z += e.z * n,
        this.w += e.w * n,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, n) {
        return this.x = e.x - n.x,
        this.y = e.y - n.y,
        this.z = e.z - n.z,
        this.w = e.w - n.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const n = this.x
          , r = this.y
          , o = this.z
          , l = this.w
          , u = e.elements;
        return this.x = u[0] * n + u[4] * r + u[8] * o + u[12] * l,
        this.y = u[1] * n + u[5] * r + u[9] * o + u[13] * l,
        this.z = u[2] * n + u[6] * r + u[10] * o + u[14] * l,
        this.w = u[3] * n + u[7] * r + u[11] * o + u[15] * l,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this.w /= e.w,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const n = Math.sqrt(1 - e.w * e.w);
        return n < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / n,
        this.y = e.y / n,
        this.z = e.z / n),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let n, r, o, l;
        const m = e.elements
          , p = m[0]
          , v = m[4]
          , _ = m[8]
          , x = m[1]
          , S = m[5]
          , E = m[9]
          , T = m[2]
          , y = m[6]
          , g = m[10];
        if (Math.abs(v - x) < .01 && Math.abs(_ - T) < .01 && Math.abs(E - y) < .01) {
            if (Math.abs(v + x) < .1 && Math.abs(_ + T) < .1 && Math.abs(E + y) < .1 && Math.abs(p + S + g - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            n = Math.PI;
            const L = (p + 1) / 2
              , C = (S + 1) / 2
              , H = (g + 1) / 2
              , k = (v + x) / 4
              , F = (_ + T) / 4
              , j = (E + y) / 4;
            return L > C && L > H ? L < .01 ? (r = 0,
            o = .707106781,
            l = .707106781) : (r = Math.sqrt(L),
            o = k / r,
            l = F / r) : C > H ? C < .01 ? (r = .707106781,
            o = 0,
            l = .707106781) : (o = Math.sqrt(C),
            r = k / o,
            l = j / o) : H < .01 ? (r = .707106781,
            o = .707106781,
            l = 0) : (l = Math.sqrt(H),
            r = F / l,
            o = j / l),
            this.set(r, o, l, n),
            this
        }
        let N = Math.sqrt((y - E) * (y - E) + (_ - T) * (_ - T) + (x - v) * (x - v));
        return Math.abs(N) < .001 && (N = 1),
        this.x = (y - E) / N,
        this.y = (_ - T) / N,
        this.z = (x - v) / N,
        this.w = Math.acos((p + S + g - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const n = e.elements;
        return this.x = n[12],
        this.y = n[13],
        this.z = n[14],
        this.w = n[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, n) {
        return this.x = _t(this.x, e.x, n.x),
        this.y = _t(this.y, e.y, n.y),
        this.z = _t(this.z, e.z, n.z),
        this.w = _t(this.w, e.w, n.w),
        this
    }
    clampScalar(e, n) {
        return this.x = _t(this.x, e, n),
        this.y = _t(this.y, e, n),
        this.z = _t(this.z, e, n),
        this.w = _t(this.w, e, n),
        this
    }
    clampLength(e, n) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(_t(r, e, n))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, n) {
        return this.x += (e.x - this.x) * n,
        this.y += (e.y - this.y) * n,
        this.z += (e.z - this.z) * n,
        this.w += (e.w - this.w) * n,
        this
    }
    lerpVectors(e, n, r) {
        return this.x = e.x + (n.x - e.x) * r,
        this.y = e.y + (n.y - e.y) * r,
        this.z = e.z + (n.z - e.z) * r,
        this.w = e.w + (n.w - e.w) * r,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, n=0) {
        return this.x = e[n],
        this.y = e[n + 1],
        this.z = e[n + 2],
        this.w = e[n + 3],
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this.x,
        e[n + 1] = this.y,
        e[n + 2] = this.z,
        e[n + 3] = this.w,
        e
    }
    fromBufferAttribute(e, n) {
        return this.x = e.getX(n),
        this.y = e.getY(n),
        this.z = e.getZ(n),
        this.w = e.getW(n),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class ev extends js {
    constructor(e=1, n=1, r={}) {
        super(),
        r = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: xi,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1,
            depth: 1,
            multiview: !1
        }, r),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = n,
        this.depth = r.depth,
        this.scissor = new Pt(0,0,e,n),
        this.scissorTest = !1,
        this.viewport = new Pt(0,0,e,n);
        const o = {
            width: e,
            height: n,
            depth: r.depth
        }
          , l = new Dn(o);
        this.textures = [];
        const u = r.count;
        for (let f = 0; f < u; f++)
            this.textures[f] = l.clone(),
            this.textures[f].isRenderTargetTexture = !0,
            this.textures[f].renderTarget = this;
        this._setTextureOptions(r),
        this.depthBuffer = r.depthBuffer,
        this.stencilBuffer = r.stencilBuffer,
        this.resolveDepthBuffer = r.resolveDepthBuffer,
        this.resolveStencilBuffer = r.resolveStencilBuffer,
        this._depthTexture = null,
        this.depthTexture = r.depthTexture,
        this.samples = r.samples,
        this.multiview = r.multiview
    }
    _setTextureOptions(e={}) {
        const n = {
            minFilter: xi,
            generateMipmaps: !1,
            flipY: !1,
            internalFormat: null
        };
        e.mapping !== void 0 && (n.mapping = e.mapping),
        e.wrapS !== void 0 && (n.wrapS = e.wrapS),
        e.wrapT !== void 0 && (n.wrapT = e.wrapT),
        e.wrapR !== void 0 && (n.wrapR = e.wrapR),
        e.magFilter !== void 0 && (n.magFilter = e.magFilter),
        e.minFilter !== void 0 && (n.minFilter = e.minFilter),
        e.format !== void 0 && (n.format = e.format),
        e.type !== void 0 && (n.type = e.type),
        e.anisotropy !== void 0 && (n.anisotropy = e.anisotropy),
        e.colorSpace !== void 0 && (n.colorSpace = e.colorSpace),
        e.flipY !== void 0 && (n.flipY = e.flipY),
        e.generateMipmaps !== void 0 && (n.generateMipmaps = e.generateMipmaps),
        e.internalFormat !== void 0 && (n.internalFormat = e.internalFormat);
        for (let r = 0; r < this.textures.length; r++)
            this.textures[r].setValues(n)
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    set depthTexture(e) {
        this._depthTexture !== null && (this._depthTexture.renderTarget = null),
        e !== null && (e.renderTarget = this),
        this._depthTexture = e
    }
    get depthTexture() {
        return this._depthTexture
    }
    setSize(e, n, r=1) {
        if (this.width !== e || this.height !== n || this.depth !== r) {
            this.width = e,
            this.height = n,
            this.depth = r;
            for (let o = 0, l = this.textures.length; o < l; o++)
                this.textures[o].image.width = e,
                this.textures[o].image.height = n,
                this.textures[o].image.depth = r,
                this.textures[o].isArrayTexture = this.textures[o].image.depth > 1;
            this.dispose()
        }
        this.viewport.set(0, 0, e, n),
        this.scissor.set(0, 0, e, n)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let n = 0, r = e.textures.length; n < r; n++) {
            this.textures[n] = e.textures[n].clone(),
            this.textures[n].isRenderTargetTexture = !0,
            this.textures[n].renderTarget = this;
            const o = Object.assign({}, e.textures[n].image);
            this.textures[n].source = new qd(o)
        }
        return this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Yr extends ev {
    constructor(e=1, n=1, r={}) {
        super(e, n, r),
        this.isWebGLRenderTarget = !0
    }
}
class tg extends Dn {
    constructor(e=null, n=1, r=1, o=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: n,
            height: r,
            depth: o
        },
        this.magFilter = hi,
        this.minFilter = hi,
        this.wrapR = Gr,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class tv extends Dn {
    constructor(e=null, n=1, r=1, o=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: n,
            height: r,
            depth: o
        },
        this.magFilter = hi,
        this.minFilter = hi,
        this.wrapR = Gr,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class ka {
    constructor(e=new J(1 / 0,1 / 0,1 / 0), n=new J(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = n
    }
    set(e, n) {
        return this.min.copy(e),
        this.max.copy(n),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let n = 0, r = e.length; n < r; n += 3)
            this.expandByPoint(oi.fromArray(e, n));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let n = 0, r = e.count; n < r; n++)
            this.expandByPoint(oi.fromBufferAttribute(e, n));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let n = 0, r = e.length; n < r; n++)
            this.expandByPoint(e[n]);
        return this
    }
    setFromCenterAndSize(e, n) {
        const r = oi.copy(n).multiplyScalar(.5);
        return this.min.copy(e).sub(r),
        this.max.copy(e).add(r),
        this
    }
    setFromObject(e, n=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, n)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, n=!1) {
        e.updateWorldMatrix(!1, !1);
        const r = e.geometry;
        if (r !== void 0) {
            const l = r.getAttribute("position");
            if (n === !0 && l !== void 0 && e.isInstancedMesh !== !0)
                for (let u = 0, f = l.count; u < f; u++)
                    e.isMesh === !0 ? e.getVertexPosition(u, oi) : oi.fromBufferAttribute(l, u),
                    oi.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(oi);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                Ko.copy(e.boundingBox)) : (r.boundingBox === null && r.computeBoundingBox(),
                Ko.copy(r.boundingBox)),
                Ko.applyMatrix4(e.matrixWorld),
                this.union(Ko)
        }
        const o = e.children;
        for (let l = 0, u = o.length; l < u; l++)
            this.expandByObject(o[l], n);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, n) {
        return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, oi),
        oi.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let n, r;
        return e.normal.x > 0 ? (n = e.normal.x * this.min.x,
        r = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x,
        r = e.normal.x * this.min.x),
        e.normal.y > 0 ? (n += e.normal.y * this.min.y,
        r += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y,
        r += e.normal.y * this.min.y),
        e.normal.z > 0 ? (n += e.normal.z * this.min.z,
        r += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z,
        r += e.normal.z * this.min.z),
        n <= -e.constant && r >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Ta),
        Qo.subVectors(this.max, Ta),
        ws.subVectors(e.a, Ta),
        Ms.subVectors(e.b, Ta),
        Es.subVectors(e.c, Ta),
        lr.subVectors(Ms, ws),
        cr.subVectors(Es, Ms),
        Ir.subVectors(ws, Es);
        let n = [0, -lr.z, lr.y, 0, -cr.z, cr.y, 0, -Ir.z, Ir.y, lr.z, 0, -lr.x, cr.z, 0, -cr.x, Ir.z, 0, -Ir.x, -lr.y, lr.x, 0, -cr.y, cr.x, 0, -Ir.y, Ir.x, 0];
        return !Tu(n, ws, Ms, Es, Qo) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !Tu(n, ws, Ms, Es, Qo)) ? !1 : (Zo.crossVectors(lr, cr),
        n = [Zo.x, Zo.y, Zo.z],
        Tu(n, ws, Ms, Es, Qo))
    }
    clampPoint(e, n) {
        return n.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, oi).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(oi).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Di[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Di[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Di[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Di[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Di[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Di[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Di[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Di[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Di),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
    toJSON() {
        return {
            min: this.min.toArray(),
            max: this.max.toArray()
        }
    }
    fromJSON(e) {
        return this.min.fromArray(e.min),
        this.max.fromArray(e.max),
        this
    }
}
const Di = [new J, new J, new J, new J, new J, new J, new J, new J]
  , oi = new J
  , Ko = new ka
  , ws = new J
  , Ms = new J
  , Es = new J
  , lr = new J
  , cr = new J
  , Ir = new J
  , Ta = new J
  , Qo = new J
  , Zo = new J
  , Ur = new J;
function Tu(s, e, n, r, o) {
    for (let l = 0, u = s.length - 3; l <= u; l += 3) {
        Ur.fromArray(s, l);
        const f = o.x * Math.abs(Ur.x) + o.y * Math.abs(Ur.y) + o.z * Math.abs(Ur.z)
          , m = e.dot(Ur)
          , p = n.dot(Ur)
          , v = r.dot(Ur);
        if (Math.max(-Math.max(m, p, v), Math.min(m, p, v)) > f)
            return !1
    }
    return !0
}
const nv = new ka
  , Aa = new J
  , Au = new J;
class Ba {
    constructor(e=new J, n=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = n
    }
    set(e, n) {
        return this.center.copy(e),
        this.radius = n,
        this
    }
    setFromPoints(e, n) {
        const r = this.center;
        n !== void 0 ? r.copy(n) : nv.setFromPoints(e).getCenter(r);
        let o = 0;
        for (let l = 0, u = e.length; l < u; l++)
            o = Math.max(o, r.distanceToSquared(e[l]));
        return this.radius = Math.sqrt(o),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const n = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= n * n
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, n) {
        const r = this.center.distanceToSquared(e);
        return n.copy(e),
        r > this.radius * this.radius && (n.sub(this.center).normalize(),
        n.multiplyScalar(this.radius).add(this.center)),
        n
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Aa.subVectors(e, this.center);
        const n = Aa.lengthSq();
        if (n > this.radius * this.radius) {
            const r = Math.sqrt(n)
              , o = (r - this.radius) * .5;
            this.center.addScaledVector(Aa, o / r),
            this.radius += o
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Au.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Aa.copy(e.center).add(Au)),
        this.expandByPoint(Aa.copy(e.center).sub(Au))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        return {
            radius: this.radius,
            center: this.center.toArray()
        }
    }
    fromJSON(e) {
        return this.radius = e.radius,
        this.center.fromArray(e.center),
        this
    }
}
const Ii = new J
  , Cu = new J
  , el = new J
  , ur = new J
  , Ru = new J
  , tl = new J
  , bu = new J;
class $d {
    constructor(e=new J, n=new J(0,0,-1)) {
        this.origin = e,
        this.direction = n
    }
    set(e, n) {
        return this.origin.copy(e),
        this.direction.copy(n),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, n) {
        return n.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, Ii)),
        this
    }
    closestPointToPoint(e, n) {
        n.subVectors(e, this.origin);
        const r = n.dot(this.direction);
        return r < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, r)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const n = Ii.subVectors(e, this.origin).dot(this.direction);
        return n < 0 ? this.origin.distanceToSquared(e) : (Ii.copy(this.origin).addScaledVector(this.direction, n),
        Ii.distanceToSquared(e))
    }
    distanceSqToSegment(e, n, r, o) {
        Cu.copy(e).add(n).multiplyScalar(.5),
        el.copy(n).sub(e).normalize(),
        ur.copy(this.origin).sub(Cu);
        const l = e.distanceTo(n) * .5
          , u = -this.direction.dot(el)
          , f = ur.dot(this.direction)
          , m = -ur.dot(el)
          , p = ur.lengthSq()
          , v = Math.abs(1 - u * u);
        let _, x, S, E;
        if (v > 0)
            if (_ = u * m - f,
            x = u * f - m,
            E = l * v,
            _ >= 0)
                if (x >= -E)
                    if (x <= E) {
                        const T = 1 / v;
                        _ *= T,
                        x *= T,
                        S = _ * (_ + u * x + 2 * f) + x * (u * _ + x + 2 * m) + p
                    } else
                        x = l,
                        _ = Math.max(0, -(u * x + f)),
                        S = -_ * _ + x * (x + 2 * m) + p;
                else
                    x = -l,
                    _ = Math.max(0, -(u * x + f)),
                    S = -_ * _ + x * (x + 2 * m) + p;
            else
                x <= -E ? (_ = Math.max(0, -(-u * l + f)),
                x = _ > 0 ? -l : Math.min(Math.max(-l, -m), l),
                S = -_ * _ + x * (x + 2 * m) + p) : x <= E ? (_ = 0,
                x = Math.min(Math.max(-l, -m), l),
                S = x * (x + 2 * m) + p) : (_ = Math.max(0, -(u * l + f)),
                x = _ > 0 ? l : Math.min(Math.max(-l, -m), l),
                S = -_ * _ + x * (x + 2 * m) + p);
        else
            x = u > 0 ? -l : l,
            _ = Math.max(0, -(u * x + f)),
            S = -_ * _ + x * (x + 2 * m) + p;
        return r && r.copy(this.origin).addScaledVector(this.direction, _),
        o && o.copy(Cu).addScaledVector(el, x),
        S
    }
    intersectSphere(e, n) {
        Ii.subVectors(e.center, this.origin);
        const r = Ii.dot(this.direction)
          , o = Ii.dot(Ii) - r * r
          , l = e.radius * e.radius;
        if (o > l)
            return null;
        const u = Math.sqrt(l - o)
          , f = r - u
          , m = r + u;
        return m < 0 ? null : f < 0 ? this.at(m, n) : this.at(f, n)
    }
    intersectsSphere(e) {
        return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const n = e.normal.dot(this.direction);
        if (n === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const r = -(this.origin.dot(e.normal) + e.constant) / n;
        return r >= 0 ? r : null
    }
    intersectPlane(e, n) {
        const r = this.distanceToPlane(e);
        return r === null ? null : this.at(r, n)
    }
    intersectsPlane(e) {
        const n = e.distanceToPoint(this.origin);
        return n === 0 || e.normal.dot(this.direction) * n < 0
    }
    intersectBox(e, n) {
        let r, o, l, u, f, m;
        const p = 1 / this.direction.x
          , v = 1 / this.direction.y
          , _ = 1 / this.direction.z
          , x = this.origin;
        return p >= 0 ? (r = (e.min.x - x.x) * p,
        o = (e.max.x - x.x) * p) : (r = (e.max.x - x.x) * p,
        o = (e.min.x - x.x) * p),
        v >= 0 ? (l = (e.min.y - x.y) * v,
        u = (e.max.y - x.y) * v) : (l = (e.max.y - x.y) * v,
        u = (e.min.y - x.y) * v),
        r > u || l > o || ((l > r || isNaN(r)) && (r = l),
        (u < o || isNaN(o)) && (o = u),
        _ >= 0 ? (f = (e.min.z - x.z) * _,
        m = (e.max.z - x.z) * _) : (f = (e.max.z - x.z) * _,
        m = (e.min.z - x.z) * _),
        r > m || f > o) || ((f > r || r !== r) && (r = f),
        (m < o || o !== o) && (o = m),
        o < 0) ? null : this.at(r >= 0 ? r : o, n)
    }
    intersectsBox(e) {
        return this.intersectBox(e, Ii) !== null
    }
    intersectTriangle(e, n, r, o, l) {
        Ru.subVectors(n, e),
        tl.subVectors(r, e),
        bu.crossVectors(Ru, tl);
        let u = this.direction.dot(bu), f;
        if (u > 0) {
            if (o)
                return null;
            f = 1
        } else if (u < 0)
            f = -1,
            u = -u;
        else
            return null;
        ur.subVectors(this.origin, e);
        const m = f * this.direction.dot(tl.crossVectors(ur, tl));
        if (m < 0)
            return null;
        const p = f * this.direction.dot(Ru.cross(ur));
        if (p < 0 || m + p > u)
            return null;
        const v = -f * ur.dot(bu);
        return v < 0 ? null : this.at(v / u, l)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Vt {
    constructor(e, n, r, o, l, u, f, m, p, v, _, x, S, E, T, y) {
        Vt.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, n, r, o, l, u, f, m, p, v, _, x, S, E, T, y)
    }
    set(e, n, r, o, l, u, f, m, p, v, _, x, S, E, T, y) {
        const g = this.elements;
        return g[0] = e,
        g[4] = n,
        g[8] = r,
        g[12] = o,
        g[1] = l,
        g[5] = u,
        g[9] = f,
        g[13] = m,
        g[2] = p,
        g[6] = v,
        g[10] = _,
        g[14] = x,
        g[3] = S,
        g[7] = E,
        g[11] = T,
        g[15] = y,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Vt().fromArray(this.elements)
    }
    copy(e) {
        const n = this.elements
          , r = e.elements;
        return n[0] = r[0],
        n[1] = r[1],
        n[2] = r[2],
        n[3] = r[3],
        n[4] = r[4],
        n[5] = r[5],
        n[6] = r[6],
        n[7] = r[7],
        n[8] = r[8],
        n[9] = r[9],
        n[10] = r[10],
        n[11] = r[11],
        n[12] = r[12],
        n[13] = r[13],
        n[14] = r[14],
        n[15] = r[15],
        this
    }
    copyPosition(e) {
        const n = this.elements
          , r = e.elements;
        return n[12] = r[12],
        n[13] = r[13],
        n[14] = r[14],
        this
    }
    setFromMatrix3(e) {
        const n = e.elements;
        return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, n, r) {
        return e.setFromMatrixColumn(this, 0),
        n.setFromMatrixColumn(this, 1),
        r.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, n, r) {
        return this.set(e.x, n.x, r.x, 0, e.y, n.y, r.y, 0, e.z, n.z, r.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const n = this.elements
          , r = e.elements
          , o = 1 / Ts.setFromMatrixColumn(e, 0).length()
          , l = 1 / Ts.setFromMatrixColumn(e, 1).length()
          , u = 1 / Ts.setFromMatrixColumn(e, 2).length();
        return n[0] = r[0] * o,
        n[1] = r[1] * o,
        n[2] = r[2] * o,
        n[3] = 0,
        n[4] = r[4] * l,
        n[5] = r[5] * l,
        n[6] = r[6] * l,
        n[7] = 0,
        n[8] = r[8] * u,
        n[9] = r[9] * u,
        n[10] = r[10] * u,
        n[11] = 0,
        n[12] = 0,
        n[13] = 0,
        n[14] = 0,
        n[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const n = this.elements
          , r = e.x
          , o = e.y
          , l = e.z
          , u = Math.cos(r)
          , f = Math.sin(r)
          , m = Math.cos(o)
          , p = Math.sin(o)
          , v = Math.cos(l)
          , _ = Math.sin(l);
        if (e.order === "XYZ") {
            const x = u * v
              , S = u * _
              , E = f * v
              , T = f * _;
            n[0] = m * v,
            n[4] = -m * _,
            n[8] = p,
            n[1] = S + E * p,
            n[5] = x - T * p,
            n[9] = -f * m,
            n[2] = T - x * p,
            n[6] = E + S * p,
            n[10] = u * m
        } else if (e.order === "YXZ") {
            const x = m * v
              , S = m * _
              , E = p * v
              , T = p * _;
            n[0] = x + T * f,
            n[4] = E * f - S,
            n[8] = u * p,
            n[1] = u * _,
            n[5] = u * v,
            n[9] = -f,
            n[2] = S * f - E,
            n[6] = T + x * f,
            n[10] = u * m
        } else if (e.order === "ZXY") {
            const x = m * v
              , S = m * _
              , E = p * v
              , T = p * _;
            n[0] = x - T * f,
            n[4] = -u * _,
            n[8] = E + S * f,
            n[1] = S + E * f,
            n[5] = u * v,
            n[9] = T - x * f,
            n[2] = -u * p,
            n[6] = f,
            n[10] = u * m
        } else if (e.order === "ZYX") {
            const x = u * v
              , S = u * _
              , E = f * v
              , T = f * _;
            n[0] = m * v,
            n[4] = E * p - S,
            n[8] = x * p + T,
            n[1] = m * _,
            n[5] = T * p + x,
            n[9] = S * p - E,
            n[2] = -p,
            n[6] = f * m,
            n[10] = u * m
        } else if (e.order === "YZX") {
            const x = u * m
              , S = u * p
              , E = f * m
              , T = f * p;
            n[0] = m * v,
            n[4] = T - x * _,
            n[8] = E * _ + S,
            n[1] = _,
            n[5] = u * v,
            n[9] = -f * v,
            n[2] = -p * v,
            n[6] = S * _ + E,
            n[10] = x - T * _
        } else if (e.order === "XZY") {
            const x = u * m
              , S = u * p
              , E = f * m
              , T = f * p;
            n[0] = m * v,
            n[4] = -_,
            n[8] = p * v,
            n[1] = x * _ + T,
            n[5] = u * v,
            n[9] = S * _ - E,
            n[2] = E * _ - S,
            n[6] = f * v,
            n[10] = T * _ + x
        }
        return n[3] = 0,
        n[7] = 0,
        n[11] = 0,
        n[12] = 0,
        n[13] = 0,
        n[14] = 0,
        n[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(iv, e, rv)
    }
    lookAt(e, n, r) {
        const o = this.elements;
        return Hn.subVectors(e, n),
        Hn.lengthSq() === 0 && (Hn.z = 1),
        Hn.normalize(),
        dr.crossVectors(r, Hn),
        dr.lengthSq() === 0 && (Math.abs(r.z) === 1 ? Hn.x += 1e-4 : Hn.z += 1e-4,
        Hn.normalize(),
        dr.crossVectors(r, Hn)),
        dr.normalize(),
        nl.crossVectors(Hn, dr),
        o[0] = dr.x,
        o[4] = nl.x,
        o[8] = Hn.x,
        o[1] = dr.y,
        o[5] = nl.y,
        o[9] = Hn.y,
        o[2] = dr.z,
        o[6] = nl.z,
        o[10] = Hn.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, n) {
        const r = e.elements
          , o = n.elements
          , l = this.elements
          , u = r[0]
          , f = r[4]
          , m = r[8]
          , p = r[12]
          , v = r[1]
          , _ = r[5]
          , x = r[9]
          , S = r[13]
          , E = r[2]
          , T = r[6]
          , y = r[10]
          , g = r[14]
          , N = r[3]
          , L = r[7]
          , C = r[11]
          , H = r[15]
          , k = o[0]
          , F = o[4]
          , j = o[8]
          , b = o[12]
          , R = o[1]
          , I = o[5]
          , oe = o[9]
          , se = o[13]
          , ce = o[2]
          , ne = o[6]
          , ae = o[10]
          , de = o[14]
          , V = o[3]
          , ue = o[7]
          , re = o[11]
          , U = o[15];
        return l[0] = u * k + f * R + m * ce + p * V,
        l[4] = u * F + f * I + m * ne + p * ue,
        l[8] = u * j + f * oe + m * ae + p * re,
        l[12] = u * b + f * se + m * de + p * U,
        l[1] = v * k + _ * R + x * ce + S * V,
        l[5] = v * F + _ * I + x * ne + S * ue,
        l[9] = v * j + _ * oe + x * ae + S * re,
        l[13] = v * b + _ * se + x * de + S * U,
        l[2] = E * k + T * R + y * ce + g * V,
        l[6] = E * F + T * I + y * ne + g * ue,
        l[10] = E * j + T * oe + y * ae + g * re,
        l[14] = E * b + T * se + y * de + g * U,
        l[3] = N * k + L * R + C * ce + H * V,
        l[7] = N * F + L * I + C * ne + H * ue,
        l[11] = N * j + L * oe + C * ae + H * re,
        l[15] = N * b + L * se + C * de + H * U,
        this
    }
    multiplyScalar(e) {
        const n = this.elements;
        return n[0] *= e,
        n[4] *= e,
        n[8] *= e,
        n[12] *= e,
        n[1] *= e,
        n[5] *= e,
        n[9] *= e,
        n[13] *= e,
        n[2] *= e,
        n[6] *= e,
        n[10] *= e,
        n[14] *= e,
        n[3] *= e,
        n[7] *= e,
        n[11] *= e,
        n[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , n = e[0]
          , r = e[4]
          , o = e[8]
          , l = e[12]
          , u = e[1]
          , f = e[5]
          , m = e[9]
          , p = e[13]
          , v = e[2]
          , _ = e[6]
          , x = e[10]
          , S = e[14]
          , E = e[3]
          , T = e[7]
          , y = e[11]
          , g = e[15];
        return E * (+l * m * _ - o * p * _ - l * f * x + r * p * x + o * f * S - r * m * S) + T * (+n * m * S - n * p * x + l * u * x - o * u * S + o * p * v - l * m * v) + y * (+n * p * _ - n * f * S - l * u * _ + r * u * S + l * f * v - r * p * v) + g * (-o * f * v - n * m * _ + n * f * x + o * u * _ - r * u * x + r * m * v)
    }
    transpose() {
        const e = this.elements;
        let n;
        return n = e[1],
        e[1] = e[4],
        e[4] = n,
        n = e[2],
        e[2] = e[8],
        e[8] = n,
        n = e[6],
        e[6] = e[9],
        e[9] = n,
        n = e[3],
        e[3] = e[12],
        e[12] = n,
        n = e[7],
        e[7] = e[13],
        e[13] = n,
        n = e[11],
        e[11] = e[14],
        e[14] = n,
        this
    }
    setPosition(e, n, r) {
        const o = this.elements;
        return e.isVector3 ? (o[12] = e.x,
        o[13] = e.y,
        o[14] = e.z) : (o[12] = e,
        o[13] = n,
        o[14] = r),
        this
    }
    invert() {
        const e = this.elements
          , n = e[0]
          , r = e[1]
          , o = e[2]
          , l = e[3]
          , u = e[4]
          , f = e[5]
          , m = e[6]
          , p = e[7]
          , v = e[8]
          , _ = e[9]
          , x = e[10]
          , S = e[11]
          , E = e[12]
          , T = e[13]
          , y = e[14]
          , g = e[15]
          , N = _ * y * p - T * x * p + T * m * S - f * y * S - _ * m * g + f * x * g
          , L = E * x * p - v * y * p - E * m * S + u * y * S + v * m * g - u * x * g
          , C = v * T * p - E * _ * p + E * f * S - u * T * S - v * f * g + u * _ * g
          , H = E * _ * m - v * T * m - E * f * x + u * T * x + v * f * y - u * _ * y
          , k = n * N + r * L + o * C + l * H;
        if (k === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const F = 1 / k;
        return e[0] = N * F,
        e[1] = (T * x * l - _ * y * l - T * o * S + r * y * S + _ * o * g - r * x * g) * F,
        e[2] = (f * y * l - T * m * l + T * o * p - r * y * p - f * o * g + r * m * g) * F,
        e[3] = (_ * m * l - f * x * l - _ * o * p + r * x * p + f * o * S - r * m * S) * F,
        e[4] = L * F,
        e[5] = (v * y * l - E * x * l + E * o * S - n * y * S - v * o * g + n * x * g) * F,
        e[6] = (E * m * l - u * y * l - E * o * p + n * y * p + u * o * g - n * m * g) * F,
        e[7] = (u * x * l - v * m * l + v * o * p - n * x * p - u * o * S + n * m * S) * F,
        e[8] = C * F,
        e[9] = (E * _ * l - v * T * l - E * r * S + n * T * S + v * r * g - n * _ * g) * F,
        e[10] = (u * T * l - E * f * l + E * r * p - n * T * p - u * r * g + n * f * g) * F,
        e[11] = (v * f * l - u * _ * l - v * r * p + n * _ * p + u * r * S - n * f * S) * F,
        e[12] = H * F,
        e[13] = (v * T * o - E * _ * o + E * r * x - n * T * x - v * r * y + n * _ * y) * F,
        e[14] = (E * f * o - u * T * o - E * r * m + n * T * m + u * r * y - n * f * y) * F,
        e[15] = (u * _ * o - v * f * o + v * r * m - n * _ * m - u * r * x + n * f * x) * F,
        this
    }
    scale(e) {
        const n = this.elements
          , r = e.x
          , o = e.y
          , l = e.z;
        return n[0] *= r,
        n[4] *= o,
        n[8] *= l,
        n[1] *= r,
        n[5] *= o,
        n[9] *= l,
        n[2] *= r,
        n[6] *= o,
        n[10] *= l,
        n[3] *= r,
        n[7] *= o,
        n[11] *= l,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , o = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(n, r, o))
    }
    makeTranslation(e, n, r) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, r, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const n = Math.cos(e)
          , r = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const n = Math.cos(e)
          , r = Math.sin(e);
        return this.set(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const n = Math.cos(e)
          , r = Math.sin(e);
        return this.set(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, n) {
        const r = Math.cos(n)
          , o = Math.sin(n)
          , l = 1 - r
          , u = e.x
          , f = e.y
          , m = e.z
          , p = l * u
          , v = l * f;
        return this.set(p * u + r, p * f - o * m, p * m + o * f, 0, p * f + o * m, v * f + r, v * m - o * u, 0, p * m - o * f, v * m + o * u, l * m * m + r, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, n, r) {
        return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, r, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, n, r, o, l, u) {
        return this.set(1, r, l, 0, e, 1, u, 0, n, o, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, n, r) {
        const o = this.elements
          , l = n._x
          , u = n._y
          , f = n._z
          , m = n._w
          , p = l + l
          , v = u + u
          , _ = f + f
          , x = l * p
          , S = l * v
          , E = l * _
          , T = u * v
          , y = u * _
          , g = f * _
          , N = m * p
          , L = m * v
          , C = m * _
          , H = r.x
          , k = r.y
          , F = r.z;
        return o[0] = (1 - (T + g)) * H,
        o[1] = (S + C) * H,
        o[2] = (E - L) * H,
        o[3] = 0,
        o[4] = (S - C) * k,
        o[5] = (1 - (x + g)) * k,
        o[6] = (y + N) * k,
        o[7] = 0,
        o[8] = (E + L) * F,
        o[9] = (y - N) * F,
        o[10] = (1 - (x + T)) * F,
        o[11] = 0,
        o[12] = e.x,
        o[13] = e.y,
        o[14] = e.z,
        o[15] = 1,
        this
    }
    decompose(e, n, r) {
        const o = this.elements;
        let l = Ts.set(o[0], o[1], o[2]).length();
        const u = Ts.set(o[4], o[5], o[6]).length()
          , f = Ts.set(o[8], o[9], o[10]).length();
        this.determinant() < 0 && (l = -l),
        e.x = o[12],
        e.y = o[13],
        e.z = o[14],
        li.copy(this);
        const p = 1 / l
          , v = 1 / u
          , _ = 1 / f;
        return li.elements[0] *= p,
        li.elements[1] *= p,
        li.elements[2] *= p,
        li.elements[4] *= v,
        li.elements[5] *= v,
        li.elements[6] *= v,
        li.elements[8] *= _,
        li.elements[9] *= _,
        li.elements[10] *= _,
        n.setFromRotationMatrix(li),
        r.x = l,
        r.y = u,
        r.z = f,
        this
    }
    makePerspective(e, n, r, o, l, u, f=yi, m=!1) {
        const p = this.elements
          , v = 2 * l / (n - e)
          , _ = 2 * l / (r - o)
          , x = (n + e) / (n - e)
          , S = (r + o) / (r - o);
        let E, T;
        if (m)
            E = l / (u - l),
            T = u * l / (u - l);
        else if (f === yi)
            E = -(u + l) / (u - l),
            T = -2 * u * l / (u - l);
        else if (f === bl)
            E = -u / (u - l),
            T = -u * l / (u - l);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + f);
        return p[0] = v,
        p[4] = 0,
        p[8] = x,
        p[12] = 0,
        p[1] = 0,
        p[5] = _,
        p[9] = S,
        p[13] = 0,
        p[2] = 0,
        p[6] = 0,
        p[10] = E,
        p[14] = T,
        p[3] = 0,
        p[7] = 0,
        p[11] = -1,
        p[15] = 0,
        this
    }
        makeOrthographic(e, n, r, o, l, u, f=yi, m=!1) {
        const p = this.elements
          , v = 2 / (n - e)
          , _ = 2 / (r - o)
          , x = -(n + e) / (n - e)
          , S = -(r + o) / (r - o);
        let E, T;
        if (m)
            E = 1 / (u - l),
            T = u / (u - l);
        else if (f === yi)
            E = -2 / (u - l),
            T = -(u + l) / (u - l);
        else if (f === bl)
            E = -1 / (u - l),
            T = -l / (u - l);
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + f);
        return p[0] = v,
        p[4] = 0,
        p[8] = 0,
        p[12] = x,
        p[1] = 0,
        p[5] = _,
        p[9] = 0,
        p[13] = S,
        p[2] = 0,
        p[6] = 0,
        p[10] = E,
        p[14] = T,
        p[3] = 0,
        p[7] = 0,
        p[11] = 0,
        p[15] = 1,
        this
    }
    equals(e) {
        const n = this.elements
          , r = e.elements;
        for (let o = 0; o < 16; o++)
            if (n[o] !== r[o])
                return !1;
        return !0
    }
    fromArray(e, n=0) {
        for (let r = 0; r < 16; r++)
            this.elements[r] = e[r + n];
        return this
    }
    toArray(e=[], n=0) {
        const r = this.elements;
        return e[n] = r[0],
        e[n + 1] = r[1],
        e[n + 2] = r[2],
        e[n + 3] = r[3],
        e[n + 4] = r[4],
        e[n + 5] = r[5],
        e[n + 6] = r[6],
        e[n + 7] = r[7],
        e[n + 8] = r[8],
        e[n + 9] = r[9],
        e[n + 10] = r[10],
        e[n + 11] = r[11],
        e[n + 12] = r[12],
        e[n + 13] = r[13],
        e[n + 14] = r[14],
        e[n + 15] = r[15],
        e
    }
}
const Ts = new J
  , li = new Vt
  , iv = new J(0,0,0)
  , rv = new J(1,1,1)
  , dr = new J
  , nl = new J
  , Hn = new J
  , Wp = new Vt
  , Xp = new za;
class wi {
    constructor(e=0, n=0, r=0, o=wi.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = n,
        this._z = r,
        this._order = o
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, n, r, o=this._order) {
        return this._x = e,
        this._y = n,
        this._z = r,
        this._order = o,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, n=this._order, r=!0) {
        const o = e.elements
          , l = o[0]
          , u = o[4]
          , f = o[8]
          , m = o[1]
          , p = o[5]
          , v = o[9]
          , _ = o[2]
          , x = o[6]
          , S = o[10];
        switch (n) {
        case "XYZ":
            this._y = Math.asin(_t(f, -1, 1)),
            Math.abs(f) < .9999999 ? (this._x = Math.atan2(-v, S),
            this._z = Math.atan2(-u, l)) : (this._x = Math.atan2(x, p),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-_t(v, -1, 1)),
            Math.abs(v) < .9999999 ? (this._y = Math.atan2(f, S),
            this._z = Math.atan2(m, p)) : (this._y = Math.atan2(-_, l),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(_t(x, -1, 1)),
            Math.abs(x) < .9999999 ? (this._y = Math.atan2(-_, S),
            this._z = Math.atan2(-u, p)) : (this._y = 0,
            this._z = Math.atan2(m, l));
            break;
        case "ZYX":
            this._y = Math.asin(-_t(_, -1, 1)),
            Math.abs(_) < .9999999 ? (this._x = Math.atan2(x, S),
            this._z = Math.atan2(m, l)) : (this._x = 0,
            this._z = Math.atan2(-u, p));
            break;
        case "YZX":
            this._z = Math.asin(_t(m, -1, 1)),
            Math.abs(m) < .9999999 ? (this._x = Math.atan2(-v, p),
            this._y = Math.atan2(-_, l)) : (this._x = 0,
            this._y = Math.atan2(f, S));
            break;
        case "XZY":
            this._z = Math.asin(-_t(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(x, p),
            this._y = Math.atan2(f, l)) : (this._x = Math.atan2(-v, S),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n)
        }
        return this._order = n,
        r === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, n, r) {
        return Wp.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(Wp, n, r)
    }
    setFromVector3(e, n=this._order) {
        return this.set(e.x, e.y, e.z, n)
    }
    reorder(e) {
        return Xp.setFromEuler(this),
        this.setFromQuaternion(Xp, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this._x,
        e[n + 1] = this._y,
        e[n + 2] = this._z,
        e[n + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
wi.DEFAULT_ORDER = "XYZ";
class ng {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let sv = 0;
const Yp = new J
  , As = new za
  , Ui = new Vt
  , il = new J
  , Ca = new J
  , av = new J
  , ov = new za
  , Jp = new J(1,0,0)
  , qp = new J(0,1,0)
  , $p = new J(0,0,1)
  , Kp = {
    type: "added"
}
  , lv = {
    type: "removed"
}
  , Cs = {
    type: "childadded",
    child: null
}
  , Lu = {
    type: "childremoved",
    child: null
};
class xn extends js {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: sv++
        }),
        this.uuid = Oa(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = xn.DEFAULT_UP.clone();
        const e = new J
          , n = new wi
          , r = new za
          , o = new J(1,1,1);
        function l() {
            r.setFromEuler(n, !1)
        }
        function u() {
            n.setFromQuaternion(r, void 0, !1)
        }
        n._onChange(l),
        r._onChange(u),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: o
            },
            modelViewMatrix: {
                value: new Vt
            },
            normalMatrix: {
                value: new ut
            }
        }),
        this.matrix = new Vt,
        this.matrixWorld = new Vt,
        this.matrixAutoUpdate = xn.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = xn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new ng,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.customDepthMaterial = void 0,
        this.customDistanceMaterial = void 0,
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, n) {
        this.quaternion.setFromAxisAngle(e, n)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, n) {
        return As.setFromAxisAngle(e, n),
        this.quaternion.multiply(As),
        this
    }
    rotateOnWorldAxis(e, n) {
        return As.setFromAxisAngle(e, n),
        this.quaternion.premultiply(As),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(Jp, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(qp, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis($p, e)
    }
    translateOnAxis(e, n) {
        return Yp.copy(e).applyQuaternion(this.quaternion),
        this.position.add(Yp.multiplyScalar(n)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(Jp, e)
    }
    translateY(e) {
        return this.translateOnAxis(qp, e)
    }
    translateZ(e) {
        return this.translateOnAxis($p, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Ui.copy(this.matrixWorld).invert())
    }
    lookAt(e, n, r) {
        e.isVector3 ? il.copy(e) : il.set(e, n, r);
        const o = this.parent;
        this.updateWorldMatrix(!0, !1),
        Ca.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Ui.lookAt(Ca, il, this.up) : Ui.lookAt(il, Ca, this.up),
        this.quaternion.setFromRotationMatrix(Ui),
        o && (Ui.extractRotation(o.matrixWorld),
        As.setFromRotationMatrix(Ui),
        this.quaternion.premultiply(As.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.add(arguments[n]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(Kp),
        Cs.child = e,
        this.dispatchEvent(Cs),
        Cs.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let r = 0; r < arguments.length; r++)
                this.remove(arguments[r]);
            return this
        }
        const n = this.children.indexOf(e);
        return n !== -1 && (e.parent = null,
        this.children.splice(n, 1),
        e.dispatchEvent(lv),
        Lu.child = e,
        this.dispatchEvent(Lu),
        Lu.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        Ui.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        Ui.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Ui),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(Kp),
        Cs.child = e,
        this.dispatchEvent(Cs),
        Cs.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, n) {
        if (this[e] === n)
            return this;
        for (let r = 0, o = this.children.length; r < o; r++) {
            const u = this.children[r].getObjectByProperty(e, n);
            if (u !== void 0)
                return u
        }
    }
    getObjectsByProperty(e, n, r=[]) {
        this[e] === n && r.push(this);
        const o = this.children;
        for (let l = 0, u = o.length; l < u; l++)
            o[l].getObjectsByProperty(e, n, r);
        return r
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Ca, e, av),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Ca, ov, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const n = this.matrixWorld.elements;
        return e.set(n[8], n[9], n[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const n = this.children;
        for (let r = 0, o = n.length; r < o; r++)
            n[r].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const n = this.children;
        for (let r = 0, o = n.length; r < o; r++)
            n[r].traverseVisible(e)
    }
    traverseAncestors(e) {
        const n = this.parent;
        n !== null && (e(n),
        n.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const n = this.children;
        for (let r = 0, o = n.length; r < o; r++)
            n[r].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, n) {
        const r = this.parent;
        if (e === !0 && r !== null && r.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        n === !0) {
            const o = this.children;
            for (let l = 0, u = o.length; l < u; l++)
                o[l].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string"
          , r = {};
        n && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        r.metadata = {
            version: 4.7,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const o = {};
        o.uuid = this.uuid,
        o.type = this.type,
        this.name !== "" && (o.name = this.name),
        this.castShadow === !0 && (o.castShadow = !0),
        this.receiveShadow === !0 && (o.receiveShadow = !0),
        this.visible === !1 && (o.visible = !1),
        this.frustumCulled === !1 && (o.frustumCulled = !1),
        this.renderOrder !== 0 && (o.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (o.userData = this.userData),
        o.layers = this.layers.mask,
        o.matrix = this.matrix.toArray(),
        o.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (o.matrixAutoUpdate = !1),
        this.isInstancedMesh && (o.type = "InstancedMesh",
        o.count = this.count,
        o.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (o.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (o.type = "BatchedMesh",
        o.perObjectFrustumCulled = this.perObjectFrustumCulled,
        o.sortObjects = this.sortObjects,
        o.drawRanges = this._drawRanges,
        o.reservedRanges = this._reservedRanges,
        o.geometryInfo = this._geometryInfo.map(f => ({
            ...f,
            boundingBox: f.boundingBox ? f.boundingBox.toJSON() : void 0,
            boundingSphere: f.boundingSphere ? f.boundingSphere.toJSON() : void 0
        })),
        o.instanceInfo = this._instanceInfo.map(f => ({
            ...f
        })),
        o.availableInstanceIds = this._availableInstanceIds.slice(),
        o.availableGeometryIds = this._availableGeometryIds.slice(),
        o.nextIndexStart = this._nextIndexStart,
        o.nextVertexStart = this._nextVertexStart,
        o.geometryCount = this._geometryCount,
        o.maxInstanceCount = this._maxInstanceCount,
        o.maxVertexCount = this._maxVertexCount,
        o.maxIndexCount = this._maxIndexCount,
        o.geometryInitialized = this._geometryInitialized,
        o.matricesTexture = this._matricesTexture.toJSON(e),
        o.indirectTexture = this._indirectTexture.toJSON(e),
        this._colorsTexture !== null && (o.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (o.boundingSphere = this.boundingSphere.toJSON()),
        this.boundingBox !== null && (o.boundingBox = this.boundingBox.toJSON()));
        function l(f, m) {
            return f[m.uuid] === void 0 && (f[m.uuid] = m.toJSON(e)),
            m.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? o.background = this.background.toJSON() : this.background.isTexture && (o.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (o.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            o.geometry = l(e.geometries, this.geometry);
            const f = this.geometry.parameters;
            if (f !== void 0 && f.shapes !== void 0) {
                const m = f.shapes;
                if (Array.isArray(m))
                    for (let p = 0, v = m.length; p < v; p++) {
                        const _ = m[p];
                        l(e.shapes, _)
                    }
                else
                    l(e.shapes, m)
            }
        }
        if (this.isSkinnedMesh && (o.bindMode = this.bindMode,
        o.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (l(e.skeletons, this.skeleton),
        o.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const f = [];
                for (let m = 0, p = this.material.length; m < p; m++)
                    f.push(l(e.materials, this.material[m]));
                o.material = f
            } else
                o.material = l(e.materials, this.material);
        if (this.children.length > 0) {
            o.children = [];
            for (let f = 0; f < this.children.length; f++)
                o.children.push(this.children[f].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            o.animations = [];
            for (let f = 0; f < this.animations.length; f++) {
                const m = this.animations[f];
                o.animations.push(l(e.animations, m))
            }
        }
        if (n) {
            const f = u(e.geometries)
              , m = u(e.materials)
              , p = u(e.textures)
              , v = u(e.images)
              , _ = u(e.shapes)
              , x = u(e.skeletons)
              , S = u(e.animations)
              , E = u(e.nodes);
            f.length > 0 && (r.geometries = f),
            m.length > 0 && (r.materials = m),
            p.length > 0 && (r.textures = p),
            v.length > 0 && (r.images = v),
            _.length > 0 && (r.shapes = _),
            x.length > 0 && (r.skeletons = x),
            S.length > 0 && (r.animations = S),
            E.length > 0 && (r.nodes = E)
        }
        return r.object = o,
        r;
        function u(f) {
            const m = [];
            for (const p in f) {
                const v = f[p];
                delete v.metadata,
                m.push(v)
            }
            return m
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, n=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        n === !0)
            for (let r = 0; r < e.children.length; r++) {
                const o = e.children[r];
                this.add(o.clone())
            }
        return this
    }
}
xn.DEFAULT_UP = new J(0,1,0);
xn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
xn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ci = new J
  , Fi = new J
  , Pu = new J
  , Oi = new J
  , Rs = new J
  , bs = new J
  , Qp = new J
  , Nu = new J
  , Du = new J
  , Iu = new J
  , Uu = new Pt
  , Fu = new Pt
  , Ou = new Pt;
class ui {
    constructor(e=new J, n=new J, r=new J) {
        this.a = e,
        this.b = n,
        this.c = r
    }
    static getNormal(e, n, r, o) {
        o.subVectors(r, n),
        ci.subVectors(e, n),
        o.cross(ci);
        const l = o.lengthSq();
        return l > 0 ? o.multiplyScalar(1 / Math.sqrt(l)) : o.set(0, 0, 0)
    }
    static getBarycoord(e, n, r, o, l) {
        ci.subVectors(o, n),
        Fi.subVectors(r, n),
        Pu.subVectors(e, n);
        const u = ci.dot(ci)
          , f = ci.dot(Fi)
          , m = ci.dot(Pu)
          , p = Fi.dot(Fi)
          , v = Fi.dot(Pu)
          , _ = u * p - f * f;
        if (_ === 0)
            return l.set(0, 0, 0),
            null;
        const x = 1 / _
          , S = (p * m - f * v) * x
          , E = (u * v - f * m) * x;
        return l.set(1 - S - E, E, S)
    }
    static containsPoint(e, n, r, o) {
        return this.getBarycoord(e, n, r, o, Oi) === null ? !1 : Oi.x >= 0 && Oi.y >= 0 && Oi.x + Oi.y <= 1
    }
    static getInterpolation(e, n, r, o, l, u, f, m) {
        return this.getBarycoord(e, n, r, o, Oi) === null ? (m.x = 0,
        m.y = 0,
        "z"in m && (m.z = 0),
        "w"in m && (m.w = 0),
        null) : (m.setScalar(0),
        m.addScaledVector(l, Oi.x),
        m.addScaledVector(u, Oi.y),
        m.addScaledVector(f, Oi.z),
        m)
    }
    static getInterpolatedAttribute(e, n, r, o, l, u) {
        return Uu.setScalar(0),
        Fu.setScalar(0),
        Ou.setScalar(0),
        Uu.fromBufferAttribute(e, n),
        Fu.fromBufferAttribute(e, r),
        Ou.fromBufferAttribute(e, o),
        u.setScalar(0),
        u.addScaledVector(Uu, l.x),
        u.addScaledVector(Fu, l.y),
        u.addScaledVector(Ou, l.z),
        u
    }
    static isFrontFacing(e, n, r, o) {
        return ci.subVectors(r, n),
        Fi.subVectors(e, n),
        ci.cross(Fi).dot(o) < 0
    }
    set(e, n, r) {
        return this.a.copy(e),
        this.b.copy(n),
        this.c.copy(r),
        this
    }
    setFromPointsAndIndices(e, n, r, o) {
        return this.a.copy(e[n]),
        this.b.copy(e[r]),
        this.c.copy(e[o]),
        this
    }
    setFromAttributeAndIndices(e, n, r, o) {
        return this.a.fromBufferAttribute(e, n),
        this.b.fromBufferAttribute(e, r),
        this.c.fromBufferAttribute(e, o),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return ci.subVectors(this.c, this.b),
        Fi.subVectors(this.a, this.b),
        ci.cross(Fi).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return ui.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, n) {
        return ui.getBarycoord(e, this.a, this.b, this.c, n)
    }
    getInterpolation(e, n, r, o, l) {
        return ui.getInterpolation(e, this.a, this.b, this.c, n, r, o, l)
    }
    containsPoint(e) {
        return ui.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return ui.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, n) {
        const r = this.a
          , o = this.b
          , l = this.c;
        let u, f;
        Rs.subVectors(o, r),
        bs.subVectors(l, r),
        Nu.subVectors(e, r);
        const m = Rs.dot(Nu)
          , p = bs.dot(Nu);
        if (m <= 0 && p <= 0)
            return n.copy(r);
        Du.subVectors(e, o);
        const v = Rs.dot(Du)
          , _ = bs.dot(Du);
        if (v >= 0 && _ <= v)
            return n.copy(o);
        const x = m * _ - v * p;
        if (x <= 0 && m >= 0 && v <= 0)
            return u = m / (m - v),
            n.copy(r).addScaledVector(Rs, u);
        Iu.subVectors(e, l);
        const S = Rs.dot(Iu)
          , E = bs.dot(Iu);
        if (E >= 0 && S <= E)
            return n.copy(l);
        const T = S * p - m * E;
        if (T <= 0 && p >= 0 && E <= 0)
            return f = p / (p - E),
            n.copy(r).addScaledVector(bs, f);
        const y = v * E - S * _;
        if (y <= 0 && _ - v >= 0 && S - E >= 0)
            return Qp.subVectors(l, o),
            f = (_ - v) / (_ - v + (S - E)),
            n.copy(o).addScaledVector(Qp, f);
        const g = 1 / (y + T + x);
        return u = T * g,
        f = x * g,
        n.copy(r).addScaledVector(Rs, u).addScaledVector(bs, f)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const ig = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , fr = {
    h: 0,
    s: 0,
    l: 0
}
  , rl = {
    h: 0,
    s: 0,
    l: 0
};
function zu(s, e, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? s + (e - s) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - n) : s
}
class mt {
    constructor(e, n, r) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, n, r)
    }
    set(e, n, r) {
        if (n === void 0 && r === void 0) {
            const o = e;
            o && o.isColor ? this.copy(o) : typeof o == "number" ? this.setHex(o) : typeof o == "string" && this.setStyle(o)
        } else
            this.setRGB(e, n, r);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, n=Qn) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        Et.colorSpaceToWorking(this, n),
        this
    }
    setRGB(e, n, r, o=Et.workingColorSpace) {
        return this.r = e,
        this.g = n,
        this.b = r,
        Et.colorSpaceToWorking(this, o),
        this
    }
    setHSL(e, n, r, o=Et.workingColorSpace) {
        if (e = Y_(e, 1),
        n = _t(n, 0, 1),
        r = _t(r, 0, 1),
        n === 0)
            this.r = this.g = this.b = r;
        else {
            const l = r <= .5 ? r * (1 + n) : r + n - r * n
              , u = 2 * r - l;
            this.r = zu(u, l, e + 1 / 3),
            this.g = zu(u, l, e),
            this.b = zu(u, l, e - 1 / 3)
        }
        return Et.colorSpaceToWorking(this, o),
        this
    }
    setStyle(e, n=Qn) {
        function r(l) {
            l !== void 0 && parseFloat(l) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let o;
        if (o = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let l;
            const u = o[1]
              , f = o[2];
            switch (u) {
            case "rgb":
            case "rgba":
                if (l = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f))
                    return r(l[4]),
                    this.setRGB(Math.min(255, parseInt(l[1], 10)) / 255, Math.min(255, parseInt(l[2], 10)) / 255, Math.min(255, parseInt(l[3], 10)) / 255, n);
                if (l = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f))
                    return r(l[4]),
                    this.setRGB(Math.min(100, parseInt(l[1], 10)) / 100, Math.min(100, parseInt(l[2], 10)) / 100, Math.min(100, parseInt(l[3], 10)) / 100, n);
                break;
            case "hsl":
            case "hsla":
                if (l = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(f))
                    return r(l[4]),
                    this.setHSL(parseFloat(l[1]) / 360, parseFloat(l[2]) / 100, parseFloat(l[3]) / 100, n);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (o = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const l = o[1]
              , u = l.length;
            if (u === 3)
                return this.setRGB(parseInt(l.charAt(0), 16) / 15, parseInt(l.charAt(1), 16) / 15, parseInt(l.charAt(2), 16) / 15, n);
            if (u === 6)
                return this.setHex(parseInt(l, 16), n);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, n);
        return this
    }
    setColorName(e, n=Qn) {
        const r = ig[e.toLowerCase()];
        return r !== void 0 ? this.setHex(r, n) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Hi(e.r),
        this.g = Hi(e.g),
        this.b = Hi(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = Os(e.r),
        this.g = Os(e.g),
        this.b = Os(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Qn) {
        return Et.workingToColorSpace(vn.copy(this), e),
        Math.round(_t(vn.r * 255, 0, 255)) * 65536 + Math.round(_t(vn.g * 255, 0, 255)) * 256 + Math.round(_t(vn.b * 255, 0, 255))
    }
    getHexString(e=Qn) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, n=Et.workingColorSpace) {
        Et.workingToColorSpace(vn.copy(this), n);
        const r = vn.r
          , o = vn.g
          , l = vn.b
          , u = Math.max(r, o, l)
          , f = Math.min(r, o, l);
        let m, p;
        const v = (f + u) / 2;
        if (f === u)
            m = 0,
            p = 0;
        else {
            const _ = u - f;
            switch (p = v <= .5 ? _ / (u + f) : _ / (2 - u - f),
            u) {
            case r:
                m = (o - l) / _ + (o < l ? 6 : 0);
                break;
            case o:
                m = (l - r) / _ + 2;
                break;
            case l:
                m = (r - o) / _ + 4;
                break
            }
            m /= 6
        }
        return e.h = m,
        e.s = p,
        e.l = v,
        e
    }
    getRGB(e, n=Et.workingColorSpace) {
        return Et.workingToColorSpace(vn.copy(this), n),
        e.r = vn.r,
        e.g = vn.g,
        e.b = vn.b,
        e
    }
    getStyle(e=Qn) {
        Et.workingToColorSpace(vn.copy(this), e);
        const n = vn.r
          , r = vn.g
          , o = vn.b;
        return e !== Qn ? `color(${e} ${n.toFixed(3)} ${r.toFixed(3)} ${o.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(r * 255)},${Math.round(o * 255)})`
    }
    offsetHSL(e, n, r) {
        return this.getHSL(fr),
        this.setHSL(fr.h + e, fr.s + n, fr.l + r)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, n) {
        return this.r = e.r + n.r,
        this.g = e.g + n.g,
        this.b = e.b + n.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, n) {
        return this.r += (e.r - this.r) * n,
        this.g += (e.g - this.g) * n,
        this.b += (e.b - this.b) * n,
        this
    }
    lerpColors(e, n, r) {
        return this.r = e.r + (n.r - e.r) * r,
        this.g = e.g + (n.g - e.g) * r,
        this.b = e.b + (n.b - e.b) * r,
        this
    }
    lerpHSL(e, n) {
        this.getHSL(fr),
        e.getHSL(rl);
        const r = yu(fr.h, rl.h, n)
          , o = yu(fr.s, rl.s, n)
          , l = yu(fr.l, rl.l, n);
        return this.setHSL(r, o, l),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const n = this.r
          , r = this.g
          , o = this.b
          , l = e.elements;
        return this.r = l[0] * n + l[3] * r + l[6] * o,
        this.g = l[1] * n + l[4] * r + l[7] * o,
        this.b = l[2] * n + l[5] * r + l[8] * o,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, n=0) {
        return this.r = e[n],
        this.g = e[n + 1],
        this.b = e[n + 2],
        this
    }
    toArray(e=[], n=0) {
        return e[n] = this.r,
        e[n + 1] = this.g,
        e[n + 2] = this.b,
        e
    }
    fromBufferAttribute(e, n) {
        return this.r = e.getX(n),
        this.g = e.getY(n),
        this.b = e.getZ(n),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const vn = new mt;
mt.NAMES = ig;
let cv = 0;
class Jr extends js {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: cv++
        }),
        this.uuid = Oa(),
        this.name = "",
        this.type = "Material",
        this.blending = Us,
        this.side = _r,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = Qu,
        this.blendDst = Zu,
        this.blendEquation = Vr,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new mt(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = zs,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = zp,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = ys,
        this.stencilZFail = ys,
        this.stencilZPass = ys,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.allowOverride = !0,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const n in e) {
                const r = e[n];
                if (r === void 0) {
                    console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
                    continue
                }
                const o = this[n];
                if (o === void 0) {
                    console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
                    continue
                }
                o && o.isColor ? o.set(r) : o && o.isVector3 && r && r.isVector3 ? o.copy(r) : this[n] = r
            }
    }
    toJSON(e) {
        const n = e === void 0 || typeof e == "string";
        n && (e = {
            textures: {},
            images: {}
        });
        const r = {
            metadata: {
                version: 4.7,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.color && this.color.isColor && (r.color = this.color.getHex()),
        this.roughness !== void 0 && (r.roughness = this.roughness),
        this.metalness !== void 0 && (r.metalness = this.metalness),
        this.sheen !== void 0 && (r.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (r.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (r.shininess = this.shininess),
        this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (r.dispersion = this.dispersion),
        this.iridescence !== void 0 && (r.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid,
        r.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid,
        r.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid,
        r.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid,
        r.normalMapType = this.normalMapType,
        r.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid,
        r.displacementScale = this.displacementScale,
        r.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (r.combine = this.combine)),
        this.envMapRotation !== void 0 && (r.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (r.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (r.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (r.size = this.size),
        this.shadowSide !== null && (r.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Us && (r.blending = this.blending),
        this.side !== _r && (r.side = this.side),
        this.vertexColors === !0 && (r.vertexColors = !0),
        this.opacity < 1 && (r.opacity = this.opacity),
        this.transparent === !0 && (r.transparent = !0),
        this.blendSrc !== Qu && (r.blendSrc = this.blendSrc),
        this.blendDst !== Zu && (r.blendDst = this.blendDst),
        this.blendEquation !== Vr && (r.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (r.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (r.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
        this.depthFunc !== zs && (r.depthFunc = this.depthFunc),
        this.depthTest === !1 && (r.depthTest = this.depthTest),
        this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (r.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== zp && (r.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (r.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== ys && (r.stencilFail = this.stencilFail),
        this.stencilZFail !== ys && (r.stencilZFail = this.stencilZFail),
        this.stencilZPass !== ys && (r.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation),
        this.polygonOffset === !0 && (r.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth),
        this.dashSize !== void 0 && (r.dashSize = this.dashSize),
        this.gapSize !== void 0 && (r.gapSize = this.gapSize),
        this.scale !== void 0 && (r.scale = this.scale),
        this.dithering === !0 && (r.dithering = !0),
        this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (r.alphaHash = !0),
        this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (r.forceSinglePass = !0),
        this.wireframe === !0 && (r.wireframe = !0),
        this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (r.flatShading = !0),
        this.visible === !1 && (r.visible = !1),
        this.toneMapped === !1 && (r.toneMapped = !1),
        this.fog === !1 && (r.fog = !1),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData);
        function o(l) {
            const u = [];
            for (const f in l) {
                const m = l[f];
                delete m.metadata,
                u.push(m)
            }
            return u
        }
        if (n) {
            const l = o(e.textures)
              , u = o(e.images);
            l.length > 0 && (r.textures = l),
            u.length > 0 && (r.images = u)
        }
        return r
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const n = e.clippingPlanes;
        let r = null;
        if (n !== null) {
            const o = n.length;
            r = new Array(o);
            for (let l = 0; l !== o; ++l)
                r[l] = n[l].clone()
        }
        return this.clippingPlanes = r,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
class rg extends Jr {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new mt(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new wi,
        this.combine = Vm,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const qt = new J
  , sl = new vt;
let uv = 0;
class Zn {
    constructor(e, n, r=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        Object.defineProperty(this, "id", {
            value: uv++
        }),
        this.name = "",
        this.array = e,
        this.itemSize = n,
        this.count = e !== void 0 ? e.length / n : 0,
        this.normalized = r,
        this.usage = kp,
        this.updateRanges = [],
        this.gpuType = Bi,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, n) {
        this.updateRanges.push({
            start: e,
            count: n
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, n, r) {
        e *= this.itemSize,
        r *= n.itemSize;
        for (let o = 0, l = this.itemSize; o < l; o++)
            this.array[e + o] = n.array[r + o];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let n = 0, r = this.count; n < r; n++)
                sl.fromBufferAttribute(this, n),
                sl.applyMatrix3(e),
                this.setXY(n, sl.x, sl.y);
        else if (this.itemSize === 3)
            for (let n = 0, r = this.count; n < r; n++)
                qt.fromBufferAttribute(this, n),
                qt.applyMatrix3(e),
                this.setXYZ(n, qt.x, qt.y, qt.z);
        return this
    }
    applyMatrix4(e) {
        for (let n = 0, r = this.count; n < r; n++)
            qt.fromBufferAttribute(this, n),
            qt.applyMatrix4(e),
            this.setXYZ(n, qt.x, qt.y, qt.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let n = 0, r = this.count; n < r; n++)
            qt.fromBufferAttribute(this, n),
            qt.applyNormalMatrix(e),
            this.setXYZ(n, qt.x, qt.y, qt.z);
        return this
    }
    transformDirection(e) {
        for (let n = 0, r = this.count; n < r; n++)
            qt.fromBufferAttribute(this, n),
            qt.transformDirection(e),
            this.setXYZ(n, qt.x, qt.y, qt.z);
        return this
    }
    set(e, n=0) {
        return this.array.set(e, n),
        this
    }
    getComponent(e, n) {
        let r = this.array[e * this.itemSize + n];
        return this.normalized && (r = Ea(r, this.array)),
        r
    }
    setComponent(e, n, r) {
        return this.normalized && (r = Pn(r, this.array)),
        this.array[e * this.itemSize + n] = r,
        this
    }
    getX(e) {
        let n = this.array[e * this.itemSize];
        return this.normalized && (n = Ea(n, this.array)),
        n
    }
    setX(e, n) {
        return this.normalized && (n = Pn(n, this.array)),
        this.array[e * this.itemSize] = n,
        this
    }
    getY(e) {
        let n = this.array[e * this.itemSize + 1];
        return this.normalized && (n = Ea(n, this.array)),
        n
    }
    setY(e, n) {
        return this.normalized && (n = Pn(n, this.array)),
        this.array[e * this.itemSize + 1] = n,
        this
    }
    getZ(e) {
        let n = this.array[e * this.itemSize + 2];
        return this.normalized && (n = Ea(n, this.array)),
        n
    }
    setZ(e, n) {
        return this.normalized && (n = Pn(n, this.array)),
        this.array[e * this.itemSize + 2] = n,
        this
    }
    getW(e) {
        let n = this.array[e * this.itemSize + 3];
        return this.normalized && (n = Ea(n, this.array)),
        n
    }
    setW(e, n) {
        return this.normalized && (n = Pn(n, this.array)),
        this.array[e * this.itemSize + 3] = n,
        this
    }
    setXY(e, n, r) {
        return e *= this.itemSize,
        this.normalized && (n = Pn(n, this.array),
        r = Pn(r, this.array)),
        this.array[e + 0] = n,
        this.array[e + 1] = r,
        this
    }
    setXYZ(e, n, r, o) {
        return e *= this.itemSize,
        this.normalized && (n = Pn(n, this.array),
        r = Pn(r, this.array),
        o = Pn(o, this.array)),
        this.array[e + 0] = n,
        this.array[e + 1] = r,
        this.array[e + 2] = o,
        this
    }
    setXYZW(e, n, r, o, l) {
        return e *= this.itemSize,
        this.normalized && (n = Pn(n, this.array),
        r = Pn(r, this.array),
        o = Pn(o, this.array),
        l = Pn(l, this.array)),
        this.array[e + 0] = n,
        this.array[e + 1] = r,
        this.array[e + 2] = o,
        this.array[e + 3] = l,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== kp && (e.usage = this.usage),
        e
    }
}
class sg extends Zn {
    constructor(e, n, r) {
        super(new Uint16Array(e), n, r)
    }
}
class ag extends Zn {
    constructor(e, n, r) {
        super(new Uint32Array(e), n, r)
    }
}
class cn extends Zn {
    constructor(e, n, r) {
        super(new Float32Array(e), n, r)
    }
}
let dv = 0;
const Kn = new Vt
  , ku = new xn
  , Ls = new J
  , Vn = new ka
  , Ra = new ka
  , sn = new J;
class Un extends js {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: dv++
        }),
        this.uuid = Oa(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.indirect = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (eg(e) ? ag : sg)(e,1) : this.index = e,
        this
    }
    setIndirect(e) {
        return this.indirect = e,
        this
    }
    getIndirect() {
        return this.indirect
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, n) {
        return this.attributes[e] = n,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, n, r=0) {
        this.groups.push({
            start: e,
            count: n,
            materialIndex: r
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, n) {
        this.drawRange.start = e,
        this.drawRange.count = n
    }
    applyMatrix4(e) {
        const n = this.attributes.position;
        n !== void 0 && (n.applyMatrix4(e),
        n.needsUpdate = !0);
        const r = this.attributes.normal;
        if (r !== void 0) {
            const l = new ut().getNormalMatrix(e);
            r.applyNormalMatrix(l),
            r.needsUpdate = !0
        }
        const o = this.attributes.tangent;
        return o !== void 0 && (o.transformDirection(e),
        o.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return Kn.makeRotationFromQuaternion(e),
        this.applyMatrix4(Kn),
        this
    }
    rotateX(e) {
        return Kn.makeRotationX(e),
        this.applyMatrix4(Kn),
        this
    }
    rotateY(e) {
        return Kn.makeRotationY(e),
        this.applyMatrix4(Kn),
        this
    }
    rotateZ(e) {
        return Kn.makeRotationZ(e),
        this.applyMatrix4(Kn),
        this
    }
    translate(e, n, r) {
        return Kn.makeTranslation(e, n, r),
        this.applyMatrix4(Kn),
        this
    }
    scale(e, n, r) {
        return Kn.makeScale(e, n, r),
        this.applyMatrix4(Kn),
        this
    }
    lookAt(e) {
        return ku.lookAt(e),
        ku.updateMatrix(),
        this.applyMatrix4(ku.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Ls).negate(),
        this.translate(Ls.x, Ls.y, Ls.z),
        this
    }
    setFromPoints(e) {
        const n = this.getAttribute("position");
        if (n === void 0) {
            const r = [];
            for (let o = 0, l = e.length; o < l; o++) {
                const u = e[o];
                r.push(u.x, u.y, u.z || 0)
            }
            this.setAttribute("position", new cn(r,3))
        } else {
            const r = Math.min(e.length, n.count);
            for (let o = 0; o < r; o++) {
                const l = e[o];
                n.setXYZ(o, l.x, l.y, l.z || 0)
            }
            e.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
            n.needsUpdate = !0
        }
        return this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new ka);
        const e = this.attributes.position
          , n = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new J(-1 / 0,-1 / 0,-1 / 0), new J(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            n)
                for (let r = 0, o = n.length; r < o; r++) {
                    const l = n[r];
                    Vn.setFromBufferAttribute(l),
                    this.morphTargetsRelative ? (sn.addVectors(this.boundingBox.min, Vn.min),
                    this.boundingBox.expandByPoint(sn),
                    sn.addVectors(this.boundingBox.max, Vn.max),
                    this.boundingBox.expandByPoint(sn)) : (this.boundingBox.expandByPoint(Vn.min),
                    this.boundingBox.expandByPoint(Vn.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Ba);
        const e = this.attributes.position
          , n = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new J, 1 / 0);
            return
        }
        if (e) {
            const r = this.boundingSphere.center;
            if (Vn.setFromBufferAttribute(e),
            n)
                for (let l = 0, u = n.length; l < u; l++) {
                    const f = n[l];
                    Ra.setFromBufferAttribute(f),
                    this.morphTargetsRelative ? (sn.addVectors(Vn.min, Ra.min),
                    Vn.expandByPoint(sn),
                    sn.addVectors(Vn.max, Ra.max),
                    Vn.expandByPoint(sn)) : (Vn.expandByPoint(Ra.min),
                    Vn.expandByPoint(Ra.max))
                }
            Vn.getCenter(r);
            let o = 0;
            for (let l = 0, u = e.count; l < u; l++)
                sn.fromBufferAttribute(e, l),
                o = Math.max(o, r.distanceToSquared(sn));
            if (n)
                for (let l = 0, u = n.length; l < u; l++) {
                    const f = n[l]
                      , m = this.morphTargetsRelative;
                    for (let p = 0, v = f.count; p < v; p++)
                        sn.fromBufferAttribute(f, p),
                        m && (Ls.fromBufferAttribute(e, p),
                        sn.add(Ls)),
                        o = Math.max(o, r.distanceToSquared(sn))
                }
            this.boundingSphere.radius = Math.sqrt(o),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , n = this.attributes;
        if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const r = n.position
          , o = n.normal
          , l = n.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Zn(new Float32Array(4 * r.count),4));
        const u = this.getAttribute("tangent")
          , f = []
          , m = [];
        for (let j = 0; j < r.count; j++)
            f[j] = new J,
            m[j] = new J;
        const p = new J
          , v = new J
          , _ = new J
          , x = new vt
          , S = new vt
          , E = new vt
          , T = new J
          , y = new J;
        function g(j, b, R) {
            p.fromBufferAttribute(r, j),
            v.fromBufferAttribute(r, b),
            _.fromBufferAttribute(r, R),
            x.fromBufferAttribute(l, j),
            S.fromBufferAttribute(l, b),
            E.fromBufferAttribute(l, R),
            v.sub(p),
            _.sub(p),
            S.sub(x),
            E.sub(x);
            const I = 1 / (S.x * E.y - E.x * S.y);
            isFinite(I) && (T.copy(v).multiplyScalar(E.y).addScaledVector(_, -S.y).multiplyScalar(I),
            y.copy(_).multiplyScalar(S.x).addScaledVector(v, -E.x).multiplyScalar(I),
            f[j].add(T),
            f[b].add(T),
            f[R].add(T),
            m[j].add(y),
            m[b].add(y),
            m[R].add(y))
        }
        let N = this.groups;
        N.length === 0 && (N = [{
            start: 0,
            count: e.count
        }]);
        for (let j = 0, b = N.length; j < b; ++j) {
            const R = N[j]
              , I = R.start
              , oe = R.count;
            for (let se = I, ce = I + oe; se < ce; se += 3)
                g(e.getX(se + 0), e.getX(se + 1), e.getX(se + 2))
        }
        const L = new J
          , C = new J
          , H = new J
          , k = new J;
        function F(j) {
            H.fromBufferAttribute(o, j),
            k.copy(H);
            const b = f[j];
            L.copy(b),
            L.sub(H.multiplyScalar(H.dot(b))).normalize(),
            C.crossVectors(k, b);
            const I = C.dot(m[j]) < 0 ? -1 : 1;
            u.setXYZW(j, L.x, L.y, L.z, I)
        }
        for (let j = 0, b = N.length; j < b; ++j) {
            const R = N[j]
              , I = R.start
              , oe = R.count;
            for (let se = I, ce = I + oe; se < ce; se += 3)
                F(e.getX(se + 0)),
                F(e.getX(se + 1)),
                F(e.getX(se + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , n = this.getAttribute("position");
        if (n !== void 0) {
            let r = this.getAttribute("normal");
            if (r === void 0)
                r = new Zn(new Float32Array(n.count * 3),3),
                this.setAttribute("normal", r);
            else
                for (let x = 0, S = r.count; x < S; x++)
                    r.setXYZ(x, 0, 0, 0);
            const o = new J
              , l = new J
              , u = new J
              , f = new J
              , m = new J
              , p = new J
              , v = new J
              , _ = new J;
            if (e)
                for (let x = 0, S = e.count; x < S; x += 3) {
                    const E = e.getX(x + 0)
                      , T = e.getX(x + 1)
                      , y = e.getX(x + 2);
                    o.fromBufferAttribute(n, E),
                    l.fromBufferAttribute(n, T),
                    u.fromBufferAttribute(n, y),
                    v.subVectors(u, l),
                    _.subVectors(o, l),
                    v.cross(_),
                    f.fromBufferAttribute(r, E),
                    m.fromBufferAttribute(r, T),
                    p.fromBufferAttribute(r, y),
                    f.add(v),
                    m.add(v),
                    p.add(v),
                    r.setXYZ(E, f.x, f.y, f.z),
                    r.setXYZ(T, m.x, m.y, m.z),
                    r.setXYZ(y, p.x, p.y, p.z)
                }
            else
                for (let x = 0, S = n.count; x < S; x += 3)
                    o.fromBufferAttribute(n, x + 0),
                    l.fromBufferAttribute(n, x + 1),
                    u.fromBufferAttribute(n, x + 2),
                    v.subVectors(u, l),
                    _.subVectors(o, l),
                    v.cross(_),
                    r.setXYZ(x + 0, v.x, v.y, v.z),
                    r.setXYZ(x + 1, v.x, v.y, v.z),
                    r.setXYZ(x + 2, v.x, v.y, v.z);
            this.normalizeNormals(),
            r.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let n = 0, r = e.count; n < r; n++)
            sn.fromBufferAttribute(e, n),
            sn.normalize(),
            e.setXYZ(n, sn.x, sn.y, sn.z)
    }
    toNonIndexed() {
        function e(f, m) {
            const p = f.array
              , v = f.itemSize
              , _ = f.normalized
              , x = new p.constructor(m.length * v);
            let S = 0
              , E = 0;
            for (let T = 0, y = m.length; T < y; T++) {
                f.isInterleavedBufferAttribute ? S = m[T] * f.data.stride + f.offset : S = m[T] * v;
                for (let g = 0; g < v; g++)
                    x[E++] = p[S++]
            }
            return new Zn(x,v,_)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const n = new Un
          , r = this.index.array
          , o = this.attributes;
        for (const f in o) {
            const m = o[f]
              , p = e(m, r);
            n.setAttribute(f, p)
        }
        const l = this.morphAttributes;
        for (const f in l) {
            const m = []
              , p = l[f];
            for (let v = 0, _ = p.length; v < _; v++) {
                const x = p[v]
                  , S = e(x, r);
                m.push(S)
            }
            n.morphAttributes[f] = m
        }
        n.morphTargetsRelative = this.morphTargetsRelative;
        const u = this.groups;
        for (let f = 0, m = u.length; f < m; f++) {
            const p = u[f];
            n.addGroup(p.start, p.count, p.materialIndex)
        }
        return n
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.7,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const m = this.parameters;
            for (const p in m)
                m[p] !== void 0 && (e[p] = m[p]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const n = this.index;
        n !== null && (e.data.index = {
            type: n.array.constructor.name,
            array: Array.prototype.slice.call(n.array)
        });
        const r = this.attributes;
        for (const m in r) {
            const p = r[m];
            e.data.attributes[m] = p.toJSON(e.data)
        }
        const o = {};
        let l = !1;
        for (const m in this.morphAttributes) {
            const p = this.morphAttributes[m]
              , v = [];
            for (let _ = 0, x = p.length; _ < x; _++) {
                const S = p[_];
                v.push(S.toJSON(e.data))
            }
            v.length > 0 && (o[m] = v,
            l = !0)
        }
        l && (e.data.morphAttributes = o,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const u = this.groups;
        u.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(u)));
        const f = this.boundingSphere;
        return f !== null && (e.data.boundingSphere = f.toJSON()),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const n = {};
        this.name = e.name;
        const r = e.index;
        r !== null && this.setIndex(r.clone());
        const o = e.attributes;
        for (const p in o) {
            const v = o[p];
            this.setAttribute(p, v.clone(n))
        }
        const l = e.morphAttributes;
        for (const p in l) {
            const v = []
              , _ = l[p];
            for (let x = 0, S = _.length; x < S; x++)
                v.push(_[x].clone(n));
            this.morphAttributes[p] = v
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const u = e.groups;
        for (let p = 0, v = u.length; p < v; p++) {
            const _ = u[p];
            this.addGroup(_.start, _.count, _.materialIndex)
        }
        const f = e.boundingBox;
        f !== null && (this.boundingBox = f.clone());
        const m = e.boundingSphere;
        return m !== null && (this.boundingSphere = m.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const Zp = new Vt
  , Fr = new $d
  , al = new Ba
  , em = new J
  , ol = new J
  , ll = new J
  , cl = new J
  , Bu = new J
  , ul = new J
  , tm = new J
  , dl = new J;
class fi extends xn {
    constructor(e=new Un, n=new rg) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = n,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.count = 1,
        this.updateMorphTargets()
    }
    copy(e, n) {
        return super.copy(e, n),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const n = this.geometry.morphAttributes
          , r = Object.keys(n);
        if (r.length > 0) {
            const o = n[r[0]];
            if (o !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let l = 0, u = o.length; l < u; l++) {
                    const f = o[l].name || String(l);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[f] = l
                }
            }
        }
    }
    getVertexPosition(e, n) {
        const r = this.geometry
          , o = r.attributes.position
          , l = r.morphAttributes.position
          , u = r.morphTargetsRelative;
        n.fromBufferAttribute(o, e);
        const f = this.morphTargetInfluences;
        if (l && f) {
            ul.set(0, 0, 0);
            for (let m = 0, p = l.length; m < p; m++) {
                const v = f[m]
                  , _ = l[m];
                v !== 0 && (Bu.fromBufferAttribute(_, e),
                u ? ul.addScaledVector(Bu, v) : ul.addScaledVector(Bu.sub(n), v))
            }
            n.add(ul)
        }
        return n
    }
    raycast(e, n) {
        const r = this.geometry
          , o = this.material
          , l = this.matrixWorld;
        o !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(),
        al.copy(r.boundingSphere),
        al.applyMatrix4(l),
        Fr.copy(e.ray).recast(e.near),
        !(al.containsPoint(Fr.origin) === !1 && (Fr.intersectSphere(al, em) === null || Fr.origin.distanceToSquared(em) > (e.far - e.near) ** 2)) && (Zp.copy(l).invert(),
        Fr.copy(e.ray).applyMatrix4(Zp),
        !(r.boundingBox !== null && Fr.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, n, Fr)))
    }
    _computeIntersections(e, n, r) {
        let o;
        const l = this.geometry
          , u = this.material
          , f = l.index
          , m = l.attributes.position
          , p = l.attributes.uv
          , v = l.attributes.uv1
          , _ = l.attributes.normal
          , x = l.groups
          , S = l.drawRange;
        if (f !== null)
            if (Array.isArray(u))
                for (let E = 0, T = x.length; E < T; E++) {
                    const y = x[E]
                      , g = u[y.materialIndex]
                      , N = Math.max(y.start, S.start)
                      , L = Math.min(f.count, Math.min(y.start + y.count, S.start + S.count));
                    for (let C = N, H = L; C < H; C += 3) {
                        const k = f.getX(C)
                          , F = f.getX(C + 1)
                          , j = f.getX(C + 2);
                        o = fl(this, g, e, r, p, v, _, k, F, j),
                        o && (o.faceIndex = Math.floor(C / 3),
                        o.face.materialIndex = y.materialIndex,
                        n.push(o))
                    }
                }
            else {
                const E = Math.max(0, S.start)
                  , T = Math.min(f.count, S.start + S.count);
                for (let y = E, g = T; y < g; y += 3) {
                    const N = f.getX(y)
                      , L = f.getX(y + 1)
                      , C = f.getX(y + 2);
                    o = fl(this, u, e, r, p, v, _, N, L, C),
                    o && (o.faceIndex = Math.floor(y / 3),
                    n.push(o))
                }
            }
        else if (m !== void 0)
            if (Array.isArray(u))
                for (let E = 0, T = x.length; E < T; E++) {
                    const y = x[E]
                      , g = u[y.materialIndex]
                      , N = Math.max(y.start, S.start)
                      , L = Math.min(m.count, Math.min(y.start + y.count, S.start + S.count));
                    for (let C = N, H = L; C < H; C += 3) {
                        const k = C
                          , F = C + 1
                          , j = C + 2;
                        o = fl(this, g, e, r, p, v, _, k, F, j),
                        o && (o.faceIndex = Math.floor(C / 3),
                        o.face.materialIndex = y.materialIndex,
                        n.push(o))
                    }
                }
            else {
                const E = Math.max(0, S.start)
                  , T = Math.min(m.count, S.start + S.count);
                for (let y = E, g = T; y < g; y += 3) {
                    const N = y
                      , L = y + 1
                      , C = y + 2;
                    o = fl(this, u, e, r, p, v, _, N, L, C),
                    o && (o.faceIndex = Math.floor(y / 3),
                    n.push(o))
                }
            }
    }
}
function fv(s, e, n, r, o, l, u, f) {
    let m;
    if (e.side === Nn ? m = r.intersectTriangle(u, l, o, !0, f) : m = r.intersectTriangle(o, l, u, e.side === _r, f),
    m === null)
        return null;
    dl.copy(f),
    dl.applyMatrix4(s.matrixWorld);
    const p = n.ray.origin.distanceTo(dl);
    return p < n.near || p > n.far ? null : {
        distance: p,
        point: dl.clone(),
        object: s
    }
}
function fl(s, e, n, r, o, l, u, f, m, p) {
    s.getVertexPosition(f, ol),
    s.getVertexPosition(m, ll),
    s.getVertexPosition(p, cl);
    const v = fv(s, e, n, r, ol, ll, cl, tm);
    if (v) {
        const _ = new J;
        ui.getBarycoord(tm, ol, ll, cl, _),
        o && (v.uv = ui.getInterpolatedAttribute(o, f, m, p, _, new vt)),
        l && (v.uv1 = ui.getInterpolatedAttribute(l, f, m, p, _, new vt)),
        u && (v.normal = ui.getInterpolatedAttribute(u, f, m, p, _, new J),
        v.normal.dot(r.direction) > 0 && v.normal.multiplyScalar(-1));
        const x = {
            a: f,
            b: m,
            c: p,
            normal: new J,
            materialIndex: 0
        };
        ui.getNormal(ol, ll, cl, x.normal),
        v.face = x,
        v.barycoord = _
    }
    return v
}
class Ha extends Un {
    constructor(e=1, n=1, r=1, o=1, l=1, u=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: n,
            depth: r,
            widthSegments: o,
            heightSegments: l,
            depthSegments: u
        };
        const f = this;
        o = Math.floor(o),
        l = Math.floor(l),
        u = Math.floor(u);
        const m = []
          , p = []
          , v = []
          , _ = [];
        let x = 0
          , S = 0;
        E("z", "y", "x", -1, -1, r, n, e, u, l, 0),
        E("z", "y", "x", 1, -1, r, n, -e, u, l, 1),
        E("x", "z", "y", 1, 1, e, r, n, o, u, 2),
        E("x", "z", "y", 1, -1, e, r, -n, o, u, 3),
        E("x", "y", "z", 1, -1, e, n, r, o, l, 4),
        E("x", "y", "z", -1, -1, e, n, -r, o, l, 5),
        this.setIndex(m),
        this.setAttribute("position", new cn(p,3)),
        this.setAttribute("normal", new cn(v,3)),
        this.setAttribute("uv", new cn(_,2));
        function E(T, y, g, N, L, C, H, k, F, j, b) {
            const R = C / F
              , I = H / j
              , oe = C / 2
              , se = H / 2
              , ce = k / 2
              , ne = F + 1
              , ae = j + 1;
            let de = 0
              , V = 0;
            const ue = new J;
            for (let re = 0; re < ae; re++) {
                const U = re * I - se;
                for (let ie = 0; ie < ne; ie++) {
                    const ke = ie * R - oe;
                    ue[T] = ke * N,
                    ue[y] = U * L,
                    ue[g] = ce,
                    p.push(ue.x, ue.y, ue.z),
                    ue[T] = 0,
                    ue[y] = 0,
                    ue[g] = k > 0 ? 1 : -1,
                    v.push(ue.x, ue.y, ue.z),
                    _.push(ie / F),
                    _.push(1 - re / j),
                    de += 1
                }
            }
            for (let re = 0; re < j; re++)
                for (let U = 0; U < F; U++) {
                    const ie = x + U + ne * re
                      , ke = x + U + ne * (re + 1)
                      , ze = x + (U + 1) + ne * (re + 1)
                      , Q = x + (U + 1) + ne * re;
                    m.push(ie, ke, Q),
                    m.push(ke, ze, Q),
                    V += 6
                }
            f.addGroup(S, V, b),
            S += V,
            x += de
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Ha(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function Vs(s) {
    const e = {};
    for (const n in s) {
        e[n] = {};
        for (const r in s[n]) {
            const o = s[n][r];
            o && (o.isColor || o.isMatrix3 || o.isMatrix4 || o.isVector2 || o.isVector3 || o.isVector4 || o.isTexture || o.isQuaternion) ? o.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[n][r] = null) : e[n][r] = o.clone() : Array.isArray(o) ? e[n][r] = o.slice() : e[n][r] = o
        }
    }
    return e
}
function En(s) {
    const e = {};
    for (let n = 0; n < s.length; n++) {
        const r = Vs(s[n]);
        for (const o in r)
            e[o] = r[o]
    }
    return e
}
function hv(s) {
    const e = [];
    for (let n = 0; n < s.length; n++)
        e.push(s[n].clone());
    return e
}
function og(s) {
    const e = s.getRenderTarget();
    return e === null ? s.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Et.workingColorSpace
}
const pv = {
    clone: Vs,
    merge: En
};
var mv = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , gv = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class vr extends Jr {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = mv,
        this.fragmentShader = gv,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Vs(e.uniforms),
        this.uniformsGroups = hv(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        n.glslVersion = this.glslVersion,
        n.uniforms = {};
        for (const o in this.uniforms) {
            const u = this.uniforms[o].value;
            u && u.isTexture ? n.uniforms[o] = {
                type: "t",
                value: u.toJSON(e).uuid
            } : u && u.isColor ? n.uniforms[o] = {
                type: "c",
                value: u.getHex()
            } : u && u.isVector2 ? n.uniforms[o] = {
                type: "v2",
                value: u.toArray()
            } : u && u.isVector3 ? n.uniforms[o] = {
                type: "v3",
                value: u.toArray()
            } : u && u.isVector4 ? n.uniforms[o] = {
                type: "v4",
                value: u.toArray()
            } : u && u.isMatrix3 ? n.uniforms[o] = {
                type: "m3",
                value: u.toArray()
            } : u && u.isMatrix4 ? n.uniforms[o] = {
                type: "m4",
                value: u.toArray()
            } : n.uniforms[o] = {
                value: u
            }
        }
        Object.keys(this.defines).length > 0 && (n.defines = this.defines),
        n.vertexShader = this.vertexShader,
        n.fragmentShader = this.fragmentShader,
        n.lights = this.lights,
        n.clipping = this.clipping;
        const r = {};
        for (const o in this.extensions)
            this.extensions[o] === !0 && (r[o] = !0);
        return Object.keys(r).length > 0 && (n.extensions = r),
        n
    }
}
class lg extends xn {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Vt,
        this.projectionMatrix = new Vt,
        this.projectionMatrixInverse = new Vt,
        this.coordinateSystem = yi,
        this._reversedDepth = !1
    }
    get reversedDepth() {
        return this._reversedDepth
    }
    copy(e, n) {
        return super.copy(e, n),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, n) {
        super.updateWorldMatrix(e, n),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const hr = new J
  , nm = new vt
  , im = new vt;
class jn extends lg {
    constructor(e=50, n=1, r=.1, o=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = r,
        this.far = o,
        this.focus = 10,
        this.aspect = n,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, n) {
        return super.copy(e, n),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const n = .5 * this.getFilmHeight() / e;
        this.fov = Od * 2 * Math.atan(n),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(xu * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Od * 2 * Math.atan(Math.tan(xu * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, n, r) {
        hr.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        n.set(hr.x, hr.y).multiplyScalar(-e / hr.z),
        hr.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        r.set(hr.x, hr.y).multiplyScalar(-e / hr.z)
    }
    getViewSize(e, n) {
        return this.getViewBounds(e, nm, im),
        n.subVectors(im, nm)
    }
    setViewOffset(e, n, r, o, l, u) {
        this.aspect = e / n,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = n,
        this.view.offsetX = r,
        this.view.offsetY = o,
        this.view.width = l,
        this.view.height = u,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let n = e * Math.tan(xu * .5 * this.fov) / this.zoom
          , r = 2 * n
          , o = this.aspect * r
          , l = -.5 * o;
        const u = this.view;
        if (this.view !== null && this.view.enabled) {
            const m = u.fullWidth
              , p = u.fullHeight;
            l += u.offsetX * o / m,
            n -= u.offsetY * r / p,
            o *= u.width / m,
            r *= u.height / p
        }
        const f = this.filmOffset;
        f !== 0 && (l += e * f / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(l, l + o, n, n - r, e, this.far, this.coordinateSystem, this.reversedDepth),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.object.fov = this.fov,
        n.object.zoom = this.zoom,
        n.object.near = this.near,
        n.object.far = this.far,
        n.object.focus = this.focus,
        n.object.aspect = this.aspect,
        this.view !== null && (n.object.view = Object.assign({}, this.view)),
        n.object.filmGauge = this.filmGauge,
        n.object.filmOffset = this.filmOffset,
        n
    }
}
const Ps = -90
  , Ns = 1;
class _v extends xn {
    constructor(e, n, r) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = r,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const o = new jn(Ps,Ns,e,n);
        o.layers = this.layers,
        this.add(o);
        const l = new jn(Ps,Ns,e,n);
        l.layers = this.layers,
        this.add(l);
        const u = new jn(Ps,Ns,e,n);
        u.layers = this.layers,
        this.add(u);
        const f = new jn(Ps,Ns,e,n);
        f.layers = this.layers,
        this.add(f);
        const m = new jn(Ps,Ns,e,n);
        m.layers = this.layers,
        this.add(m);
        const p = new jn(Ps,Ns,e,n);
        p.layers = this.layers,
        this.add(p)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , n = this.children.concat()
          , [r,o,l,u,f,m] = n;
        for (const p of n)
            this.remove(p);
        if (e === yi)
            r.up.set(0, 1, 0),
            r.lookAt(1, 0, 0),
            o.up.set(0, 1, 0),
            o.lookAt(-1, 0, 0),
            l.up.set(0, 0, -1),
            l.lookAt(0, 1, 0),
            u.up.set(0, 0, 1),
            u.lookAt(0, -1, 0),
            f.up.set(0, 1, 0),
            f.lookAt(0, 0, 1),
            m.up.set(0, 1, 0),
            m.lookAt(0, 0, -1);
        else if (e === bl)
            r.up.set(0, -1, 0),
            r.lookAt(-1, 0, 0),
            o.up.set(0, -1, 0),
            o.lookAt(1, 0, 0),
            l.up.set(0, 0, 1),
            l.lookAt(0, 1, 0),
            u.up.set(0, 0, -1),
            u.lookAt(0, -1, 0),
            f.up.set(0, -1, 0),
            f.lookAt(0, 0, 1),
            m.up.set(0, -1, 0),
            m.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const p of n)
            this.add(p),
            p.updateMatrixWorld()
    }
    update(e, n) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: r, activeMipmapLevel: o} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [l,u,f,m,p,v] = this.children
          , _ = e.getRenderTarget()
          , x = e.getActiveCubeFace()
          , S = e.getActiveMipmapLevel()
          , E = e.xr.enabled;
        e.xr.enabled = !1;
        const T = r.texture.generateMipmaps;
        r.texture.generateMipmaps = !1,
        e.setRenderTarget(r, 0, o),
        e.render(n, l),
        e.setRenderTarget(r, 1, o),
        e.render(n, u),
        e.setRenderTarget(r, 2, o),
        e.render(n, f),
        e.setRenderTarget(r, 3, o),
        e.render(n, m),
        e.setRenderTarget(r, 4, o),
        e.render(n, p),
        r.texture.generateMipmaps = T,
        e.setRenderTarget(r, 5, o),
        e.render(n, v),
        e.setRenderTarget(_, x, S),
        e.xr.enabled = E,
        r.texture.needsPMREMUpdate = !0
    }
}
class cg extends Dn {
    constructor(e=[], n=ks, r, o, l, u, f, m, p, v) {
        super(e, n, r, o, l, u, f, m, p, v),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class vv extends Yr {
    constructor(e=1, n={}) {
        super(e, e, n),
        this.isWebGLCubeRenderTarget = !0;
        const r = {
            width: e,
            height: e,
            depth: 1
        }
          , o = [r, r, r, r, r, r];
        this.texture = new cg(o),
        this._setTextureOptions(n),
        this.texture.isRenderTargetTexture = !0
    }
    fromEquirectangularTexture(e, n) {
        this.texture.type = n.type,
        this.texture.colorSpace = n.colorSpace,
        this.texture.generateMipmaps = n.generateMipmaps,
        this.texture.minFilter = n.minFilter,
        this.texture.magFilter = n.magFilter;
        const r = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , o = new Ha(5,5,5)
          , l = new vr({
            name: "CubemapFromEquirect",
            uniforms: Vs(r.uniforms),
            vertexShader: r.vertexShader,
            fragmentShader: r.fragmentShader,
            side: Nn,
            blending: mr
        });
        l.uniforms.tEquirect.value = n;
        const u = new fi(o,l)
          , f = n.minFilter;
        return n.minFilter === Wr && (n.minFilter = xi),
        new _v(1,10,this).update(e, u),
        n.minFilter = f,
        u.geometry.dispose(),
        u.material.dispose(),
        this
    }
    clear(e, n=!0, r=!0, o=!0) {
        const l = e.getRenderTarget();
        for (let u = 0; u < 6; u++)
            e.setRenderTarget(this, u),
            e.clear(n, r, o);
        e.setRenderTarget(l)
    }
}
class hl extends xn {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const xv = {
    type: "move"
};
class Hu {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new hl,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new hl,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new J,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new J),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new hl,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new J,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new J),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const n = this._hand;
            if (n)
                for (const r of e.hand.values())
                    this._getHandJoint(n, r)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, n, r) {
        let o = null
          , l = null
          , u = null;
        const f = this._targetRay
          , m = this._grip
          , p = this._hand;
        if (e && n.session.visibilityState !== "visible-blurred") {
            if (p && e.hand) {
                u = !0;
                for (const T of e.hand.values()) {
                    const y = n.getJointPose(T, r)
                      , g = this._getHandJoint(p, T);
                    y !== null && (g.matrix.fromArray(y.transform.matrix),
                    g.matrix.decompose(g.position, g.rotation, g.scale),
                    g.matrixWorldNeedsUpdate = !0,
                    g.jointRadius = y.radius),
                    g.visible = y !== null
                }
                const v = p.joints["index-finger-tip"]
                  , _ = p.joints["thumb-tip"]
                  , x = v.position.distanceTo(_.position)
                  , S = .02
                  , E = .005;
                p.inputState.pinching && x > S + E ? (p.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !p.inputState.pinching && x <= S - E && (p.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                m !== null && e.gripSpace && (l = n.getPose(e.gripSpace, r),
                l !== null && (m.matrix.fromArray(l.transform.matrix),
                m.matrix.decompose(m.position, m.rotation, m.scale),
                m.matrixWorldNeedsUpdate = !0,
                l.linearVelocity ? (m.hasLinearVelocity = !0,
                m.linearVelocity.copy(l.linearVelocity)) : m.hasLinearVelocity = !1,
                l.angularVelocity ? (m.hasAngularVelocity = !0,
                m.angularVelocity.copy(l.angularVelocity)) : m.hasAngularVelocity = !1));
            f !== null && (o = n.getPose(e.targetRaySpace, r),
            o === null && l !== null && (o = l),
            o !== null && (f.matrix.fromArray(o.transform.matrix),
            f.matrix.decompose(f.position, f.rotation, f.scale),
            f.matrixWorldNeedsUpdate = !0,
            o.linearVelocity ? (f.hasLinearVelocity = !0,
            f.linearVelocity.copy(o.linearVelocity)) : f.hasLinearVelocity = !1,
            o.angularVelocity ? (f.hasAngularVelocity = !0,
            f.angularVelocity.copy(o.angularVelocity)) : f.hasAngularVelocity = !1,
            this.dispatchEvent(xv)))
        }
        return f !== null && (f.visible = o !== null),
        m !== null && (m.visible = l !== null),
        p !== null && (p.visible = u !== null),
        this
    }
    _getHandJoint(e, n) {
        if (e.joints[n.jointName] === void 0) {
            const r = new hl;
            r.matrixAutoUpdate = !1,
            r.visible = !1,
            e.joints[n.jointName] = r,
            e.add(r)
        }
        return e.joints[n.jointName]
    }
}
class yv extends xn {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new wi,
        this.environmentIntensity = 1,
        this.environmentRotation = new wi,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, n) {
        return super.copy(e, n),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return this.fog !== null && (n.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity),
        n.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity),
        n.object.environmentRotation = this.environmentRotation.toArray(),
        n
    }
}
const Vu = new J
  , Sv = new J
  , wv = new ut;
class Br {
    constructor(e=new J(1,0,0), n=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = n
    }
    set(e, n) {
        return this.normal.copy(e),
        this.constant = n,
        this
    }
    setComponents(e, n, r, o) {
        return this.normal.set(e, n, r),
        this.constant = o,
        this
    }
    setFromNormalAndCoplanarPoint(e, n) {
        return this.normal.copy(e),
        this.constant = -n.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, n, r) {
        const o = Vu.subVectors(r, n).cross(Sv.subVectors(e, n)).normalize();
        return this.setFromNormalAndCoplanarPoint(o, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, n) {
        return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, n) {
        const r = e.delta(Vu)
          , o = this.normal.dot(r);
        if (o === 0)
            return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
        const l = -(e.start.dot(this.normal) + this.constant) / o;
        return l < 0 || l > 1 ? null : n.copy(e.start).addScaledVector(r, l)
    }
    intersectsLine(e) {
        const n = this.distanceToPoint(e.start)
          , r = this.distanceToPoint(e.end);
        return n < 0 && r > 0 || r < 0 && n > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, n) {
        const r = n || wv.getNormalMatrix(e)
          , o = this.coplanarPoint(Vu).applyMatrix4(e)
          , l = this.normal.applyMatrix3(r).normalize();
        return this.constant = -o.dot(l),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Or = new Ba
  , Mv = new vt(.5,.5)
  , pl = new J;
class Kd {
    constructor(e=new Br, n=new Br, r=new Br, o=new Br, l=new Br, u=new Br) {
        this.planes = [e, n, r, o, l, u]
    }
    set(e, n, r, o, l, u) {
        const f = this.planes;
        return f[0].copy(e),
        f[1].copy(n),
        f[2].copy(r),
        f[3].copy(o),
        f[4].copy(l),
        f[5].copy(u),
        this
    }
    copy(e) {
        const n = this.planes;
        for (let r = 0; r < 6; r++)
            n[r].copy(e.planes[r]);
        return this
    }
    setFromProjectionMatrix(e, n=yi, r=!1) {
        const o = this.planes
          , l = e.elements
          , u = l[0]
          , f = l[1]
          , m = l[2]
          , p = l[3]
          , v = l[4]
          , _ = l[5]
          , x = l[6]
          , S = l[7]
          , E = l[8]
          , T = l[9]
          , y = l[10]
          , g = l[11]
          , N = l[12]
          , L = l[13]
          , C = l[14]
          , H = l[15];
        if (o[0].setComponents(p - u, S - v, g - E, H - N).normalize(),
        o[1].setComponents(p + u, S + v, g + E, H + N).normalize(),
        o[2].setComponents(p + f, S + _, g + T, H + L).normalize(),
        o[3].setComponents(p - f, S - _, g - T, H - L).normalize(),
        r)
            o[4].setComponents(m, x, y, C).normalize(),
            o[5].setComponents(p - m, S - x, g - y, H - C).normalize();
        else if (o[4].setComponents(p - m, S - x, g - y, H - C).normalize(),
        n === yi)
            o[5].setComponents(p + m, S + x, g + y, H + C).normalize();
        else if (n === bl)
            o[5].setComponents(m, x, y, C).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            Or.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const n = e.geometry;
            n.boundingSphere === null && n.computeBoundingSphere(),
            Or.copy(n.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Or)
    }
    intersectsSprite(e) {
        Or.center.set(0, 0, 0);
        const n = Mv.distanceTo(e.center);
        return Or.radius = .7071067811865476 + n,
        Or.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Or)
    }
    intersectsSphere(e) {
        const n = this.planes
          , r = e.center
          , o = -e.radius;
        for (let l = 0; l < 6; l++)
            if (n[l].distanceToPoint(r) < o)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const n = this.planes;
        for (let r = 0; r < 6; r++) {
            const o = n[r];
            if (pl.x = o.normal.x > 0 ? e.max.x : e.min.x,
            pl.y = o.normal.y > 0 ? e.max.y : e.min.y,
            pl.z = o.normal.z > 0 ? e.max.z : e.min.z,
            o.distanceToPoint(pl) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const n = this.planes;
        for (let r = 0; r < 6; r++)
            if (n[r].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class ug extends Jr {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new mt(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const Pl = new J
  , Nl = new J
  , rm = new Vt
  , ba = new $d
  , ml = new Ba
  , ju = new J
  , sm = new J;
class Ev extends xn {
    constructor(e=new Un, n=new ug) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = n,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, n) {
        return super.copy(e, n),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const n = e.attributes.position
              , r = [0];
            for (let o = 1, l = n.count; o < l; o++)
                Pl.fromBufferAttribute(n, o - 1),
                Nl.fromBufferAttribute(n, o),
                r[o] = r[o - 1],
                r[o] += Pl.distanceTo(Nl);
            e.setAttribute("lineDistance", new cn(r,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, n) {
        const r = this.geometry
          , o = this.matrixWorld
          , l = e.params.Line.threshold
          , u = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(),
        ml.copy(r.boundingSphere),
        ml.applyMatrix4(o),
        ml.radius += l,
        e.ray.intersectsSphere(ml) === !1)
            return;
        rm.copy(o).invert(),
        ba.copy(e.ray).applyMatrix4(rm);
        const f = l / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , m = f * f
          , p = this.isLineSegments ? 2 : 1
          , v = r.index
          , x = r.attributes.position;
        if (v !== null) {
            const S = Math.max(0, u.start)
              , E = Math.min(v.count, u.start + u.count);
            for (let T = S, y = E - 1; T < y; T += p) {
                const g = v.getX(T)
                  , N = v.getX(T + 1)
                  , L = gl(this, e, ba, m, g, N, T);
                L && n.push(L)
            }
            if (this.isLineLoop) {
                const T = v.getX(E - 1)
                  , y = v.getX(S)
                  , g = gl(this, e, ba, m, T, y, E - 1);
                g && n.push(g)
            }
        } else {
            const S = Math.max(0, u.start)
              , E = Math.min(x.count, u.start + u.count);
            for (let T = S, y = E - 1; T < y; T += p) {
                const g = gl(this, e, ba, m, T, T + 1, T);
                g && n.push(g)
            }
            if (this.isLineLoop) {
                const T = gl(this, e, ba, m, E - 1, S, E - 1);
                T && n.push(T)
            }
        }
    }
    updateMorphTargets() {
        const n = this.geometry.morphAttributes
          , r = Object.keys(n);
        if (r.length > 0) {
            const o = n[r[0]];
            if (o !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let l = 0, u = o.length; l < u; l++) {
                    const f = o[l].name || String(l);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[f] = l
                }
            }
        }
    }
}
function gl(s, e, n, r, o, l, u) {
    const f = s.geometry.attributes.position;
    if (Pl.fromBufferAttribute(f, o),
    Nl.fromBufferAttribute(f, l),
    n.distanceSqToSegment(Pl, Nl, ju, sm) > r)
        return;
    ju.applyMatrix4(s.matrixWorld);
    const p = e.ray.origin.distanceTo(ju);
    if (!(p < e.near || p > e.far))
        return {
            distance: p,
            point: sm.clone().applyMatrix4(s.matrixWorld),
            index: u,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: s
        }
}
const am = new J
  , om = new J;
class Tv extends Ev {
    constructor(e, n) {
        super(e, n),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const n = e.attributes.position
              , r = [];
            for (let o = 0, l = n.count; o < l; o += 2)
                am.fromBufferAttribute(n, o),
                om.fromBufferAttribute(n, o + 1),
                r[o] = o === 0 ? 0 : r[o - 1],
                r[o + 1] = r[o] + am.distanceTo(om);
            e.setAttribute("lineDistance", new cn(r,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class zd extends Jr {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new mt(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const lm = new Vt
  , kd = new $d
  , _l = new Ba
  , vl = new J;
class cm extends xn {
    constructor(e=new Un, n=new zd) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = n,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, n) {
        return super.copy(e, n),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, n) {
        const r = this.geometry
          , o = this.matrixWorld
          , l = e.params.Points.threshold
          , u = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(),
        _l.copy(r.boundingSphere),
        _l.applyMatrix4(o),
        _l.radius += l,
        e.ray.intersectsSphere(_l) === !1)
            return;
        lm.copy(o).invert(),
        kd.copy(e.ray).applyMatrix4(lm);
        const f = l / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , m = f * f
          , p = r.index
          , _ = r.attributes.position;
        if (p !== null) {
            const x = Math.max(0, u.start)
              , S = Math.min(p.count, u.start + u.count);
            for (let E = x, T = S; E < T; E++) {
                const y = p.getX(E);
                vl.fromBufferAttribute(_, y),
                um(vl, y, m, o, e, n, this)
            }
        } else {
            const x = Math.max(0, u.start)
              , S = Math.min(_.count, u.start + u.count);
            for (let E = x, T = S; E < T; E++)
                vl.fromBufferAttribute(_, E),
                um(vl, E, m, o, e, n, this)
        }
    }
    updateMorphTargets() {
        const n = this.geometry.morphAttributes
          , r = Object.keys(n);
        if (r.length > 0) {
            const o = n[r[0]];
            if (o !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let l = 0, u = o.length; l < u; l++) {
                    const f = o[l].name || String(l);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[f] = l
                }
            }
        }
    }
}
function um(s, e, n, r, o, l, u) {
    const f = kd.distanceSqToPoint(s);
    if (f < n) {
        const m = new J;
        kd.closestPointToPoint(s, m),
        m.applyMatrix4(r);
        const p = o.ray.origin.distanceTo(m);
        if (p < o.near || p > o.far)
            return;
        l.push({
            distance: p,
            distanceToRay: Math.sqrt(f),
            point: m,
            index: e,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: u
        })
    }
}
class dg extends Dn {
    constructor(e, n, r=Xr, o, l, u, f=hi, m=hi, p, v=Ia, _=1) {
        if (v !== Ia && v !== Ua)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        const x = {
            width: e,
            height: n,
            depth: _
        };
        super(x, o, l, u, f, m, v, r, p),
        this.isDepthTexture = !0,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.source = new qd(Object.assign({}, e.image)),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return this.compareFunction !== null && (n.compareFunction = this.compareFunction),
        n
    }
}
class Qd extends Un {
    constructor(e=[], n=[], r=1, o=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: n,
            radius: r,
            detail: o
        };
        const l = []
          , u = [];
        f(o),
        p(r),
        v(),
        this.setAttribute("position", new cn(l,3)),
        this.setAttribute("normal", new cn(l.slice(),3)),
        this.setAttribute("uv", new cn(u,2)),
        o === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function f(N) {
            const L = new J
              , C = new J
              , H = new J;
            for (let k = 0; k < n.length; k += 3)
                S(n[k + 0], L),
                S(n[k + 1], C),
                S(n[k + 2], H),
                m(L, C, H, N)
        }
        function m(N, L, C, H) {
            const k = H + 1
              , F = [];
            for (let j = 0; j <= k; j++) {
                F[j] = [];
                const b = N.clone().lerp(C, j / k)
                  , R = L.clone().lerp(C, j / k)
                  , I = k - j;
                for (let oe = 0; oe <= I; oe++)
                    oe === 0 && j === k ? F[j][oe] = b : F[j][oe] = b.clone().lerp(R, oe / I)
            }
            for (let j = 0; j < k; j++)
                for (let b = 0; b < 2 * (k - j) - 1; b++) {
                    const R = Math.floor(b / 2);
                    b % 2 === 0 ? (x(F[j][R + 1]),
                    x(F[j + 1][R]),
                    x(F[j][R])) : (x(F[j][R + 1]),
                    x(F[j + 1][R + 1]),
                    x(F[j + 1][R]))
                }
        }
        function p(N) {
            const L = new J;
            for (let C = 0; C < l.length; C += 3)
                L.x = l[C + 0],
                L.y = l[C + 1],
                L.z = l[C + 2],
                L.normalize().multiplyScalar(N),
                l[C + 0] = L.x,
                l[C + 1] = L.y,
                l[C + 2] = L.z
        }
        function v() {
            const N = new J;
            for (let L = 0; L < l.length; L += 3) {
                N.x = l[L + 0],
                N.y = l[L + 1],
                N.z = l[L + 2];
                const C = y(N) / 2 / Math.PI + .5
                  , H = g(N) / Math.PI + .5;
                u.push(C, 1 - H)
            }
            E(),
            _()
        }
        function _() {
            for (let N = 0; N < u.length; N += 6) {
                const L = u[N + 0]
                  , C = u[N + 2]
                  , H = u[N + 4]
                  , k = Math.max(L, C, H)
                  , F = Math.min(L, C, H);
                k > .9 && F < .1 && (L < .2 && (u[N + 0] += 1),
                C < .2 && (u[N + 2] += 1),
                H < .2 && (u[N + 4] += 1))
            }
        }
        function x(N) {
            l.push(N.x, N.y, N.z)
        }
        function S(N, L) {
            const C = N * 3;
            L.x = e[C + 0],
            L.y = e[C + 1],
            L.z = e[C + 2]
        }
        function E() {
            const N = new J
              , L = new J
              , C = new J
              , H = new J
              , k = new vt
              , F = new vt
              , j = new vt;
            for (let b = 0, R = 0; b < l.length; b += 9,
            R += 6) {
                N.set(l[b + 0], l[b + 1], l[b + 2]),
                L.set(l[b + 3], l[b + 4], l[b + 5]),
                C.set(l[b + 6], l[b + 7], l[b + 8]),
                k.set(u[R + 0], u[R + 1]),
                F.set(u[R + 2], u[R + 3]),
                j.set(u[R + 4], u[R + 5]),
                H.copy(N).add(L).add(C).divideScalar(3);
                const I = y(H);
                T(k, R + 0, N, I),
                T(F, R + 2, L, I),
                T(j, R + 4, C, I)
            }
        }
        function T(N, L, C, H) {
            H < 0 && N.x === 1 && (u[L] = N.x - 1),
            C.x === 0 && C.z === 0 && (u[L] = H / 2 / Math.PI + .5)
        }
        function y(N) {
            return Math.atan2(N.z, -N.x)
        }
        function g(N) {
            return Math.atan2(-N.y, Math.sqrt(N.x * N.x + N.z * N.z))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Qd(e.vertices,e.indices,e.radius,e.details)
    }
}
class Zd extends Qd {
    constructor(e=1, n=0) {
        const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
          , o = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(r, o, e, n),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: n
        }
    }
    static fromJSON(e) {
        return new Zd(e.radius,e.detail)
    }
}
class Il extends Un {
    constructor(e=1, n=1, r=1, o=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: n,
            widthSegments: r,
            heightSegments: o
        };
        const l = e / 2
          , u = n / 2
          , f = Math.floor(r)
          , m = Math.floor(o)
          , p = f + 1
          , v = m + 1
          , _ = e / f
          , x = n / m
          , S = []
          , E = []
          , T = []
          , y = [];
        for (let g = 0; g < v; g++) {
            const N = g * x - u;
            for (let L = 0; L < p; L++) {
                const C = L * _ - l;
                E.push(C, -N, 0),
                T.push(0, 0, 1),
                y.push(L / f),
                y.push(1 - g / m)
            }
        }
        for (let g = 0; g < m; g++)
            for (let N = 0; N < f; N++) {
                const L = N + p * g
                  , C = N + p * (g + 1)
                  , H = N + 1 + p * (g + 1)
                  , k = N + 1 + p * g;
                S.push(L, C, k),
                S.push(C, H, k)
            }
        this.setIndex(S),
        this.setAttribute("position", new cn(E,3)),
        this.setAttribute("normal", new cn(T,3)),
        this.setAttribute("uv", new cn(y,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Il(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
class ef extends Un {
    constructor(e=1, n=.4, r=12, o=48, l=Math.PI * 2) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: n,
            radialSegments: r,
            tubularSegments: o,
            arc: l
        },
        r = Math.floor(r),
        o = Math.floor(o);
        const u = []
          , f = []
          , m = []
          , p = []
          , v = new J
          , _ = new J
          , x = new J;
        for (let S = 0; S <= r; S++)
            for (let E = 0; E <= o; E++) {
                const T = E / o * l
                  , y = S / r * Math.PI * 2;
                _.x = (e + n * Math.cos(y)) * Math.cos(T),
                _.y = (e + n * Math.cos(y)) * Math.sin(T),
                _.z = n * Math.sin(y),
                f.push(_.x, _.y, _.z),
                v.x = e * Math.cos(T),
                v.y = e * Math.sin(T),
                x.subVectors(_, v).normalize(),
                m.push(x.x, x.y, x.z),
                p.push(E / o),
                p.push(S / r)
            }
        for (let S = 1; S <= r; S++)
            for (let E = 1; E <= o; E++) {
                const T = (o + 1) * S + E - 1
                  , y = (o + 1) * (S - 1) + E - 1
                  , g = (o + 1) * (S - 1) + E
                  , N = (o + 1) * S + E;
                u.push(T, y, N),
                u.push(y, g, N)
            }
        this.setIndex(u),
        this.setAttribute("position", new cn(f,3)),
        this.setAttribute("normal", new cn(m,3)),
        this.setAttribute("uv", new cn(p,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new ef(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class dm extends Jr {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.type = "MeshStandardMaterial",
        this.defines = {
            STANDARD: ""
        },
        this.color = new mt(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new mt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Qm,
        this.normalScale = new vt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new wi,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class Av extends Jr {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = O_,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class Cv extends Jr {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
class fg extends xn {
    constructor(e, n=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new mt(e),
        this.intensity = n
    }
    dispose() {}
    copy(e, n) {
        return super.copy(e, n),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.object.color = this.color.getHex(),
        n.object.intensity = this.intensity,
        this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (n.object.distance = this.distance),
        this.angle !== void 0 && (n.object.angle = this.angle),
        this.decay !== void 0 && (n.object.decay = this.decay),
        this.penumbra !== void 0 && (n.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()),
        this.target !== void 0 && (n.object.target = this.target.uuid),
        n
    }
}
const Gu = new Vt
  , fm = new J
  , hm = new J;
class Rv {
    constructor(e) {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new vt(512,512),
        this.mapType = Si,
        this.map = null,
        this.mapPass = null,
        this.matrix = new Vt,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Kd,
        this._frameExtents = new vt(1,1),
        this._viewportCount = 1,
        this._viewports = [new Pt(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const n = this.camera
          , r = this.matrix;
        fm.setFromMatrixPosition(e.matrixWorld),
        n.position.copy(fm),
        hm.setFromMatrixPosition(e.target.matrixWorld),
        n.lookAt(hm),
        n.updateMatrixWorld(),
        Gu.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Gu, n.coordinateSystem, n.reversedDepth),
        n.reversedDepth ? r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        r.multiply(Gu)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.intensity = e.intensity,
        this.bias = e.bias,
        this.radius = e.radius,
        this.autoUpdate = e.autoUpdate,
        this.needsUpdate = e.needsUpdate,
        this.normalBias = e.normalBias,
        this.blurSamples = e.blurSamples,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity),
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
const pm = new Vt
  , La = new J
  , Wu = new J;
class bv extends Rv {
    constructor() {
        super(new jn(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new vt(4,2),
        this._viewportCount = 6,
        this._viewports = [new Pt(2,1,1,1), new Pt(0,1,1,1), new Pt(3,1,1,1), new Pt(1,1,1,1), new Pt(3,0,1,1), new Pt(1,0,1,1)],
        this._cubeDirections = [new J(1,0,0), new J(-1,0,0), new J(0,0,1), new J(0,0,-1), new J(0,1,0), new J(0,-1,0)],
        this._cubeUps = [new J(0,1,0), new J(0,1,0), new J(0,1,0), new J(0,1,0), new J(0,0,1), new J(0,0,-1)]
    }
    updateMatrices(e, n=0) {
        const r = this.camera
          , o = this.matrix
          , l = e.distance || r.far;
        l !== r.far && (r.far = l,
        r.updateProjectionMatrix()),
        La.setFromMatrixPosition(e.matrixWorld),
        r.position.copy(La),
        Wu.copy(r.position),
        Wu.add(this._cubeDirections[n]),
        r.up.copy(this._cubeUps[n]),
        r.lookAt(Wu),
        r.updateMatrixWorld(),
        o.makeTranslation(-La.x, -La.y, -La.z),
        pm.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(pm, r.coordinateSystem, r.reversedDepth)
    }
}
class mm extends fg {
    constructor(e, n, r=0, o=2) {
        super(e, n),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = r,
        this.decay = o,
        this.shadow = new bv
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, n) {
        return super.copy(e, n),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class Lv extends lg {
    constructor(e=-1, n=1, r=1, o=-1, l=.1, u=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = n,
        this.top = r,
        this.bottom = o,
        this.near = l,
        this.far = u,
        this.updateProjectionMatrix()
    }
    copy(e, n) {
        return super.copy(e, n),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, n, r, o, l, u) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = n,
        this.view.offsetX = r,
        this.view.offsetY = o,
        this.view.width = l,
        this.view.height = u,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , n = (this.top - this.bottom) / (2 * this.zoom)
          , r = (this.right + this.left) / 2
          , o = (this.top + this.bottom) / 2;
        let l = r - e
          , u = r + e
          , f = o + n
          , m = o - n;
        if (this.view !== null && this.view.enabled) {
            const p = (this.right - this.left) / this.view.fullWidth / this.zoom
              , v = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            l += p * this.view.offsetX,
            u = l + p * this.view.width,
            f -= v * this.view.offsetY,
            m = f - v * this.view.height
        }
        this.projectionMatrix.makeOrthographic(l, u, f, m, this.near, this.far, this.coordinateSystem, this.reversedDepth),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const n = super.toJSON(e);
        return n.object.zoom = this.zoom,
        n.object.left = this.left,
        n.object.right = this.right,
        n.object.top = this.top,
        n.object.bottom = this.bottom,
        n.object.near = this.near,
        n.object.far = this.far,
        this.view !== null && (n.object.view = Object.assign({}, this.view)),
        n
    }
}
class Pv extends fg {
    constructor(e, n) {
        super(e, n),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class Nv extends jn {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.isMultiViewCamera = !1,
        this.cameras = e
    }
}
class Dv extends Tv {
    constructor(e=10, n=10, r=4473924, o=8947848) {
        r = new mt(r),
        o = new mt(o);
        const l = n / 2
          , u = e / n
          , f = e / 2
          , m = []
          , p = [];
        for (let x = 0, S = 0, E = -f; x <= n; x++,
        E += u) {
            m.push(-f, 0, E, f, 0, E),
            m.push(E, 0, -f, E, 0, f);
            const T = x === l ? r : o;
            T.toArray(p, S),
            S += 3,
            T.toArray(p, S),
            S += 3,
            T.toArray(p, S),
            S += 3,
            T.toArray(p, S),
            S += 3
        }
        const v = new Un;
        v.setAttribute("position", new cn(m,3)),
        v.setAttribute("color", new cn(p,3));
        const _ = new ug({
            vertexColors: !0,
            toneMapped: !1
        });
        super(v, _),
        this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function gm(s, e, n, r) {
    const o = Iv(r);
    switch (n) {
    case Ym:
        return s * e;
    case qm:
        return s * e / o.components * o.byteLength;
    case Xd:
        return s * e / o.components * o.byteLength;
    case $m:
        return s * e * 2 / o.components * o.byteLength;
    case Yd:
        return s * e * 2 / o.components * o.byteLength;
    case Jm:
        return s * e * 3 / o.components * o.byteLength;
    case di:
        return s * e * 4 / o.components * o.byteLength;
    case Jd:
        return s * e * 4 / o.components * o.byteLength;
    case wl:
    case Ml:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case El:
    case Tl:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case fd:
    case pd:
        return Math.max(s, 16) * Math.max(e, 8) / 4;
    case dd:
    case hd:
        return Math.max(s, 8) * Math.max(e, 8) / 2;
    case md:
    case gd:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case _d:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case vd:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case xd:
        return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case yd:
        return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Sd:
        return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case wd:
        return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Md:
        return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Ed:
        return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Td:
        return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Ad:
        return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Cd:
        return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Rd:
        return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case bd:
        return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Ld:
        return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Pd:
        return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Al:
    case Nd:
    case Dd:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case Km:
    case Id:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case Ud:
    case Fd:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${n} format.`)
}
function Iv(s) {
    switch (s) {
    case Si:
    case Gm:
        return {
            byteLength: 1,
            components: 1
        };
    case Na:
    case Wm:
    case Fa:
        return {
            byteLength: 2,
            components: 1
        };
    case Gd:
    case Wd:
        return {
            byteLength: 2,
            components: 4
        };
    case Xr:
    case jd:
    case Bi:
        return {
            byteLength: 4,
            components: 1
        };
    case Xm:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${s}.`)
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: Vd
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Vd);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function hg() {
    let s = null
      , e = !1
      , n = null
      , r = null;
    function o(l, u) {
        n(l, u),
        r = s.requestAnimationFrame(o)
    }
    return {
        start: function() {
            e !== !0 && n !== null && (r = s.requestAnimationFrame(o),
            e = !0)
        },
        stop: function() {
            s.cancelAnimationFrame(r),
            e = !1
        },
        setAnimationLoop: function(l) {
            n = l
        },
        setContext: function(l) {
            s = l
        }
    }
}
function Uv(s) {
    const e = new WeakMap;
    function n(f, m) {
        const p = f.array
          , v = f.usage
          , _ = p.byteLength
          , x = s.createBuffer();
        s.bindBuffer(m, x),
        s.bufferData(m, p, v),
        f.onUploadCallback();
        let S;
        if (p instanceof Float32Array)
            S = s.FLOAT;
        else if (typeof Float16Array < "u" && p instanceof Float16Array)
            S = s.HALF_FLOAT;
        else if (p instanceof Uint16Array)
            f.isFloat16BufferAttribute ? S = s.HALF_FLOAT : S = s.UNSIGNED_SHORT;
        else if (p instanceof Int16Array)
            S = s.SHORT;
        else if (p instanceof Uint32Array)
            S = s.UNSIGNED_INT;
        else if (p instanceof Int32Array)
            S = s.INT;
        else if (p instanceof Int8Array)
            S = s.BYTE;
        else if (p instanceof Uint8Array)
            S = s.UNSIGNED_BYTE;
        else if (p instanceof Uint8ClampedArray)
            S = s.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + p);
        return {
            buffer: x,
            type: S,
            bytesPerElement: p.BYTES_PER_ELEMENT,
            version: f.version,
            size: _
        }
    }
    function r(f, m, p) {
        const v = m.array
          , _ = m.updateRanges;
        if (s.bindBuffer(p, f),
        _.length === 0)
            s.bufferSubData(p, 0, v);
        else {
            _.sort( (S, E) => S.start - E.start);
            let x = 0;
            for (let S = 1; S < _.length; S++) {
                const E = _[x]
                  , T = _[S];
                T.start <= E.start + E.count + 1 ? E.count = Math.max(E.count, T.start + T.count - E.start) : (++x,
                _[x] = T)
            }
            _.length = x + 1;
            for (let S = 0, E = _.length; S < E; S++) {
                const T = _[S];
                s.bufferSubData(p, T.start * v.BYTES_PER_ELEMENT, v, T.start, T.count)
            }
            m.clearUpdateRanges()
        }
        m.onUploadCallback()
    }
    function o(f) {
        return f.isInterleavedBufferAttribute && (f = f.data),
        e.get(f)
    }
    function l(f) {
        f.isInterleavedBufferAttribute && (f = f.data);
        const m = e.get(f);
        m && (s.deleteBuffer(m.buffer),
        e.delete(f))
    }
    function u(f, m) {
        if (f.isInterleavedBufferAttribute && (f = f.data),
        f.isGLBufferAttribute) {
            const v = e.get(f);
            (!v || v.version < f.version) && e.set(f, {
                buffer: f.buffer,
                type: f.type,
                bytesPerElement: f.elementSize,
                version: f.version
            });
            return
        }
        const p = e.get(f);
        if (p === void 0)
            e.set(f, n(f, m));
        else if (p.version < f.version) {
            if (p.size !== f.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            r(p.buffer, f, m),
            p.version = f.version
        }
    }
    return {
        get: o,
        remove: l,
        update: u
    }
}
var Fv = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , Ov = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , zv = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , kv = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , Bv = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , Hv = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , Vv = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , jv = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , Gv = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , Wv = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , Xv = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , Yv = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , Jv = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , qv = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , $v = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , Kv = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , Qv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , Zv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , ex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , tx = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , nx = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , ix = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , rx = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , sx = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , ax = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , ox = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , lx = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , cx = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , ux = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , dx = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , fx = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , hx = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , px = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , mx = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , gx = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , _x = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , vx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , xx = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , yx = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , Sx = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , wx = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , Mx = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , Ex = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , Tx = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , Ax = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , Cx = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , Rx = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , bx = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , Lx = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , Px = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , Nx = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , Dx = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , Ix = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , Ux = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , Fx = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , Ox = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , zx = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , kx = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , Bx = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , Hx = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , Vx = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , jx = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , Gx = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , Wx = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , Xx = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , Yx = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , Jx = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , qx = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , $x = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , Kx = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , Qx = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , Zx = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , ey = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , ty = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , ny = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , iy = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , ry = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , sy = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , ay = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , oy = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , ly = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , cy = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , uy = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , dy = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , fy = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , hy = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , py = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , my = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , gy = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , _y = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSEDEPTHBUF
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSEDEPTHBUF
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare , distribution.x );
		#endif
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , vy = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , xy = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , yy = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , Sy = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , wy = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , My = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , Ey = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , Ty = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , Ay = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , Cy = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , Ry = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , by = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , Ly = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , Py = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , Ny = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , Dy = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , Iy = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Uy = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , Fy = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , Oy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , zy = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , ky = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , By = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , Hy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , Vy = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSEDEPTHBUF
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`
  , jy = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , Gy = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , Wy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , Xy = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , Yy = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , Jy = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , qy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , $y = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
    #include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , Ky = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , Qy = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , Zy = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , eS = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , tS = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , nS = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , iS = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , rS = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , sS = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , aS = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , oS = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , lS = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , cS = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , uS = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , dS = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , fS = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , hS = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , pS = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , dt = {
    alphahash_fragment: Fv,
    alphahash_pars_fragment: Ov,
    alphamap_fragment: zv,
    alphamap_pars_fragment: kv,
    alphatest_fragment: Bv,
    alphatest_pars_fragment: Hv,
    aomap_fragment: Vv,
    aomap_pars_fragment: jv,
    batching_pars_vertex: Gv,
    batching_vertex: Wv,
    begin_vertex: Xv,
    beginnormal_vertex: Yv,
    bsdfs: Jv,
    iridescence_fragment: qv,
    bumpmap_pars_fragment: $v,
    clipping_planes_fragment: Kv,
    clipping_planes_pars_fragment: Qv,
    clipping_planes_pars_vertex: Zv,
    clipping_planes_vertex: ex,
    color_fragment: tx,
    color_pars_fragment: nx,
    color_pars_vertex: ix,
    color_vertex: rx,
    common: sx,
    cube_uv_reflection_fragment: ax,
    defaultnormal_vertex: ox,
    displacementmap_pars_vertex: lx,
    displacementmap_vertex: cx,
    emissivemap_fragment: ux,
    emissivemap_pars_fragment: dx,
    colorspace_fragment: fx,
    colorspace_pars_fragment: hx,
    envmap_fragment: px,
    envmap_common_pars_fragment: mx,
    envmap_pars_fragment: gx,
    envmap_pars_vertex: _x,
    envmap_physical_pars_fragment: Rx,
    envmap_vertex: vx,
    fog_vertex: xx,
    fog_pars_vertex: yx,
    fog_fragment: Sx,
    fog_pars_fragment: wx,
    gradientmap_pars_fragment: Mx,
    lightmap_pars_fragment: Ex,
    lights_lambert_fragment: Tx,
    lights_lambert_pars_fragment: Ax,
    lights_pars_begin: Cx,
    lights_toon_fragment: bx,
    lights_toon_pars_fragment: Lx,
    lights_phong_fragment: Px,
    lights_phong_pars_fragment: Nx,
    lights_physical_fragment: Dx,
    lights_physical_pars_fragment: Ix,
    lights_fragment_begin: Ux,
    lights_fragment_maps: Fx,
    lights_fragment_end: Ox,
    logdepthbuf_fragment: zx,
    logdepthbuf_pars_fragment: kx,
    logdepthbuf_pars_vertex: Bx,
    logdepthbuf_vertex: Hx,
    map_fragment: Vx,
    map_pars_fragment: jx,
    map_particle_fragment: Gx,
    map_particle_pars_fragment: Wx,
    metalnessmap_fragment: Xx,
    metalnessmap_pars_fragment: Yx,
    morphinstance_vertex: Jx,
    morphcolor_vertex: qx,
    morphnormal_vertex: $x,
    morphtarget_pars_vertex: Kx,
    morphtarget_vertex: Qx,
    normal_fragment_begin: Zx,
    normal_fragment_maps: ey,
    normal_pars_fragment: ty,
    normal_pars_vertex: ny,
    normal_vertex: iy,
    normalmap_pars_fragment: ry,
    clearcoat_normal_fragment_begin: sy,
    clearcoat_normal_fragment_maps: ay,
    clearcoat_pars_fragment: oy,
    iridescence_pars_fragment: ly,
    opaque_fragment: cy,
    packing: uy,
    premultiplied_alpha_fragment: dy,
    project_vertex: fy,
    dithering_fragment: hy,
    dithering_pars_fragment: py,
    roughnessmap_fragment: my,
    roughnessmap_pars_fragment: gy,
    shadowmap_pars_fragment: _y,
    shadowmap_pars_vertex: vy,
    shadowmap_vertex: xy,
    shadowmask_pars_fragment: yy,
    skinbase_vertex: Sy,
    skinning_pars_vertex: wy,
    skinning_vertex: My,
    skinnormal_vertex: Ey,
    specularmap_fragment: Ty,
    specularmap_pars_fragment: Ay,
    tonemapping_fragment: Cy,
    tonemapping_pars_fragment: Ry,
    transmission_fragment: by,
    transmission_pars_fragment: Ly,
    uv_pars_fragment: Py,
    uv_pars_vertex: Ny,
    uv_vertex: Dy,
    worldpos_vertex: Iy,
    background_vert: Uy,
    background_frag: Fy,
    backgroundCube_vert: Oy,
    backgroundCube_frag: zy,
    cube_vert: ky,
    cube_frag: By,
    depth_vert: Hy,
    depth_frag: Vy,
    distanceRGBA_vert: jy,
    distanceRGBA_frag: Gy,
    equirect_vert: Wy,
    equirect_frag: Xy,
    linedashed_vert: Yy,
    linedashed_frag: Jy,
    meshbasic_vert: qy,
    meshbasic_frag: $y,
    meshlambert_vert: Ky,
    meshlambert_frag: Qy,
    meshmatcap_vert: Zy,
    meshmatcap_frag: eS,
    meshnormal_vert: tS,
    meshnormal_frag: nS,
    meshphong_vert: iS,
    meshphong_frag: rS,
    meshphysical_vert: sS,
    meshphysical_frag: aS,
    meshtoon_vert: oS,
    meshtoon_frag: lS,
    points_vert: cS,
    points_frag: uS,
    shadow_vert: dS,
    shadow_frag: fS,
    sprite_vert: hS,
    sprite_frag: pS
}
  , Le = {
    common: {
        diffuse: {
            value: new mt(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new ut
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new ut
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new ut
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new ut
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new ut
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new ut
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new ut
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new ut
        },
        normalScale: {
            value: new vt(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new ut
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new ut
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new ut
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new ut
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new mt(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new mt(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new ut
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new ut
        }
    },
    sprite: {
        diffuse: {
            value: new mt(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new vt(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new ut
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new ut
        },
        alphaTest: {
            value: 0
        }
    }
}
  , vi = {
    basic: {
        uniforms: En([Le.common, Le.specularmap, Le.envmap, Le.aomap, Le.lightmap, Le.fog]),
        vertexShader: dt.meshbasic_vert,
        fragmentShader: dt.meshbasic_frag
    },
    lambert: {
        uniforms: En([Le.common, Le.specularmap, Le.envmap, Le.aomap, Le.lightmap, Le.emissivemap, Le.bumpmap, Le.normalmap, Le.displacementmap, Le.fog, Le.lights, {
            emissive: {
                value: new mt(0)
            }
        }]),
        vertexShader: dt.meshlambert_vert,
        fragmentShader: dt.meshlambert_frag
    },
    phong: {
        uniforms: En([Le.common, Le.specularmap, Le.envmap, Le.aomap, Le.lightmap, Le.emissivemap, Le.bumpmap, Le.normalmap, Le.displacementmap, Le.fog, Le.lights, {
            emissive: {
                value: new mt(0)
            },
            specular: {
                value: new mt(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: dt.meshphong_vert,
        fragmentShader: dt.meshphong_frag
    },
    standard: {
        uniforms: En([Le.common, Le.envmap, Le.aomap, Le.lightmap, Le.emissivemap, Le.bumpmap, Le.normalmap, Le.displacementmap, Le.roughnessmap, Le.metalnessmap, Le.fog, Le.lights, {
            emissive: {
                value: new mt(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: dt.meshphysical_vert,
        fragmentShader: dt.meshphysical_frag
    },
    toon: {
        uniforms: En([Le.common, Le.aomap, Le.lightmap, Le.emissivemap, Le.bumpmap, Le.normalmap, Le.displacementmap, Le.gradientmap, Le.fog, Le.lights, {
            emissive: {
                value: new mt(0)
            }
        }]),
        vertexShader: dt.meshtoon_vert,
        fragmentShader: dt.meshtoon_frag
    },
    matcap: {
        uniforms: En([Le.common, Le.bumpmap, Le.normalmap, Le.displacementmap, Le.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: dt.meshmatcap_vert,
        fragmentShader: dt.meshmatcap_frag
    },
    points: {
        uniforms: En([Le.points, Le.fog]),
        vertexShader: dt.points_vert,
        fragmentShader: dt.points_frag
    },
    dashed: {
        uniforms: En([Le.common, Le.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: dt.linedashed_vert,
        fragmentShader: dt.linedashed_frag
    },
    depth: {
        uniforms: En([Le.common, Le.displacementmap]),
        vertexShader: dt.depth_vert,
        fragmentShader: dt.depth_frag
    },
    normal: {
        uniforms: En([Le.common, Le.bumpmap, Le.normalmap, Le.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: dt.meshnormal_vert,
        fragmentShader: dt.meshnormal_frag
    },
    sprite: {
        uniforms: En([Le.sprite, Le.fog]),
        vertexShader: dt.sprite_vert,
        fragmentShader: dt.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new ut
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: dt.background_vert,
        fragmentShader: dt.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new ut
            }
        },
        vertexShader: dt.backgroundCube_vert,
        fragmentShader: dt.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: dt.cube_vert,
        fragmentShader: dt.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: dt.equirect_vert,
        fragmentShader: dt.equirect_frag
    },
    distanceRGBA: {
        uniforms: En([Le.common, Le.displacementmap, {
            referencePosition: {
                value: new J
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: dt.distanceRGBA_vert,
        fragmentShader: dt.distanceRGBA_frag
    },
    shadow: {
        uniforms: En([Le.lights, Le.fog, {
            color: {
                value: new mt(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: dt.shadow_vert,
        fragmentShader: dt.shadow_frag
    }
};
vi.physical = {
    uniforms: En([vi.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new ut
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new ut
        },
        clearcoatNormalScale: {
            value: new vt(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new ut
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new ut
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new ut
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new mt(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new ut
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new ut
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new ut
        },
        transmissionSamplerSize: {
            value: new vt
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new ut
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new mt(0)
        },
        specularColor: {
            value: new mt(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new ut
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new ut
        },
        anisotropyVector: {
            value: new vt
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new ut
        }
    }]),
    vertexShader: dt.meshphysical_vert,
    fragmentShader: dt.meshphysical_frag
};
const xl = {
    r: 0,
    b: 0,
    g: 0
}
  , zr = new wi
  , mS = new Vt;
function gS(s, e, n, r, o, l, u) {
    const f = new mt(0);
    let m = l === !0 ? 0 : 1, p, v, _ = null, x = 0, S = null;
    function E(L) {
        let C = L.isScene === !0 ? L.background : null;
        return C && C.isTexture && (C = (L.backgroundBlurriness > 0 ? n : e).get(C)),
        C
    }
    function T(L) {
        let C = !1;
        const H = E(L);
        H === null ? g(f, m) : H && H.isColor && (g(H, 1),
        C = !0);
        const k = s.xr.getEnvironmentBlendMode();
        k === "additive" ? r.buffers.color.setClear(0, 0, 0, 1, u) : k === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, u),
        (s.autoClear || C) && (r.buffers.depth.setTest(!0),
        r.buffers.depth.setMask(!0),
        r.buffers.color.setMask(!0),
        s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil))
    }
    function y(L, C) {
        const H = E(C);
        H && (H.isCubeTexture || H.mapping === Dl) ? (v === void 0 && (v = new fi(new Ha(1,1,1),new vr({
            name: "BackgroundCubeMaterial",
            uniforms: Vs(vi.backgroundCube.uniforms),
            vertexShader: vi.backgroundCube.vertexShader,
            fragmentShader: vi.backgroundCube.fragmentShader,
            side: Nn,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        v.geometry.deleteAttribute("normal"),
        v.geometry.deleteAttribute("uv"),
        v.onBeforeRender = function(k, F, j) {
            this.matrixWorld.copyPosition(j.matrixWorld)
        }
        ,
        Object.defineProperty(v.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        o.update(v)),
        zr.copy(C.backgroundRotation),
        zr.x *= -1,
        zr.y *= -1,
        zr.z *= -1,
        H.isCubeTexture && H.isRenderTargetTexture === !1 && (zr.y *= -1,
        zr.z *= -1),
        v.material.uniforms.envMap.value = H,
        v.material.uniforms.flipEnvMap.value = H.isCubeTexture && H.isRenderTargetTexture === !1 ? -1 : 1,
        v.material.uniforms.backgroundBlurriness.value = C.backgroundBlurriness,
        v.material.uniforms.backgroundIntensity.value = C.backgroundIntensity,
        v.material.uniforms.backgroundRotation.value.setFromMatrix4(mS.makeRotationFromEuler(zr)),
        v.material.toneMapped = Et.getTransfer(H.colorSpace) !== Lt,
        (_ !== H || x !== H.version || S !== s.toneMapping) && (v.material.needsUpdate = !0,
        _ = H,
        x = H.version,
        S = s.toneMapping),
        v.layers.enableAll(),
        L.unshift(v, v.geometry, v.material, 0, 0, null)) : H && H.isTexture && (p === void 0 && (p = new fi(new Il(2,2),new vr({
            name: "BackgroundMaterial",
            uniforms: Vs(vi.background.uniforms),
            vertexShader: vi.background.vertexShader,
            fragmentShader: vi.background.fragmentShader,
            side: _r,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        p.geometry.deleteAttribute("normal"),
        Object.defineProperty(p.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        o.update(p)),
        p.material.uniforms.t2D.value = H,
        p.material.uniforms.backgroundIntensity.value = C.backgroundIntensity,
        p.material.toneMapped = Et.getTransfer(H.colorSpace) !== Lt,
        H.matrixAutoUpdate === !0 && H.updateMatrix(),
        p.material.uniforms.uvTransform.value.copy(H.matrix),
        (_ !== H || x !== H.version || S !== s.toneMapping) && (p.material.needsUpdate = !0,
        _ = H,
        x = H.version,
        S = s.toneMapping),
        p.layers.enableAll(),
        L.unshift(p, p.geometry, p.material, 0, 0, null))
    }
    function g(L, C) {
        L.getRGB(xl, og(s)),
        r.buffers.color.setClear(xl.r, xl.g, xl.b, C, u)
    }
    function N() {
        v !== void 0 && (v.geometry.dispose(),
        v.material.dispose(),
        v = void 0),
        p !== void 0 && (p.geometry.dispose(),
        p.material.dispose(),
        p = void 0)
    }
    return {
        getClearColor: function() {
            return f
        },
        setClearColor: function(L, C=1) {
            f.set(L),
            m = C,
            g(f, m)
        },
        getClearAlpha: function() {
            return m
        },
        setClearAlpha: function(L) {
            m = L,
            g(f, m)
        },
        render: T,
        addToRenderList: y,
        dispose: N
    }
}
function _S(s, e) {
    const n = s.getParameter(s.MAX_VERTEX_ATTRIBS)
      , r = {}
      , o = x(null);
    let l = o
      , u = !1;
    function f(R, I, oe, se, ce) {
        let ne = !1;
        const ae = _(se, oe, I);
        l !== ae && (l = ae,
        p(l.object)),
        ne = S(R, se, oe, ce),
        ne && E(R, se, oe, ce),
        ce !== null && e.update(ce, s.ELEMENT_ARRAY_BUFFER),
        (ne || u) && (u = !1,
        C(R, I, oe, se),
        ce !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(ce).buffer))
    }
    function m() {
        return s.createVertexArray()
    }
    function p(R) {
        return s.bindVertexArray(R)
    }
    function v(R) {
        return s.deleteVertexArray(R)
    }
    function _(R, I, oe) {
        const se = oe.wireframe === !0;
        let ce = r[R.id];
        ce === void 0 && (ce = {},
        r[R.id] = ce);
        let ne = ce[I.id];
        ne === void 0 && (ne = {},
        ce[I.id] = ne);
        let ae = ne[se];
        return ae === void 0 && (ae = x(m()),
        ne[se] = ae),
        ae
    }
    function x(R) {
        const I = []
          , oe = []
          , se = [];
        for (let ce = 0; ce < n; ce++)
            I[ce] = 0,
            oe[ce] = 0,
            se[ce] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: I,
            enabledAttributes: oe,
            attributeDivisors: se,
            object: R,
            attributes: {},
            index: null
        }
    }
    function S(R, I, oe, se) {
        const ce = l.attributes
          , ne = I.attributes;
        let ae = 0;
        const de = oe.getAttributes();
        for (const V in de)
            if (de[V].location >= 0) {
                const re = ce[V];
                let U = ne[V];
                if (U === void 0 && (V === "instanceMatrix" && R.instanceMatrix && (U = R.instanceMatrix),
                V === "instanceColor" && R.instanceColor && (U = R.instanceColor)),
                re === void 0 || re.attribute !== U || U && re.data !== U.data)
                    return !0;
                ae++
            }
        return l.attributesNum !== ae || l.index !== se
    }
    function E(R, I, oe, se) {
        const ce = {}
          , ne = I.attributes;
        let ae = 0;
        const de = oe.getAttributes();
        for (const V in de)
            if (de[V].location >= 0) {
                let re = ne[V];
                re === void 0 && (V === "instanceMatrix" && R.instanceMatrix && (re = R.instanceMatrix),
                V === "instanceColor" && R.instanceColor && (re = R.instanceColor));
                const U = {};
                U.attribute = re,
                re && re.data && (U.data = re.data),
                ce[V] = U,
                ae++
            }
        l.attributes = ce,
        l.attributesNum = ae,
        l.index = se
    }
    function T() {
        const R = l.newAttributes;
        for (let I = 0, oe = R.length; I < oe; I++)
            R[I] = 0
    }
    function y(R) {
        g(R, 0)
    }
    function g(R, I) {
        const oe = l.newAttributes
          , se = l.enabledAttributes
          , ce = l.attributeDivisors;
        oe[R] = 1,
        se[R] === 0 && (s.enableVertexAttribArray(R),
        se[R] = 1),
        ce[R] !== I && (s.vertexAttribDivisor(R, I),
        ce[R] = I)
    }
    function N() {
        const R = l.newAttributes
          , I = l.enabledAttributes;
        for (let oe = 0, se = I.length; oe < se; oe++)
            I[oe] !== R[oe] && (s.disableVertexAttribArray(oe),
            I[oe] = 0)
    }
    function L(R, I, oe, se, ce, ne, ae) {
        ae === !0 ? s.vertexAttribIPointer(R, I, oe, ce, ne) : s.vertexAttribPointer(R, I, oe, se, ce, ne)
    }
    function C(R, I, oe, se) {
        T();
        const ce = se.attributes
          , ne = oe.getAttributes()
          , ae = I.defaultAttributeValues;
        for (const de in ne) {
            const V = ne[de];
            if (V.location >= 0) {
                let ue = ce[de];
                if (ue === void 0 && (de === "instanceMatrix" && R.instanceMatrix && (ue = R.instanceMatrix),
                de === "instanceColor" && R.instanceColor && (ue = R.instanceColor)),
                ue !== void 0) {
                    const re = ue.normalized
                      , U = ue.itemSize
                      , ie = e.get(ue);
                    if (ie === void 0)
                        continue;
                    const ke = ie.buffer
                      , ze = ie.type
                      , Q = ie.bytesPerElement
                      , me = ze === s.INT || ze === s.UNSIGNED_INT || ue.gpuType === jd;
                    if (ue.isInterleavedBufferAttribute) {
                        const pe = ue.data
                          , Ce = pe.stride
                          , Pe = ue.offset;
                        if (pe.isInstancedInterleavedBuffer) {
                            for (let Ke = 0; Ke < V.locationSize; Ke++)
                                g(V.location + Ke, pe.meshPerAttribute);
                            R.isInstancedMesh !== !0 && se._maxInstanceCount === void 0 && (se._maxInstanceCount = pe.meshPerAttribute * pe.count)
                        } else
                            for (let Ke = 0; Ke < V.locationSize; Ke++)
                                y(V.location + Ke);
                        s.bindBuffer(s.ARRAY_BUFFER, ke);
                        for (let Ke = 0; Ke < V.locationSize; Ke++)
                            L(V.location + Ke, U / V.locationSize, ze, re, Ce * Q, (Pe + U / V.locationSize * Ke) * Q, me)
                    } else {
                        if (ue.isInstancedBufferAttribute) {
                            for (let pe = 0; pe < V.locationSize; pe++)
                                g(V.location + pe, ue.meshPerAttribute);
                            R.isInstancedMesh !== !0 && se._maxInstanceCount === void 0 && (se._maxInstanceCount = ue.meshPerAttribute * ue.count)
                        } else
                            for (let pe = 0; pe < V.locationSize; pe++)
                                y(V.location + pe);
                        s.bindBuffer(s.ARRAY_BUFFER, ke);
                        for (let pe = 0; pe < V.locationSize; pe++)
                            L(V.location + pe, U / V.locationSize, ze, re, U * Q, U / V.locationSize * pe * Q, me)
                    }
                } else if (ae !== void 0) {
                    const re = ae[de];
                    if (re !== void 0)
                        switch (re.length) {
                        case 2:
                            s.vertexAttrib2fv(V.location, re);
                            break;
                        case 3:
                            s.vertexAttrib3fv(V.location, re);
                            break;
                        case 4:
                            s.vertexAttrib4fv(V.location, re);
                            break;
                        default:
                            s.vertexAttrib1fv(V.location, re)
                        }
                }
            }
        }
        N()
    }
    function H() {
        j();
        for (const R in r) {
            const I = r[R];
            for (const oe in I) {
                const se = I[oe];
                for (const ce in se)
                    v(se[ce].object),
                    delete se[ce];
                delete I[oe]
            }
            delete r[R]
        }
    }
    function k(R) {
        if (r[R.id] === void 0)
            return;
        const I = r[R.id];
        for (const oe in I) {
            const se = I[oe];
            for (const ce in se)
                v(se[ce].object),
                delete se[ce];
            delete I[oe]
        }
        delete r[R.id]
    }
    function F(R) {
        for (const I in r) {
            const oe = r[I];
            if (oe[R.id] === void 0)
                continue;
            const se = oe[R.id];
            for (const ce in se)
                v(se[ce].object),
                delete se[ce];
            delete oe[R.id]
        }
    }
    function j() {
        b(),
        u = !0,
        l !== o && (l = o,
        p(l.object))
    }
    function b() {
        o.geometry = null,
        o.program = null,
        o.wireframe = !1
    }
    return {
        setup: f,
        reset: j,
        resetDefaultState: b,
        dispose: H,
        releaseStatesOfGeometry: k,
        releaseStatesOfProgram: F,
        initAttributes: T,
        enableAttribute: y,
        disableUnusedAttributes: N
    }
}
function vS(s, e, n) {
    let r;
    function o(p) {
        r = p
    }
    function l(p, v) {
        s.drawArrays(r, p, v),
        n.update(v, r, 1)
    }
    function u(p, v, _) {
        _ !== 0 && (s.drawArraysInstanced(r, p, v, _),
        n.update(v, r, _))
    }
    function f(p, v, _) {
        if (_ === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, p, 0, v, 0, _);
        let S = 0;
        for (let E = 0; E < _; E++)
            S += v[E];
        n.update(S, r, 1)
    }
    function m(p, v, _, x) {
        if (_ === 0)
            return;
        const S = e.get("WEBGL_multi_draw");
        if (S === null)
            for (let E = 0; E < p.length; E++)
                u(p[E], v[E], x[E]);
        else {
            S.multiDrawArraysInstancedWEBGL(r, p, 0, v, 0, x, 0, _);
            let E = 0;
            for (let T = 0; T < _; T++)
                E += v[T] * x[T];
            n.update(E, r, 1)
        }
    }
    this.setMode = o,
    this.render = l,
    this.renderInstances = u,
    this.renderMultiDraw = f,
    this.renderMultiDrawInstances = m
}
function xS(s, e, n, r) {
    let o;
    function l() {
        if (o !== void 0)
            return o;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const F = e.get("EXT_texture_filter_anisotropic");
            o = s.getParameter(F.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            o = 0;
        return o
    }
    function u(F) {
        return !(F !== di && r.convert(F) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function f(F) {
        const j = F === Fa && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(F !== Si && r.convert(F) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && F !== Bi && !j)
    }
    function m(F) {
        if (F === "highp") {
            if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
                return "highp";
            F = "mediump"
        }
        return F === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let p = n.precision !== void 0 ? n.precision : "highp";
    const v = m(p);
    v !== p && (console.warn("THREE.WebGLRenderer:", p, "not supported, using", v, "instead."),
    p = v);
    const _ = n.logarithmicDepthBuffer === !0
      , x = n.reversedDepthBuffer === !0 && e.has("EXT_clip_control")
      , S = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS)
      , E = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , T = s.getParameter(s.MAX_TEXTURE_SIZE)
      , y = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE)
      , g = s.getParameter(s.MAX_VERTEX_ATTRIBS)
      , N = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS)
      , L = s.getParameter(s.MAX_VARYING_VECTORS)
      , C = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS)
      , H = E > 0
      , k = s.getParameter(s.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: l,
        getMaxPrecision: m,
        textureFormatReadable: u,
        textureTypeReadable: f,
        precision: p,
        logarithmicDepthBuffer: _,
        reversedDepthBuffer: x,
        maxTextures: S,
        maxVertexTextures: E,
        maxTextureSize: T,
        maxCubemapSize: y,
        maxAttributes: g,
        maxVertexUniforms: N,
        maxVaryings: L,
        maxFragmentUniforms: C,
        vertexTextures: H,
        maxSamples: k
    }
}
function yS(s) {
    const e = this;
    let n = null
      , r = 0
      , o = !1
      , l = !1;
    const u = new Br
      , f = new ut
      , m = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = m,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(_, x) {
        const S = _.length !== 0 || x || r !== 0 || o;
        return o = x,
        r = _.length,
        S
    }
    ,
    this.beginShadows = function() {
        l = !0,
        v(null)
    }
    ,
    this.endShadows = function() {
        l = !1
    }
    ,
    this.setGlobalState = function(_, x) {
        n = v(_, x, 0)
    }
    ,
    this.setState = function(_, x, S) {
        const E = _.clippingPlanes
          , T = _.clipIntersection
          , y = _.clipShadows
          , g = s.get(_);
        if (!o || E === null || E.length === 0 || l && !y)
            l ? v(null) : p();
        else {
            const N = l ? 0 : r
              , L = N * 4;
            let C = g.clippingState || null;
            m.value = C,
            C = v(E, x, L, S);
            for (let H = 0; H !== L; ++H)
                C[H] = n[H];
            g.clippingState = C,
            this.numIntersection = T ? this.numPlanes : 0,
            this.numPlanes += N
        }
    }
    ;
    function p() {
        m.value !== n && (m.value = n,
        m.needsUpdate = r > 0),
        e.numPlanes = r,
        e.numIntersection = 0
    }
    function v(_, x, S, E) {
        const T = _ !== null ? _.length : 0;
        let y = null;
        if (T !== 0) {
            if (y = m.value,
            E !== !0 || y === null) {
                const g = S + T * 4
                  , N = x.matrixWorldInverse;
                f.getNormalMatrix(N),
                (y === null || y.length < g) && (y = new Float32Array(g));
                for (let L = 0, C = S; L !== T; ++L,
                C += 4)
                    u.copy(_[L]).applyMatrix4(N, f),
                    u.normal.toArray(y, C),
                    y[C + 3] = u.constant
            }
            m.value = y,
            m.needsUpdate = !0
        }
        return e.numPlanes = T,
        e.numIntersection = 0,
        y
    }
}
function SS(s) {
    let e = new WeakMap;
    function n(u, f) {
        return f === od ? u.mapping = ks : f === ld && (u.mapping = Bs),
        u
    }
    function r(u) {
        if (u && u.isTexture) {
            const f = u.mapping;
            if (f === od || f === ld)
                if (e.has(u)) {
                    const m = e.get(u).texture;
                    return n(m, u.mapping)
                } else {
                    const m = u.image;
                    if (m && m.height > 0) {
                        const p = new vv(m.height);
                        return p.fromEquirectangularTexture(s, u),
                        e.set(u, p),
                        u.addEventListener("dispose", o),
                        n(p.texture, u.mapping)
                    } else
                        return null
                }
        }
        return u
    }
    function o(u) {
        const f = u.target;
        f.removeEventListener("dispose", o);
        const m = e.get(f);
        m !== void 0 && (e.delete(f),
        m.dispose())
    }
    function l() {
        e = new WeakMap
    }
    return {
        get: r,
        dispose: l
    }
}
const Is = 4
  , _m = [.125, .215, .35, .446, .526, .582]
  , jr = 20
  , Xu = new Lv
  , vm = new mt;
let Yu = null
  , Ju = 0
  , qu = 0
  , $u = !1;
const Hr = (1 + Math.sqrt(5)) / 2
  , Ds = 1 / Hr
  , xm = [new J(-Hr,Ds,0), new J(Hr,Ds,0), new J(-Ds,0,Hr), new J(Ds,0,Hr), new J(0,Hr,-Ds), new J(0,Hr,Ds), new J(-1,1,-1), new J(1,1,-1), new J(-1,1,1), new J(1,1,1)]
  , wS = new J;
class ym {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, n=0, r=.1, o=100, l={}) {
        const {size: u=256, position: f=wS} = l;
        Yu = this._renderer.getRenderTarget(),
        Ju = this._renderer.getActiveCubeFace(),
        qu = this._renderer.getActiveMipmapLevel(),
        $u = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(u);
        const m = this._allocateTargets();
        return m.depthBuffer = !0,
        this._sceneToCubeUV(e, r, o, m, f),
        n > 0 && this._blur(m, 0, 0, n),
        this._applyPMREM(m),
        this._cleanup(m),
        m
    }
    fromEquirectangular(e, n=null) {
        return this._fromTexture(e, n)
    }
    fromCubemap(e, n=null) {
        return this._fromTexture(e, n)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = Mm(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = wm(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Yu, Ju, qu),
        this._renderer.xr.enabled = $u,
        e.scissorTest = !1,
        yl(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, n) {
        e.mapping === ks || e.mapping === Bs ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        Yu = this._renderer.getRenderTarget(),
        Ju = this._renderer.getActiveCubeFace(),
        qu = this._renderer.getActiveMipmapLevel(),
        $u = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const r = n || this._allocateTargets();
        return this._textureToCubeUV(e, r),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , n = 4 * this._cubeSize
          , r = {
            magFilter: xi,
            minFilter: xi,
            generateMipmaps: !1,
            type: Fa,
            format: di,
            colorSpace: Hs,
            depthBuffer: !1
        }
          , o = Sm(e, n, r);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = Sm(e, n, r);
            const {_lodMax: l} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = MS(l)),
            this._blurMaterial = ES(l, e, n)
        }
        return o
    }
    _compileMaterial(e) {
        const n = new fi(this._lodPlanes[0],e);
        this._renderer.compile(n, Xu)
    }
    _sceneToCubeUV(e, n, r, o, l) {
        const m = new jn(90,1,n,r)
          , p = [1, -1, 1, 1, 1, 1]
          , v = [1, 1, 1, -1, -1, -1]
          , _ = this._renderer
          , x = _.autoClear
          , S = _.toneMapping;
        _.getClearColor(vm),
        _.toneMapping = gr,
        _.autoClear = !1,
        _.state.buffers.depth.getReversed() && (_.setRenderTarget(o),
        _.clearDepth(),
        _.setRenderTarget(null));
        const T = new rg({
            name: "PMREM.Background",
            side: Nn,
            depthWrite: !1,
            depthTest: !1
        })
          , y = new fi(new Ha,T);
        let g = !1;
        const N = e.background;
        N ? N.isColor && (T.color.copy(N),
        e.background = null,
        g = !0) : (T.color.copy(vm),
        g = !0);
        for (let L = 0; L < 6; L++) {
            const C = L % 3;
            C === 0 ? (m.up.set(0, p[L], 0),
            m.position.set(l.x, l.y, l.z),
            m.lookAt(l.x + v[L], l.y, l.z)) : C === 1 ? (m.up.set(0, 0, p[L]),
            m.position.set(l.x, l.y, l.z),
            m.lookAt(l.x, l.y + v[L], l.z)) : (m.up.set(0, p[L], 0),
            m.position.set(l.x, l.y, l.z),
            m.lookAt(l.x, l.y, l.z + v[L]));
            const H = this._cubeSize;
            yl(o, C * H, L > 2 ? H : 0, H, H),
            _.setRenderTarget(o),
            g && _.render(y, m),
            _.render(e, m)
        }
        y.geometry.dispose(),
        y.material.dispose(),
        _.toneMapping = S,
        _.autoClear = x,
        e.background = N
    }
    _textureToCubeUV(e, n) {
        const r = this._renderer
          , o = e.mapping === ks || e.mapping === Bs;
        o ? (this._cubemapMaterial === null && (this._cubemapMaterial = Mm()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = wm());
        const l = o ? this._cubemapMaterial : this._equirectMaterial
          , u = new fi(this._lodPlanes[0],l)
          , f = l.uniforms;
        f.envMap.value = e;
        const m = this._cubeSize;
        yl(n, 0, 0, 3 * m, 2 * m),
        r.setRenderTarget(n),
        r.render(u, Xu)
    }
    _applyPMREM(e) {
        const n = this._renderer
          , r = n.autoClear;
        n.autoClear = !1;
        const o = this._lodPlanes.length;
        for (let l = 1; l < o; l++) {
            const u = Math.sqrt(this._sigmas[l] * this._sigmas[l] - this._sigmas[l - 1] * this._sigmas[l - 1])
              , f = xm[(o - l - 1) % xm.length];
            this._blur(e, l - 1, l, u, f)
        }
        n.autoClear = r
    }
    _blur(e, n, r, o, l) {
        const u = this._pingPongRenderTarget;
        this._halfBlur(e, u, n, r, o, "latitudinal", l),
        this._halfBlur(u, e, r, r, o, "longitudinal", l)
    }
    _halfBlur(e, n, r, o, l, u, f) {
        const m = this._renderer
          , p = this._blurMaterial;
        u !== "latitudinal" && u !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const v = 3
          , _ = new fi(this._lodPlanes[o],p)
          , x = p.uniforms
          , S = this._sizeLods[r] - 1
          , E = isFinite(l) ? Math.PI / (2 * S) : 2 * Math.PI / (2 * jr - 1)
          , T = l / E
          , y = isFinite(l) ? 1 + Math.floor(v * T) : jr;
        y > jr && console.warn(`sigmaRadians, ${l}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${jr}`);
        const g = [];
        let N = 0;
        for (let F = 0; F < jr; ++F) {
            const j = F / T
              , b = Math.exp(-j * j / 2);
            g.push(b),
            F === 0 ? N += b : F < y && (N += 2 * b)
        }
        for (let F = 0; F < g.length; F++)
            g[F] = g[F] / N;
        x.envMap.value = e.texture,
        x.samples.value = y,
        x.weights.value = g,
        x.latitudinal.value = u === "latitudinal",
        f && (x.poleAxis.value = f);
        const {_lodMax: L} = this;
        x.dTheta.value = E,
        x.mipInt.value = L - r;
        const C = this._sizeLods[o]
          , H = 3 * C * (o > L - Is ? o - L + Is : 0)
          , k = 4 * (this._cubeSize - C);
        yl(n, H, k, 3 * C, 2 * C),
        m.setRenderTarget(n),
        m.render(_, Xu)
    }
}
function MS(s) {
    const e = []
      , n = []
      , r = [];
    let o = s;
    const l = s - Is + 1 + _m.length;
    for (let u = 0; u < l; u++) {
        const f = Math.pow(2, o);
        n.push(f);
        let m = 1 / f;
        u > s - Is ? m = _m[u - s + Is - 1] : u === 0 && (m = 0),
        r.push(m);
        const p = 1 / (f - 2)
          , v = -p
          , _ = 1 + p
          , x = [v, v, _, v, _, _, v, v, _, _, v, _]
          , S = 6
          , E = 6
          , T = 3
          , y = 2
          , g = 1
          , N = new Float32Array(T * E * S)
          , L = new Float32Array(y * E * S)
          , C = new Float32Array(g * E * S);
        for (let k = 0; k < S; k++) {
            const F = k % 3 * 2 / 3 - 1
              , j = k > 2 ? 0 : -1
              , b = [F, j, 0, F + 2 / 3, j, 0, F + 2 / 3, j + 1, 0, F, j, 0, F + 2 / 3, j + 1, 0, F, j + 1, 0];
            N.set(b, T * E * k),
            L.set(x, y * E * k);
            const R = [k, k, k, k, k, k];
            C.set(R, g * E * k)
        }
        const H = new Un;
        H.setAttribute("position", new Zn(N,T)),
        H.setAttribute("uv", new Zn(L,y)),
        H.setAttribute("faceIndex", new Zn(C,g)),
        e.push(H),
        o > Is && o--
    }
    return {
        lodPlanes: e,
        sizeLods: n,
        sigmas: r
    }
}
function Sm(s, e, n) {
    const r = new Yr(s,e,n);
    return r.texture.mapping = Dl,
    r.texture.name = "PMREM.cubeUv",
    r.scissorTest = !0,
    r
}
function yl(s, e, n, r, o) {
    s.viewport.set(e, n, r, o),
    s.scissor.set(e, n, r, o)
}
function ES(s, e, n) {
    const r = new Float32Array(jr)
      , o = new J(0,1,0);
    return new vr({
        name: "SphericalGaussianBlur",
        defines: {
            n: jr,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / n,
            CUBEUV_MAX_MIP: `${s}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: r
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: o
            }
        },
        vertexShader: tf(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: mr,
        depthTest: !1,
        depthWrite: !1
    })
}
function wm() {
    return new vr({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: tf(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: mr,
        depthTest: !1,
        depthWrite: !1
    })
}
function Mm() {
    return new vr({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: tf(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: mr,
        depthTest: !1,
        depthWrite: !1
    })
}
function tf() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function TS(s) {
    let e = new WeakMap
      , n = null;
    function r(f) {
        if (f && f.isTexture) {
            const m = f.mapping
              , p = m === od || m === ld
              , v = m === ks || m === Bs;
            if (p || v) {
                let _ = e.get(f);
                const x = _ !== void 0 ? _.texture.pmremVersion : 0;
                if (f.isRenderTargetTexture && f.pmremVersion !== x)
                    return n === null && (n = new ym(s)),
                    _ = p ? n.fromEquirectangular(f, _) : n.fromCubemap(f, _),
                    _.texture.pmremVersion = f.pmremVersion,
                    e.set(f, _),
                    _.texture;
                if (_ !== void 0)
                    return _.texture;
                {
                    const S = f.image;
                    return p && S && S.height > 0 || v && S && o(S) ? (n === null && (n = new ym(s)),
                    _ = p ? n.fromEquirectangular(f) : n.fromCubemap(f),
                    _.texture.pmremVersion = f.pmremVersion,
                    e.set(f, _),
                    f.addEventListener("dispose", l),
                    _.texture) : null
                }
            }
        }
        return f
    }
    function o(f) {
        let m = 0;
        const p = 6;
        for (let v = 0; v < p; v++)
            f[v] !== void 0 && m++;
        return m === p
    }
    function l(f) {
        const m = f.target;
        m.removeEventListener("dispose", l);
        const p = e.get(m);
        p !== void 0 && (e.delete(m),
        p.dispose())
    }
    function u() {
        e = new WeakMap,
        n !== null && (n.dispose(),
        n = null)
    }
    return {
        get: r,
        dispose: u
    }
}
function AS(s) {
    const e = {};
    function n(r) {
        if (e[r] !== void 0)
            return e[r];
        let o;
        switch (r) {
        case "WEBGL_depth_texture":
            o = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            o = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            o = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            o = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            o = s.getExtension(r)
        }
        return e[r] = o,
        o
    }
    return {
        has: function(r) {
            return n(r) !== null
        },
        init: function() {
            n("EXT_color_buffer_float"),
            n("WEBGL_clip_cull_distance"),
            n("OES_texture_float_linear"),
            n("EXT_color_buffer_half_float"),
            n("WEBGL_multisampled_render_to_texture"),
            n("WEBGL_render_shared_exponent")
        },
        get: function(r) {
            const o = n(r);
            return o === null && Fs("THREE.WebGLRenderer: " + r + " extension not supported."),
            o
        }
    }
}
function CS(s, e, n, r) {
    const o = {}
      , l = new WeakMap;
    function u(_) {
        const x = _.target;
        x.index !== null && e.remove(x.index);
        for (const E in x.attributes)
            e.remove(x.attributes[E]);
        x.removeEventListener("dispose", u),
        delete o[x.id];
        const S = l.get(x);
        S && (e.remove(S),
        l.delete(x)),
        r.releaseStatesOfGeometry(x),
        x.isInstancedBufferGeometry === !0 && delete x._maxInstanceCount,
        n.memory.geometries--
    }
    function f(_, x) {
        return o[x.id] === !0 || (x.addEventListener("dispose", u),
        o[x.id] = !0,
        n.memory.geometries++),
        x
    }
    function m(_) {
        const x = _.attributes;
        for (const S in x)
            e.update(x[S], s.ARRAY_BUFFER)
    }
    function p(_) {
        const x = []
          , S = _.index
          , E = _.attributes.position;
        let T = 0;
        if (S !== null) {
            const N = S.array;
            T = S.version;
            for (let L = 0, C = N.length; L < C; L += 3) {
                const H = N[L + 0]
                  , k = N[L + 1]
                  , F = N[L + 2];
                x.push(H, k, k, F, F, H)
            }
        } else if (E !== void 0) {
            const N = E.array;
            T = E.version;
            for (let L = 0, C = N.length / 3 - 1; L < C; L += 3) {
                const H = L + 0
                  , k = L + 1
                  , F = L + 2;
                x.push(H, k, k, F, F, H)
            }
        } else
            return;
        const y = new (eg(x) ? ag : sg)(x,1);
        y.version = T;
        const g = l.get(_);
        g && e.remove(g),
        l.set(_, y)
    }
    function v(_) {
        const x = l.get(_);
        if (x) {
            const S = _.index;
            S !== null && x.version < S.version && p(_)
        } else
            p(_);
        return l.get(_)
    }
    return {
        get: f,
        update: m,
        getWireframeAttribute: v
    }
}
function RS(s, e, n) {
    let r;
    function o(x) {
        r = x
    }
    let l, u;
    function f(x) {
        l = x.type,
        u = x.bytesPerElement
    }
    function m(x, S) {
        s.drawElements(r, S, l, x * u),
        n.update(S, r, 1)
    }
    function p(x, S, E) {
        E !== 0 && (s.drawElementsInstanced(r, S, l, x * u, E),
        n.update(S, r, E))
    }
    function v(x, S, E) {
        if (E === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, S, 0, l, x, 0, E);
        let y = 0;
        for (let g = 0; g < E; g++)
            y += S[g];
        n.update(y, r, 1)
    }
    function _(x, S, E, T) {
        if (E === 0)
            return;
        const y = e.get("WEBGL_multi_draw");
        if (y === null)
            for (let g = 0; g < x.length; g++)
                p(x[g] / u, S[g], T[g]);
        else {
            y.multiDrawElementsInstancedWEBGL(r, S, 0, l, x, 0, T, 0, E);
            let g = 0;
            for (let N = 0; N < E; N++)
                g += S[N] * T[N];
            n.update(g, r, 1)
        }
    }
    this.setMode = o,
    this.setIndex = f,
    this.render = m,
    this.renderInstances = p,
    this.renderMultiDraw = v,
    this.renderMultiDrawInstances = _
}
function bS(s) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , n = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function r(l, u, f) {
        switch (n.calls++,
        u) {
        case s.TRIANGLES:
            n.triangles += f * (l / 3);
            break;
        case s.LINES:
            n.lines += f * (l / 2);
            break;
        case s.LINE_STRIP:
            n.lines += f * (l - 1);
            break;
        case s.LINE_LOOP:
            n.lines += f * l;
            break;
        case s.POINTS:
            n.points += f * l;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", u);
            break
        }
    }
    function o() {
        n.calls = 0,
        n.triangles = 0,
        n.points = 0,
        n.lines = 0
    }
    return {
        memory: e,
        render: n,
        programs: null,
        autoReset: !0,
        reset: o,
        update: r
    }
}
function LS(s, e, n) {
    const r = new WeakMap
      , o = new Pt;
    function l(u, f, m) {
        const p = u.morphTargetInfluences
          , v = f.morphAttributes.position || f.morphAttributes.normal || f.morphAttributes.color
          , _ = v !== void 0 ? v.length : 0;
        let x = r.get(f);
        if (x === void 0 || x.count !== _) {
            let R = function() {
                j.dispose(),
                r.delete(f),
                f.removeEventListener("dispose", R)
            };
            var S = R;
            x !== void 0 && x.texture.dispose();
            const E = f.morphAttributes.position !== void 0
              , T = f.morphAttributes.normal !== void 0
              , y = f.morphAttributes.color !== void 0
              , g = f.morphAttributes.position || []
              , N = f.morphAttributes.normal || []
              , L = f.morphAttributes.color || [];
            let C = 0;
            E === !0 && (C = 1),
            T === !0 && (C = 2),
            y === !0 && (C = 3);
            let H = f.attributes.position.count * C
              , k = 1;
            H > e.maxTextureSize && (k = Math.ceil(H / e.maxTextureSize),
            H = e.maxTextureSize);
            const F = new Float32Array(H * k * 4 * _)
              , j = new tg(F,H,k,_);
            j.type = Bi,
            j.needsUpdate = !0;
            const b = C * 4;
            for (let I = 0; I < _; I++) {
                const oe = g[I]
                  , se = N[I]
                  , ce = L[I]
                  , ne = H * k * 4 * I;
                for (let ae = 0; ae < oe.count; ae++) {
                    const de = ae * b;
                    E === !0 && (o.fromBufferAttribute(oe, ae),
                    F[ne + de + 0] = o.x,
                    F[ne + de + 1] = o.y,
                    F[ne + de + 2] = o.z,
                    F[ne + de + 3] = 0),
                    T === !0 && (o.fromBufferAttribute(se, ae),
                    F[ne + de + 4] = o.x,
                    F[ne + de + 5] = o.y,
                    F[ne + de + 6] = o.z,
                    F[ne + de + 7] = 0),
                    y === !0 && (o.fromBufferAttribute(ce, ae),
                    F[ne + de + 8] = o.x,
                    F[ne + de + 9] = o.y,
                    F[ne + de + 10] = o.z,
                    F[ne + de + 11] = ce.itemSize === 4 ? o.w : 1)
                }
            }
            x = {
                count: _,
                texture: j,
                size: new vt(H,k)
            },
            r.set(f, x),
            f.addEventListener("dispose", R)
        }
        if (u.isInstancedMesh === !0 && u.morphTexture !== null)
            m.getUniforms().setValue(s, "morphTexture", u.morphTexture, n);
        else {
            let E = 0;
            for (let y = 0; y < p.length; y++)
                E += p[y];
            const T = f.morphTargetsRelative ? 1 : 1 - E;
            m.getUniforms().setValue(s, "morphTargetBaseInfluence", T),
            m.getUniforms().setValue(s, "morphTargetInfluences", p)
        }
        m.getUniforms().setValue(s, "morphTargetsTexture", x.texture, n),
        m.getUniforms().setValue(s, "morphTargetsTextureSize", x.size)
    }
    return {
        update: l
    }
}
function PS(s, e, n, r) {
    let o = new WeakMap;
    function l(m) {
        const p = r.render.frame
          , v = m.geometry
          , _ = e.get(m, v);
        if (o.get(_) !== p && (e.update(_),
        o.set(_, p)),
        m.isInstancedMesh && (m.hasEventListener("dispose", f) === !1 && m.addEventListener("dispose", f),
        o.get(m) !== p && (n.update(m.instanceMatrix, s.ARRAY_BUFFER),
        m.instanceColor !== null && n.update(m.instanceColor, s.ARRAY_BUFFER),
        o.set(m, p))),
        m.isSkinnedMesh) {
            const x = m.skeleton;
            o.get(x) !== p && (x.update(),
            o.set(x, p))
        }
        return _
    }
    function u() {
        o = new WeakMap
    }
    function f(m) {
        const p = m.target;
        p.removeEventListener("dispose", f),
        n.remove(p.instanceMatrix),
        p.instanceColor !== null && n.remove(p.instanceColor)
    }
    return {
        update: l,
        dispose: u
    }
}
const pg = new Dn
  , Em = new dg(1,1)
  , mg = new tg
  , gg = new tv
  , _g = new cg
  , Tm = []
  , Am = []
  , Cm = new Float32Array(16)
  , Rm = new Float32Array(9)
  , bm = new Float32Array(4);
function Gs(s, e, n) {
    const r = s[0];
    if (r <= 0 || r > 0)
        return s;
    const o = e * n;
    let l = Tm[o];
    if (l === void 0 && (l = new Float32Array(o),
    Tm[o] = l),
    e !== 0) {
        r.toArray(l, 0);
        for (let u = 1, f = 0; u !== e; ++u)
            f += n,
            s[u].toArray(l, f)
    }
    return l
}
function Zt(s, e) {
    if (s.length !== e.length)
        return !1;
    for (let n = 0, r = s.length; n < r; n++)
        if (s[n] !== e[n])
            return !1;
    return !0
}
function en(s, e) {
    for (let n = 0, r = e.length; n < r; n++)
        s[n] = e[n]
}
function Ul(s, e) {
    let n = Am[e];
    n === void 0 && (n = new Int32Array(e),
    Am[e] = n);
    for (let r = 0; r !== e; ++r)
        n[r] = s.allocateTextureUnit();
    return n
}
function NS(s, e) {
    const n = this.cache;
    n[0] !== e && (s.uniform1f(this.addr, e),
    n[0] = e)
}
function DS(s, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y),
        n[0] = e.x,
        n[1] = e.y);
    else {
        if (Zt(n, e))
            return;
        s.uniform2fv(this.addr, e),
        en(n, e)
    }
}
function IS(s, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z);
    else if (e.r !== void 0)
        (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b),
        n[0] = e.r,
        n[1] = e.g,
        n[2] = e.b);
    else {
        if (Zt(n, e))
            return;
        s.uniform3fv(this.addr, e),
        en(n, e)
    }
}
function US(s, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z,
        n[3] = e.w);
    else {
        if (Zt(n, e))
            return;
        s.uniform4fv(this.addr, e),
        en(n, e)
    }
}
function FS(s, e) {
    const n = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (Zt(n, e))
            return;
        s.uniformMatrix2fv(this.addr, !1, e),
        en(n, e)
    } else {
        if (Zt(n, r))
            return;
        bm.set(r),
        s.uniformMatrix2fv(this.addr, !1, bm),
        en(n, r)
    }
}
function OS(s, e) {
    const n = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (Zt(n, e))
            return;
        s.uniformMatrix3fv(this.addr, !1, e),
        en(n, e)
    } else {
        if (Zt(n, r))
            return;
        Rm.set(r),
        s.uniformMatrix3fv(this.addr, !1, Rm),
        en(n, r)
    }
}
function zS(s, e) {
    const n = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (Zt(n, e))
            return;
        s.uniformMatrix4fv(this.addr, !1, e),
        en(n, e)
    } else {
        if (Zt(n, r))
            return;
        Cm.set(r),
        s.uniformMatrix4fv(this.addr, !1, Cm),
        en(n, r)
    }
}
function kS(s, e) {
    const n = this.cache;
    n[0] !== e && (s.uniform1i(this.addr, e),
    n[0] = e)
}
function BS(s, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y),
        n[0] = e.x,
        n[1] = e.y);
    else {
        if (Zt(n, e))
            return;
        s.uniform2iv(this.addr, e),
        en(n, e)
    }
}
function HS(s, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z);
    else {
        if (Zt(n, e))
            return;
        s.uniform3iv(this.addr, e),
        en(n, e)
    }
}
function VS(s, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z,
        n[3] = e.w);
    else {
        if (Zt(n, e))
            return;
        s.uniform4iv(this.addr, e),
        en(n, e)
    }
}
function jS(s, e) {
    const n = this.cache;
    n[0] !== e && (s.uniform1ui(this.addr, e),
    n[0] = e)
}
function GS(s, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y),
        n[0] = e.x,
        n[1] = e.y);
    else {
        if (Zt(n, e))
            return;
        s.uniform2uiv(this.addr, e),
        en(n, e)
    }
}
function WS(s, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z);
    else {
        if (Zt(n, e))
            return;
        s.uniform3uiv(this.addr, e),
        en(n, e)
    }
}
function XS(s, e) {
    const n = this.cache;
    if (e.x !== void 0)
        (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        n[0] = e.x,
        n[1] = e.y,
        n[2] = e.z,
        n[3] = e.w);
    else {
        if (Zt(n, e))
            return;
        s.uniform4uiv(this.addr, e),
        en(n, e)
    }
}
function YS(s, e, n) {
    const r = this.cache
      , o = n.allocateTextureUnit();
    r[0] !== o && (s.uniform1i(this.addr, o),
    r[0] = o);
    let l;
    this.type === s.SAMPLER_2D_SHADOW ? (Em.compareFunction = Zm,
    l = Em) : l = pg,
    n.setTexture2D(e || l, o)
}
function JS(s, e, n) {
    const r = this.cache
      , o = n.allocateTextureUnit();
    r[0] !== o && (s.uniform1i(this.addr, o),
    r[0] = o),
    n.setTexture3D(e || gg, o)
}
function qS(s, e, n) {
    const r = this.cache
      , o = n.allocateTextureUnit();
    r[0] !== o && (s.uniform1i(this.addr, o),
    r[0] = o),
    n.setTextureCube(e || _g, o)
}
function $S(s, e, n) {
    const r = this.cache
      , o = n.allocateTextureUnit();
    r[0] !== o && (s.uniform1i(this.addr, o),
    r[0] = o),
    n.setTexture2DArray(e || mg, o)
}
function KS(s) {
    switch (s) {
    case 5126:
        return NS;
    case 35664:
        return DS;
    case 35665:
        return IS;
    case 35666:
        return US;
    case 35674:
        return FS;
    case 35675:
        return OS;
    case 35676:
        return zS;
    case 5124:
    case 35670:
        return kS;
    case 35667:
    case 35671:
        return BS;
    case 35668:
    case 35672:
        return HS;
    case 35669:
    case 35673:
        return VS;
    case 5125:
        return jS;
    case 36294:
        return GS;
    case 36295:
        return WS;
    case 36296:
        return XS;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return YS;
    case 35679:
    case 36299:
    case 36307:
        return JS;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return qS;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return $S
    }
}
function QS(s, e) {
    s.uniform1fv(this.addr, e)
}
function ZS(s, e) {
    const n = Gs(e, this.size, 2);
    s.uniform2fv(this.addr, n)
}
function ew(s, e) {
    const n = Gs(e, this.size, 3);
    s.uniform3fv(this.addr, n)
}
function tw(s, e) {
    const n = Gs(e, this.size, 4);
    s.uniform4fv(this.addr, n)
}
function nw(s, e) {
    const n = Gs(e, this.size, 4);
    s.uniformMatrix2fv(this.addr, !1, n)
}
function iw(s, e) {
    const n = Gs(e, this.size, 9);
    s.uniformMatrix3fv(this.addr, !1, n)
}
function rw(s, e) {
    const n = Gs(e, this.size, 16);
    s.uniformMatrix4fv(this.addr, !1, n)
}
function sw(s, e) {
    s.uniform1iv(this.addr, e)
}
function aw(s, e) {
    s.uniform2iv(this.addr, e)
}
function ow(s, e) {
    s.uniform3iv(this.addr, e)
}
function lw(s, e) {
    s.uniform4iv(this.addr, e)
}
function cw(s, e) {
    s.uniform1uiv(this.addr, e)
}
function uw(s, e) {
    s.uniform2uiv(this.addr, e)
}
function dw(s, e) {
    s.uniform3uiv(this.addr, e)
}
function fw(s, e) {
    s.uniform4uiv(this.addr, e)
}
function hw(s, e, n) {
    const r = this.cache
      , o = e.length
      , l = Ul(n, o);
    Zt(r, l) || (s.uniform1iv(this.addr, l),
    en(r, l));
    for (let u = 0; u !== o; ++u)
        n.setTexture2D(e[u] || pg, l[u])
}
function pw(s, e, n) {
    const r = this.cache
      , o = e.length
      , l = Ul(n, o);
    Zt(r, l) || (s.uniform1iv(this.addr, l),
    en(r, l));
    for (let u = 0; u !== o; ++u)
        n.setTexture3D(e[u] || gg, l[u])
}
function mw(s, e, n) {
    const r = this.cache
      , o = e.length
      , l = Ul(n, o);
    Zt(r, l) || (s.uniform1iv(this.addr, l),
    en(r, l));
    for (let u = 0; u !== o; ++u)
        n.setTextureCube(e[u] || _g, l[u])
}
function gw(s, e, n) {
    const r = this.cache
      , o = e.length
      , l = Ul(n, o);
    Zt(r, l) || (s.uniform1iv(this.addr, l),
    en(r, l));
    for (let u = 0; u !== o; ++u)
        n.setTexture2DArray(e[u] || mg, l[u])
}
function _w(s) {
    switch (s) {
    case 5126:
        return QS;
    case 35664:
        return ZS;
    case 35665:
        return ew;
    case 35666:
        return tw;
    case 35674:
        return nw;
    case 35675:
        return iw;
    case 35676:
        return rw;
    case 5124:
    case 35670:
        return sw;
    case 35667:
    case 35671:
        return aw;
    case 35668:
    case 35672:
        return ow;
    case 35669:
    case 35673:
        return lw;
    case 5125:
        return cw;
    case 36294:
        return uw;
    case 36295:
        return dw;
    case 36296:
        return fw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return hw;
    case 35679:
    case 36299:
    case 36307:
        return pw;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return mw;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return gw
    }
}
class vw {
    constructor(e, n, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.type = n.type,
        this.setValue = KS(n.type)
    }
}
class xw {
    constructor(e, n, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.type = n.type,
        this.size = n.size,
        this.setValue = _w(n.type)
    }
}
class yw {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, n, r) {
        const o = this.seq;
        for (let l = 0, u = o.length; l !== u; ++l) {
            const f = o[l];
            f.setValue(e, n[f.id], r)
        }
    }
}
const Ku = /(\w+)(\])?(\[|\.)?/g;
function Lm(s, e) {
    s.seq.push(e),
    s.map[e.id] = e
}
function Sw(s, e, n) {
    const r = s.name
      , o = r.length;
    for (Ku.lastIndex = 0; ; ) {
        const l = Ku.exec(r)
          , u = Ku.lastIndex;
        let f = l[1];
        const m = l[2] === "]"
          , p = l[3];
        if (m && (f = f | 0),
        p === void 0 || p === "[" && u + 2 === o) {
            Lm(n, p === void 0 ? new vw(f,s,e) : new xw(f,s,e));
            break
        } else {
            let _ = n.map[f];
            _ === void 0 && (_ = new yw(f),
            Lm(n, _)),
            n = _
        }
    }
}
class Cl {
    constructor(e, n) {
        this.seq = [],
        this.map = {};
        const r = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
        for (let o = 0; o < r; ++o) {
            const l = e.getActiveUniform(n, o)
              , u = e.getUniformLocation(n, l.name);
            Sw(l, u, this)
        }
    }
    setValue(e, n, r, o) {
        const l = this.map[n];
        l !== void 0 && l.setValue(e, r, o)
    }
    setOptional(e, n, r) {
        const o = n[r];
        o !== void 0 && this.setValue(e, r, o)
    }
    static upload(e, n, r, o) {
        for (let l = 0, u = n.length; l !== u; ++l) {
            const f = n[l]
              , m = r[f.id];
            m.needsUpdate !== !1 && f.setValue(e, m.value, o)
        }
    }
    static seqWithValue(e, n) {
        const r = [];
        for (let o = 0, l = e.length; o !== l; ++o) {
            const u = e[o];
            u.id in n && r.push(u)
        }
        return r
    }
}
function Pm(s, e, n) {
    const r = s.createShader(e);
    return s.shaderSource(r, n),
    s.compileShader(r),
    r
}
const ww = 37297;
let Mw = 0;
function Ew(s, e) {
    const n = s.split(`
`)
      , r = []
      , o = Math.max(e - 6, 0)
      , l = Math.min(e + 6, n.length);
    for (let u = o; u < l; u++) {
        const f = u + 1;
        r.push(`${f === e ? ">" : " "} ${f}: ${n[u]}`)
    }
    return r.join(`
`)
}
const Nm = new ut;
function Tw(s) {
    Et._getMatrix(Nm, Et.workingColorSpace, s);
    const e = `mat3( ${Nm.elements.map(n => n.toFixed(4))} )`;
    switch (Et.getTransfer(s)) {
    case Rl:
        return [e, "LinearTransferOETF"];
    case Lt:
        return [e, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space: ", s),
        [e, "LinearTransferOETF"]
    }
}
function Dm(s, e, n) {
    const r = s.getShaderParameter(e, s.COMPILE_STATUS)
      , l = (s.getShaderInfoLog(e) || "").trim();
    if (r && l === "")
        return "";
    const u = /ERROR: 0:(\d+)/.exec(l);
    if (u) {
        const f = parseInt(u[1]);
        return n.toUpperCase() + `

` + l + `

` + Ew(s.getShaderSource(e), f)
    } else
        return l
}
function Aw(s, e) {
    const n = Tw(e);
    return [`vec4 ${s}( vec4 value ) {`, `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join(`
`)
}
function Cw(s, e) {
    let n;
    switch (e) {
    case b_:
        n = "Linear";
        break;
    case L_:
        n = "Reinhard";
        break;
    case P_:
        n = "Cineon";
        break;
    case N_:
        n = "ACESFilmic";
        break;
    case I_:
        n = "AgX";
        break;
    case U_:
        n = "Neutral";
        break;
    case D_:
        n = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        n = "Linear"
    }
    return "vec3 " + s + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
}
const Sl = new J;
function Rw() {
    Et.getLuminanceCoefficients(Sl);
    const s = Sl.x.toFixed(4)
      , e = Sl.y.toFixed(4)
      , n = Sl.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${s}, ${e}, ${n} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}
function bw(s) {
    return [s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Pa).join(`
`)
}
function Lw(s) {
    const e = [];
    for (const n in s) {
        const r = s[n];
        r !== !1 && e.push("#define " + n + " " + r)
    }
    return e.join(`
`)
}
function Pw(s, e) {
    const n = {}
      , r = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
    for (let o = 0; o < r; o++) {
        const l = s.getActiveAttrib(e, o)
          , u = l.name;
        let f = 1;
        l.type === s.FLOAT_MAT2 && (f = 2),
        l.type === s.FLOAT_MAT3 && (f = 3),
        l.type === s.FLOAT_MAT4 && (f = 4),
        n[u] = {
            type: l.type,
            location: s.getAttribLocation(e, u),
            locationSize: f
        }
    }
    return n
}
function Pa(s) {
    return s !== ""
}
function Im(s, e) {
    const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function Um(s, e) {
    return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const Nw = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Bd(s) {
    return s.replace(Nw, Iw)
}
const Dw = new Map;
function Iw(s, e) {
    let n = dt[e];
    if (n === void 0) {
        const r = Dw.get(e);
        if (r !== void 0)
            n = dt[r],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, r);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return Bd(n)
}
const Uw = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Fm(s) {
    return s.replace(Uw, Fw)
}
function Fw(s, e, n, r) {
    let o = "";
    for (let l = parseInt(e); l < parseInt(n); l++)
        o += r.replace(/\[\s*i\s*\]/g, "[ " + l + " ]").replace(/UNROLLED_LOOP_INDEX/g, l);
    return o
}
function Om(s) {
    let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
    return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function Ow(s) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return s.shadowMapType === Hm ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === l_ ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === zi && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function zw(s) {
    let e = "ENVMAP_TYPE_CUBE";
    if (s.envMap)
        switch (s.envMapMode) {
        case ks:
        case Bs:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Dl:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function kw(s) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (s.envMap)
        switch (s.envMapMode) {
        case Bs:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function Bw(s) {
    let e = "ENVMAP_BLENDING_NONE";
    if (s.envMap)
        switch (s.combine) {
        case Vm:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case C_:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case R_:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function Hw(s) {
    const e = s.envMapCubeUVHeight;
    if (e === null)
        return null;
    const n = Math.log2(e) - 2
      , r = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
        texelHeight: r,
        maxMip: n
    }
}
function Vw(s, e, n, r) {
    const o = s.getContext()
      , l = n.defines;
    let u = n.vertexShader
      , f = n.fragmentShader;
    const m = Ow(n)
      , p = zw(n)
      , v = kw(n)
      , _ = Bw(n)
      , x = Hw(n)
      , S = bw(n)
      , E = Lw(l)
      , T = o.createProgram();
    let y, g, N = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
    n.isRawShaderMaterial ? (y = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, E].filter(Pa).join(`
`),
    y.length > 0 && (y += `
`),
    g = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, E].filter(Pa).join(`
`),
    g.length > 0 && (g += `
`)) : (y = [Om(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, E, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + v : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + m : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reversedDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Pa).join(`
`),
    g = [Om(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, E, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + v : "", n.envMap ? "#define " + _ : "", x ? "#define CUBEUV_TEXEL_WIDTH " + x.texelWidth : "", x ? "#define CUBEUV_TEXEL_HEIGHT " + x.texelHeight : "", x ? "#define CUBEUV_MAX_MIP " + x.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + m : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reversedDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== gr ? "#define TONE_MAPPING" : "", n.toneMapping !== gr ? dt.tonemapping_pars_fragment : "", n.toneMapping !== gr ? Cw("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", dt.colorspace_pars_fragment, Aw("linearToOutputTexel", n.outputColorSpace), Rw(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter(Pa).join(`
`)),
    u = Bd(u),
    u = Im(u, n),
    u = Um(u, n),
    f = Bd(f),
    f = Im(f, n),
    f = Um(f, n),
    u = Fm(u),
    f = Fm(f),
    n.isRawShaderMaterial !== !0 && (N = `#version 300 es
`,
    y = [S, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + y,
    g = ["#define varying in", n.glslVersion === Bp ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Bp ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + g);
    const L = N + y + u
      , C = N + g + f
      , H = Pm(o, o.VERTEX_SHADER, L)
      , k = Pm(o, o.FRAGMENT_SHADER, C);
    o.attachShader(T, H),
    o.attachShader(T, k),
    n.index0AttributeName !== void 0 ? o.bindAttribLocation(T, 0, n.index0AttributeName) : n.morphTargets === !0 && o.bindAttribLocation(T, 0, "position"),
    o.linkProgram(T);
    function F(I) {
        if (s.debug.checkShaderErrors) {
            const oe = o.getProgramInfoLog(T) || ""
              , se = o.getShaderInfoLog(H) || ""
              , ce = o.getShaderInfoLog(k) || ""
              , ne = oe.trim()
              , ae = se.trim()
              , de = ce.trim();
            let V = !0
              , ue = !0;
            if (o.getProgramParameter(T, o.LINK_STATUS) === !1)
                if (V = !1,
                typeof s.debug.onShaderError == "function")
                    s.debug.onShaderError(o, T, H, k);
                else {
                    const re = Dm(o, H, "vertex")
                      , U = Dm(o, k, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + o.getError() + " - VALIDATE_STATUS " + o.getProgramParameter(T, o.VALIDATE_STATUS) + `

Material Name: ` + I.name + `
Material Type: ` + I.type + `

Program Info Log: ` + ne + `
` + re + `
` + U)
                }
            else
                ne !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", ne) : (ae === "" || de === "") && (ue = !1);
            ue && (I.diagnostics = {
                runnable: V,
                programLog: ne,
                vertexShader: {
                    log: ae,
                    prefix: y
                },
                fragmentShader: {
                    log: de,
                    prefix: g
                }
            })
        }
        o.deleteShader(H),
        o.deleteShader(k),
        j = new Cl(o,T),
        b = Pw(o, T)
    }
    let j;
    this.getUniforms = function() {
        return j === void 0 && F(this),
        j
    }
    ;
    let b;
    this.getAttributes = function() {
        return b === void 0 && F(this),
        b
    }
    ;
    let R = n.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return R === !1 && (R = o.getProgramParameter(T, ww)),
        R
    }
    ,
    this.destroy = function() {
        r.releaseStatesOfProgram(this),
        o.deleteProgram(T),
        this.program = void 0
    }
    ,
    this.type = n.shaderType,
    this.name = n.shaderName,
    this.id = Mw++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = T,
    this.vertexShader = H,
    this.fragmentShader = k,
    this
}
let jw = 0;
class Gw {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const n = e.vertexShader
          , r = e.fragmentShader
          , o = this._getShaderStage(n)
          , l = this._getShaderStage(r)
          , u = this._getShaderCacheForMaterial(e);
        return u.has(o) === !1 && (u.add(o),
        o.usedTimes++),
        u.has(l) === !1 && (u.add(l),
        l.usedTimes++),
        this
    }
    remove(e) {
        const n = this.materialCache.get(e);
        for (const r of n)
            r.usedTimes--,
            r.usedTimes === 0 && this.shaderCache.delete(r.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const n = this.materialCache;
        let r = n.get(e);
        return r === void 0 && (r = new Set,
        n.set(e, r)),
        r
    }
    _getShaderStage(e) {
        const n = this.shaderCache;
        let r = n.get(e);
        return r === void 0 && (r = new Ww(e),
        n.set(e, r)),
        r
    }
}
class Ww {
    constructor(e) {
        this.id = jw++,
        this.code = e,
        this.usedTimes = 0
    }
}
function Xw(s, e, n, r, o, l, u) {
    const f = new ng
      , m = new Gw
      , p = new Set
      , v = []
      , _ = o.logarithmicDepthBuffer
      , x = o.vertexTextures;
    let S = o.precision;
    const E = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function T(b) {
        return p.add(b),
        b === 0 ? "uv" : `uv${b}`
    }
    function y(b, R, I, oe, se) {
        const ce = oe.fog
          , ne = se.geometry
          , ae = b.isMeshStandardMaterial ? oe.environment : null
          , de = (b.isMeshStandardMaterial ? n : e).get(b.envMap || ae)
          , V = de && de.mapping === Dl ? de.image.height : null
          , ue = E[b.type];
        b.precision !== null && (S = o.getMaxPrecision(b.precision),
        S !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", S, "instead."));
        const re = ne.morphAttributes.position || ne.morphAttributes.normal || ne.morphAttributes.color
          , U = re !== void 0 ? re.length : 0;
        let ie = 0;
        ne.morphAttributes.position !== void 0 && (ie = 1),
        ne.morphAttributes.normal !== void 0 && (ie = 2),
        ne.morphAttributes.color !== void 0 && (ie = 3);
        let ke, ze, Q, me;
        if (ue) {
            const yt = vi[ue];
            ke = yt.vertexShader,
            ze = yt.fragmentShader
        } else
            ke = b.vertexShader,
            ze = b.fragmentShader,
            m.update(b),
            Q = m.getVertexShaderID(b),
            me = m.getFragmentShaderID(b);
        const pe = s.getRenderTarget()
          , Ce = s.state.buffers.depth.getReversed()
          , Pe = se.isInstancedMesh === !0
          , Ke = se.isBatchedMesh === !0
          , Ut = !!b.map
          , gt = !!b.matcap
          , z = !!de
          , Tt = !!b.aoMap
          , Qe = !!b.lightMap
          , xt = !!b.bumpMap
          , qe = !!b.normalMap
          , Nt = !!b.displacementMap
          , Fe = !!b.emissiveMap
          , lt = !!b.metalnessMap
          , Ot = !!b.roughnessMap
          , zt = b.anisotropy > 0
          , P = b.clearcoat > 0
          , M = b.dispersion > 0
          , $ = b.iridescence > 0
          , fe = b.sheen > 0
          , ve = b.transmission > 0
          , le = zt && !!b.anisotropyMap
          , Ye = P && !!b.clearcoatMap
          , Te = P && !!b.clearcoatNormalMap
          , Be = P && !!b.clearcoatRoughnessMap
          , Je = $ && !!b.iridescenceMap
          , Me = $ && !!b.iridescenceThicknessMap
          , Ne = fe && !!b.sheenColorMap
          , it = fe && !!b.sheenRoughnessMap
          , We = !!b.specularMap
          , Re = !!b.specularColorMap
          , ct = !!b.specularIntensityMap
          , G = ve && !!b.transmissionMap
          , Se = ve && !!b.thicknessMap
          , Ae = !!b.gradientMap
          , De = !!b.alphaMap
          , ye = b.alphaTest > 0
          , he = !!b.alphaHash
          , je = !!b.extensions;
        let ot = gr;
        b.toneMapped && (pe === null || pe.isXRRenderTarget === !0) && (ot = s.toneMapping);
        const Ct = {
            shaderID: ue,
            shaderType: b.type,
            shaderName: b.name,
            vertexShader: ke,
            fragmentShader: ze,
            defines: b.defines,
            customVertexShaderID: Q,
            customFragmentShaderID: me,
            isRawShaderMaterial: b.isRawShaderMaterial === !0,
            glslVersion: b.glslVersion,
            precision: S,
            batching: Ke,
            batchingColor: Ke && se._colorsTexture !== null,
            instancing: Pe,
            instancingColor: Pe && se.instanceColor !== null,
            instancingMorph: Pe && se.morphTexture !== null,
            supportsVertexTextures: x,
            outputColorSpace: pe === null ? s.outputColorSpace : pe.isXRRenderTarget === !0 ? pe.texture.colorSpace : Hs,
            alphaToCoverage: !!b.alphaToCoverage,
            map: Ut,
            matcap: gt,
            envMap: z,
            envMapMode: z && de.mapping,
            envMapCubeUVHeight: V,
            aoMap: Tt,
            lightMap: Qe,
            bumpMap: xt,
            normalMap: qe,
            displacementMap: x && Nt,
            emissiveMap: Fe,
            normalMapObjectSpace: qe && b.normalMapType === k_,
            normalMapTangentSpace: qe && b.normalMapType === Qm,
            metalnessMap: lt,
            roughnessMap: Ot,
            anisotropy: zt,
            anisotropyMap: le,
            clearcoat: P,
            clearcoatMap: Ye,
            clearcoatNormalMap: Te,
            clearcoatRoughnessMap: Be,
            dispersion: M,
            iridescence: $,
            iridescenceMap: Je,
            iridescenceThicknessMap: Me,
            sheen: fe,
            sheenColorMap: Ne,
            sheenRoughnessMap: it,
            specularMap: We,
            specularColorMap: Re,
            specularIntensityMap: ct,
            transmission: ve,
            transmissionMap: G,
            thicknessMap: Se,
            gradientMap: Ae,
            opaque: b.transparent === !1 && b.blending === Us && b.alphaToCoverage === !1,
            alphaMap: De,
            alphaTest: ye,
            alphaHash: he,
            combine: b.combine,
            mapUv: Ut && T(b.map.channel),
            aoMapUv: Tt && T(b.aoMap.channel),
            lightMapUv: Qe && T(b.lightMap.channel),
            bumpMapUv: xt && T(b.bumpMap.channel),
            normalMapUv: qe && T(b.normalMap.channel),
            displacementMapUv: Nt && T(b.displacementMap.channel),
            emissiveMapUv: Fe && T(b.emissiveMap.channel),
            metalnessMapUv: lt && T(b.metalnessMap.channel),
            roughnessMapUv: Ot && T(b.roughnessMap.channel),
            anisotropyMapUv: le && T(b.anisotropyMap.channel),
            clearcoatMapUv: Ye && T(b.clearcoatMap.channel),
            clearcoatNormalMapUv: Te && T(b.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Be && T(b.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Je && T(b.iridescenceMap.channel),
            iridescenceThicknessMapUv: Me && T(b.iridescenceThicknessMap.channel),
            sheenColorMapUv: Ne && T(b.sheenColorMap.channel),
            sheenRoughnessMapUv: it && T(b.sheenRoughnessMap.channel),
            specularMapUv: We && T(b.specularMap.channel),
            specularColorMapUv: Re && T(b.specularColorMap.channel),
            specularIntensityMapUv: ct && T(b.specularIntensityMap.channel),
            transmissionMapUv: G && T(b.transmissionMap.channel),
            thicknessMapUv: Se && T(b.thicknessMap.channel),
            alphaMapUv: De && T(b.alphaMap.channel),
            vertexTangents: !!ne.attributes.tangent && (qe || zt),
            vertexColors: b.vertexColors,
            vertexAlphas: b.vertexColors === !0 && !!ne.attributes.color && ne.attributes.color.itemSize === 4,
            pointsUvs: se.isPoints === !0 && !!ne.attributes.uv && (Ut || De),
            fog: !!ce,
            useFog: b.fog === !0,
            fogExp2: !!ce && ce.isFogExp2,
            flatShading: b.flatShading === !0 && b.wireframe === !1,
            sizeAttenuation: b.sizeAttenuation === !0,
            logarithmicDepthBuffer: _,
            reversedDepthBuffer: Ce,
            skinning: se.isSkinnedMesh === !0,
            morphTargets: ne.morphAttributes.position !== void 0,
            morphNormals: ne.morphAttributes.normal !== void 0,
            morphColors: ne.morphAttributes.color !== void 0,
            morphTargetsCount: U,
            morphTextureStride: ie,
            numDirLights: R.directional.length,
            numPointLights: R.point.length,
            numSpotLights: R.spot.length,
            numSpotLightMaps: R.spotLightMap.length,
            numRectAreaLights: R.rectArea.length,
            numHemiLights: R.hemi.length,
            numDirLightShadows: R.directionalShadowMap.length,
            numPointLightShadows: R.pointShadowMap.length,
            numSpotLightShadows: R.spotShadowMap.length,
            numSpotLightShadowsWithMaps: R.numSpotLightShadowsWithMaps,
            numLightProbes: R.numLightProbes,
            numClippingPlanes: u.numPlanes,
            numClipIntersection: u.numIntersection,
            dithering: b.dithering,
            shadowMapEnabled: s.shadowMap.enabled && I.length > 0,
            shadowMapType: s.shadowMap.type,
            toneMapping: ot,
            decodeVideoTexture: Ut && b.map.isVideoTexture === !0 && Et.getTransfer(b.map.colorSpace) === Lt,
            decodeVideoTextureEmissive: Fe && b.emissiveMap.isVideoTexture === !0 && Et.getTransfer(b.emissiveMap.colorSpace) === Lt,
            premultipliedAlpha: b.premultipliedAlpha,
            doubleSided: b.side === ki,
            flipSided: b.side === Nn,
            useDepthPacking: b.depthPacking >= 0,
            depthPacking: b.depthPacking || 0,
            index0AttributeName: b.index0AttributeName,
            extensionClipCullDistance: je && b.extensions.clipCullDistance === !0 && r.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (je && b.extensions.multiDraw === !0 || Ke) && r.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: b.customProgramCacheKey()
        };
        return Ct.vertexUv1s = p.has(1),
        Ct.vertexUv2s = p.has(2),
        Ct.vertexUv3s = p.has(3),
        p.clear(),
        Ct
    }
    function g(b) {
        const R = [];
        if (b.shaderID ? R.push(b.shaderID) : (R.push(b.customVertexShaderID),
        R.push(b.customFragmentShaderID)),
        b.defines !== void 0)
            for (const I in b.defines)
                R.push(I),
                R.push(b.defines[I]);
        return b.isRawShaderMaterial === !1 && (N(R, b),
        L(R, b),
        R.push(s.outputColorSpace)),
        R.push(b.customProgramCacheKey),
        R.join()
    }
    function N(b, R) {
        b.push(R.precision),
        b.push(R.outputColorSpace),
        b.push(R.envMapMode),
        b.push(R.envMapCubeUVHeight),
        b.push(R.mapUv),
        b.push(R.alphaMapUv),
        b.push(R.lightMapUv),
        b.push(R.aoMapUv),
        b.push(R.bumpMapUv),
        b.push(R.normalMapUv),
        b.push(R.displacementMapUv),
        b.push(R.emissiveMapUv),
        b.push(R.metalnessMapUv),
        b.push(R.roughnessMapUv),
        b.push(R.anisotropyMapUv),
        b.push(R.clearcoatMapUv),
        b.push(R.clearcoatNormalMapUv),
        b.push(R.clearcoatRoughnessMapUv),
        b.push(R.iridescenceMapUv),
        b.push(R.iridescenceThicknessMapUv),
        b.push(R.sheenColorMapUv),
        b.push(R.sheenRoughnessMapUv),
        b.push(R.specularMapUv),
        b.push(R.specularColorMapUv),
        b.push(R.specularIntensityMapUv),
        b.push(R.transmissionMapUv),
        b.push(R.thicknessMapUv),
        b.push(R.combine),
        b.push(R.fogExp2),
        b.push(R.sizeAttenuation),
        b.push(R.morphTargetsCount),
        b.push(R.morphAttributeCount),
        b.push(R.numDirLights),
        b.push(R.numPointLights),
        b.push(R.numSpotLights),
        b.push(R.numSpotLightMaps),
        b.push(R.numHemiLights),
        b.push(R.numRectAreaLights),
        b.push(R.numDirLightShadows),
        b.push(R.numPointLightShadows),
        b.push(R.numSpotLightShadows),
        b.push(R.numSpotLightShadowsWithMaps),
        b.push(R.numLightProbes),
        b.push(R.shadowMapType),
        b.push(R.toneMapping),
        b.push(R.numClippingPlanes),
        b.push(R.numClipIntersection),
        b.push(R.depthPacking)
    }
    function L(b, R) {
        f.disableAll(),
        R.supportsVertexTextures && f.enable(0),
        R.instancing && f.enable(1),
        R.instancingColor && f.enable(2),
        R.instancingMorph && f.enable(3),
        R.matcap && f.enable(4),
        R.envMap && f.enable(5),
        R.normalMapObjectSpace && f.enable(6),
        R.normalMapTangentSpace && f.enable(7),
        R.clearcoat && f.enable(8),
        R.iridescence && f.enable(9),
        R.alphaTest && f.enable(10),
        R.vertexColors && f.enable(11),
        R.vertexAlphas && f.enable(12),
        R.vertexUv1s && f.enable(13),
        R.vertexUv2s && f.enable(14),
        R.vertexUv3s && f.enable(15),
        R.vertexTangents && f.enable(16),
        R.anisotropy && f.enable(17),
        R.alphaHash && f.enable(18),
        R.batching && f.enable(19),
        R.dispersion && f.enable(20),
        R.batchingColor && f.enable(21),
        R.gradientMap && f.enable(22),
        b.push(f.mask),
        f.disableAll(),
        R.fog && f.enable(0),
        R.useFog && f.enable(1),
        R.flatShading && f.enable(2),
        R.logarithmicDepthBuffer && f.enable(3),
        R.reversedDepthBuffer && f.enable(4),
        R.skinning && f.enable(5),
        R.morphTargets && f.enable(6),
        R.morphNormals && f.enable(7),
        R.morphColors && f.enable(8),
        R.premultipliedAlpha && f.enable(9),
        R.shadowMapEnabled && f.enable(10),
        R.doubleSided && f.enable(11),
        R.flipSided && f.enable(12),
        R.useDepthPacking && f.enable(13),
        R.dithering && f.enable(14),
        R.transmission && f.enable(15),
        R.sheen && f.enable(16),
        R.opaque && f.enable(17),
        R.pointsUvs && f.enable(18),
        R.decodeVideoTexture && f.enable(19),
        R.decodeVideoTextureEmissive && f.enable(20),
        R.alphaToCoverage && f.enable(21),
        b.push(f.mask)
    }
    function C(b) {
        const R = E[b.type];
        let I;
        if (R) {
            const oe = vi[R];
            I = pv.clone(oe.uniforms)
        } else
            I = b.uniforms;
        return I
    }
    function H(b, R) {
        let I;
        for (let oe = 0, se = v.length; oe < se; oe++) {
            const ce = v[oe];
            if (ce.cacheKey === R) {
                I = ce,
                ++I.usedTimes;
                break
            }
        }
        return I === void 0 && (I = new Vw(s,R,b,l),
        v.push(I)),
        I
    }
    function k(b) {
        if (--b.usedTimes === 0) {
            const R = v.indexOf(b);
            v[R] = v[v.length - 1],
            v.pop(),
            b.destroy()
        }
    }
    function F(b) {
        m.remove(b)
    }
    function j() {
        m.dispose()
    }
    return {
        getParameters: y,
        getProgramCacheKey: g,
        getUniforms: C,
        acquireProgram: H,
        releaseProgram: k,
        releaseShaderCache: F,
        programs: v,
        dispose: j
    }
}
function Yw() {
    let s = new WeakMap;
    function e(u) {
        return s.has(u)
    }
    function n(u) {
        let f = s.get(u);
        return f === void 0 && (f = {},
        s.set(u, f)),
        f
    }
    function r(u) {
        s.delete(u)
    }
    function o(u, f, m) {
        s.get(u)[f] = m
    }
    function l() {
        s = new WeakMap
    }
    return {
        has: e,
        get: n,
        remove: r,
        update: o,
        dispose: l
    }
}
function Jw(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id
}
function zm(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id
}
function km() {
    const s = [];
    let e = 0;
    const n = []
      , r = []
      , o = [];
    function l() {
        e = 0,
        n.length = 0,
        r.length = 0,
        o.length = 0
    }
    function u(_, x, S, E, T, y) {
        let g = s[e];
        return g === void 0 ? (g = {
            id: _.id,
            object: _,
            geometry: x,
            material: S,
            groupOrder: E,
            renderOrder: _.renderOrder,
            z: T,
            group: y
        },
        s[e] = g) : (g.id = _.id,
        g.object = _,
        g.geometry = x,
        g.material = S,
        g.groupOrder = E,
        g.renderOrder = _.renderOrder,
        g.z = T,
        g.group = y),
        e++,
        g
    }
    function f(_, x, S, E, T, y) {
        const g = u(_, x, S, E, T, y);
        S.transmission > 0 ? r.push(g) : S.transparent === !0 ? o.push(g) : n.push(g)
    }
    function m(_, x, S, E, T, y) {
        const g = u(_, x, S, E, T, y);
        S.transmission > 0 ? r.unshift(g) : S.transparent === !0 ? o.unshift(g) : n.unshift(g)
    }
    function p(_, x) {
        n.length > 1 && n.sort(_ || Jw),
        r.length > 1 && r.sort(x || zm),
        o.length > 1 && o.sort(x || zm)
    }
    function v() {
        for (let _ = e, x = s.length; _ < x; _++) {
            const S = s[_];
            if (S.id === null)
                break;
            S.id = null,
            S.object = null,
            S.geometry = null,
            S.material = null,
            S.group = null
        }
    }
    return {
        opaque: n,
        transmissive: r,
        transparent: o,
        init: l,
        push: f,
        unshift: m,
        finish: v,
        sort: p
    }
}
function qw() {
    let s = new WeakMap;
    function e(r, o) {
        const l = s.get(r);
        let u;
        return l === void 0 ? (u = new km,
        s.set(r, [u])) : o >= l.length ? (u = new km,
        l.push(u)) : u = l[o],
        u
    }
    function n() {
        s = new WeakMap
    }
    return {
        get: e,
        dispose: n
    }
}
function $w() {
    const s = {};
    return {
        get: function(e) {
            if (s[e.id] !== void 0)
                return s[e.id];
            let n;
            switch (e.type) {
            case "DirectionalLight":
                n = {
                    direction: new J,
                    color: new mt
                };
                break;
            case "SpotLight":
                n = {
                    position: new J,
                    direction: new J,
                    color: new mt,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                n = {
                    position: new J,
                    color: new mt,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                n = {
                    direction: new J,
                    skyColor: new mt,
                    groundColor: new mt
                };
                break;
            case "RectAreaLight":
                n = {
                    color: new mt,
                    position: new J,
                    halfWidth: new J,
                    halfHeight: new J
                };
                break
            }
            return s[e.id] = n,
            n
        }
    }
}
function Kw() {
    const s = {};
    return {
        get: function(e) {
            if (s[e.id] !== void 0)
                return s[e.id];
            let n;
            switch (e.type) {
            case "DirectionalLight":
                n = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new vt
                };
                break;
            case "SpotLight":
                n = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new vt
                };
                break;
            case "PointLight":
                n = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new vt,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return s[e.id] = n,
            n
        }
    }
}
let Qw = 0;
function Zw(s, e) {
    return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0)
}
function eM(s) {
    const e = new $w
      , n = Kw()
      , r = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let p = 0; p < 9; p++)
        r.probe.push(new J);
    const o = new J
      , l = new Vt
      , u = new Vt;
    function f(p) {
        let v = 0
          , _ = 0
          , x = 0;
        for (let b = 0; b < 9; b++)
            r.probe[b].set(0, 0, 0);
        let S = 0
          , E = 0
          , T = 0
          , y = 0
          , g = 0
          , N = 0
          , L = 0
          , C = 0
          , H = 0
          , k = 0
          , F = 0;
        p.sort(Zw);
        for (let b = 0, R = p.length; b < R; b++) {
            const I = p[b]
              , oe = I.color
              , se = I.intensity
              , ce = I.distance
              , ne = I.shadow && I.shadow.map ? I.shadow.map.texture : null;
            if (I.isAmbientLight)
                v += oe.r * se,
                _ += oe.g * se,
                x += oe.b * se;
            else if (I.isLightProbe) {
                for (let ae = 0; ae < 9; ae++)
                    r.probe[ae].addScaledVector(I.sh.coefficients[ae], se);
                F++
            } else if (I.isDirectionalLight) {
                const ae = e.get(I);
                if (ae.color.copy(I.color).multiplyScalar(I.intensity),
                I.castShadow) {
                    const de = I.shadow
                      , V = n.get(I);
                    V.shadowIntensity = de.intensity,
                    V.shadowBias = de.bias,
                    V.shadowNormalBias = de.normalBias,
                    V.shadowRadius = de.radius,
                    V.shadowMapSize = de.mapSize,
                    r.directionalShadow[S] = V,
                    r.directionalShadowMap[S] = ne,
                    r.directionalShadowMatrix[S] = I.shadow.matrix,
                    N++
                }
                r.directional[S] = ae,
                S++
            } else if (I.isSpotLight) {
                const ae = e.get(I);
                ae.position.setFromMatrixPosition(I.matrixWorld),
                ae.color.copy(oe).multiplyScalar(se),
                ae.distance = ce,
                ae.coneCos = Math.cos(I.angle),
                ae.penumbraCos = Math.cos(I.angle * (1 - I.penumbra)),
                ae.decay = I.decay,
                r.spot[T] = ae;
                const de = I.shadow;
                if (I.map && (r.spotLightMap[H] = I.map,
                H++,
                de.updateMatrices(I),
                I.castShadow && k++),
                r.spotLightMatrix[T] = de.matrix,
                I.castShadow) {
                    const V = n.get(I);
                    V.shadowIntensity = de.intensity,
                    V.shadowBias = de.bias,
                    V.shadowNormalBias = de.normalBias,
                    V.shadowRadius = de.radius,
                    V.shadowMapSize = de.mapSize,
                    r.spotShadow[T] = V,
                    r.spotShadowMap[T] = ne,
                    C++
                }
                T++
            } else if (I.isRectAreaLight) {
                const ae = e.get(I);
                ae.color.copy(oe).multiplyScalar(se),
                ae.halfWidth.set(I.width * .5, 0, 0),
                ae.halfHeight.set(0, I.height * .5, 0),
                r.rectArea[y] = ae,
                y++
            } else if (I.isPointLight) {
                const ae = e.get(I);
                if (ae.color.copy(I.color).multiplyScalar(I.intensity),
                ae.distance = I.distance,
                ae.decay = I.decay,
                I.castShadow) {
                    const de = I.shadow
                      , V = n.get(I);
                    V.shadowIntensity = de.intensity,
                    V.shadowBias = de.bias,
                    V.shadowNormalBias = de.normalBias,
                    V.shadowRadius = de.radius,
                    V.shadowMapSize = de.mapSize,
                    V.shadowCameraNear = de.camera.near,
                    V.shadowCameraFar = de.camera.far,
                    r.pointShadow[E] = V,
                    r.pointShadowMap[E] = ne,
                    r.pointShadowMatrix[E] = I.shadow.matrix,
                    L++
                }
                r.point[E] = ae,
                E++
            } else if (I.isHemisphereLight) {
                const ae = e.get(I);
                ae.skyColor.copy(I.color).multiplyScalar(se),
                ae.groundColor.copy(I.groundColor).multiplyScalar(se),
                r.hemi[g] = ae,
                g++
            }
        }
        y > 0 && (s.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Le.LTC_FLOAT_1,
        r.rectAreaLTC2 = Le.LTC_FLOAT_2) : (r.rectAreaLTC1 = Le.LTC_HALF_1,
        r.rectAreaLTC2 = Le.LTC_HALF_2)),
        r.ambient[0] = v,
        r.ambient[1] = _,
        r.ambient[2] = x;
        const j = r.hash;
        (j.directionalLength !== S || j.pointLength !== E || j.spotLength !== T || j.rectAreaLength !== y || j.hemiLength !== g || j.numDirectionalShadows !== N || j.numPointShadows !== L || j.numSpotShadows !== C || j.numSpotMaps !== H || j.numLightProbes !== F) && (r.directional.length = S,
        r.spot.length = T,
        r.rectArea.length = y,
        r.point.length = E,
        r.hemi.length = g,
        r.directionalShadow.length = N,
        r.directionalShadowMap.length = N,
        r.pointShadow.length = L,
        r.pointShadowMap.length = L,
        r.spotShadow.length = C,
        r.spotShadowMap.length = C,
        r.directionalShadowMatrix.length = N,
        r.pointShadowMatrix.length = L,
        r.spotLightMatrix.length = C + H - k,
        r.spotLightMap.length = H,
        r.numSpotLightShadowsWithMaps = k,
        r.numLightProbes = F,
        j.directionalLength = S,
        j.pointLength = E,
        j.spotLength = T,
        j.rectAreaLength = y,
        j.hemiLength = g,
        j.numDirectionalShadows = N,
        j.numPointShadows = L,
        j.numSpotShadows = C,
        j.numSpotMaps = H,
        j.numLightProbes = F,
        r.version = Qw++)
    }
    function m(p, v) {
        let _ = 0
          , x = 0
          , S = 0
          , E = 0
          , T = 0;
        const y = v.matrixWorldInverse;
        for (let g = 0, N = p.length; g < N; g++) {
            const L = p[g];
            if (L.isDirectionalLight) {
                const C = r.directional[_];
                C.direction.setFromMatrixPosition(L.matrixWorld),
                o.setFromMatrixPosition(L.target.matrixWorld),
                C.direction.sub(o),
                C.direction.transformDirection(y),
                _++
            } else if (L.isSpotLight) {
                const C = r.spot[S];
                C.position.setFromMatrixPosition(L.matrixWorld),
                C.position.applyMatrix4(y),
                C.direction.setFromMatrixPosition(L.matrixWorld),
                o.setFromMatrixPosition(L.target.matrixWorld),
                C.direction.sub(o),
                C.direction.transformDirection(y),
                S++
            } else if (L.isRectAreaLight) {
                const C = r.rectArea[E];
                C.position.setFromMatrixPosition(L.matrixWorld),
                C.position.applyMatrix4(y),
                u.identity(),
                l.copy(L.matrixWorld),
                l.premultiply(y),
                u.extractRotation(l),
                C.halfWidth.set(L.width * .5, 0, 0),
                C.halfHeight.set(0, L.height * .5, 0),
                C.halfWidth.applyMatrix4(u),
                C.halfHeight.applyMatrix4(u),
                E++
            } else if (L.isPointLight) {
                const C = r.point[x];
                C.position.setFromMatrixPosition(L.matrixWorld),
                C.position.applyMatrix4(y),
                x++
            } else if (L.isHemisphereLight) {
                const C = r.hemi[T];
                C.direction.setFromMatrixPosition(L.matrixWorld),
                C.direction.transformDirection(y),
                T++
            }
        }
    }
    return {
        setup: f,
        setupView: m,
        state: r
    }
}
function Bm(s) {
    const e = new eM(s)
      , n = []
      , r = [];
    function o(v) {
        p.camera = v,
        n.length = 0,
        r.length = 0
    }
    function l(v) {
        n.push(v)
    }
    function u(v) {
        r.push(v)
    }
    function f() {
        e.setup(n)
    }
    function m(v) {
        e.setupView(n, v)
    }
    const p = {
        lightsArray: n,
        shadowsArray: r,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: o,
        state: p,
        setupLights: f,
        setupLightsView: m,
        pushLight: l,
        pushShadow: u
    }
}
function tM(s) {
    let e = new WeakMap;
    function n(o, l=0) {
        const u = e.get(o);
        let f;
        return u === void 0 ? (f = new Bm(s),
        e.set(o, [f])) : l >= u.length ? (f = new Bm(s),
        u.push(f)) : f = u[l],
        f
    }
    function r() {
        e = new WeakMap
    }
    return {
        get: n,
        dispose: r
    }
}
const nM = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , iM = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function rM(s, e, n) {
    let r = new Kd;
    const o = new vt
      , l = new vt
      , u = new Pt
      , f = new Av({
        depthPacking: z_
    })
      , m = new Cv
      , p = {}
      , v = n.maxTextureSize
      , _ = {
        [_r]: Nn,
        [Nn]: _r,
        [ki]: ki
    }
      , x = new vr({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new vt
            },
            radius: {
                value: 4
            }
        },
        vertexShader: nM,
        fragmentShader: iM
    })
      , S = x.clone();
    S.defines.HORIZONTAL_PASS = 1;
    const E = new Un;
    E.setAttribute("position", new Zn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const T = new fi(E,x)
      , y = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = Hm;
    let g = this.type;
    this.render = function(k, F, j) {
        if (y.enabled === !1 || y.autoUpdate === !1 && y.needsUpdate === !1 || k.length === 0)
            return;
        const b = s.getRenderTarget()
          , R = s.getActiveCubeFace()
          , I = s.getActiveMipmapLevel()
          , oe = s.state;
        oe.setBlending(mr),
        oe.buffers.depth.getReversed() ? oe.buffers.color.setClear(0, 0, 0, 0) : oe.buffers.color.setClear(1, 1, 1, 1),
        oe.buffers.depth.setTest(!0),
        oe.setScissorTest(!1);
        const se = g !== zi && this.type === zi
          , ce = g === zi && this.type !== zi;
        for (let ne = 0, ae = k.length; ne < ae; ne++) {
            const de = k[ne]
              , V = de.shadow;
            if (V === void 0) {
                console.warn("THREE.WebGLShadowMap:", de, "has no shadow.");
                continue
            }
            if (V.autoUpdate === !1 && V.needsUpdate === !1)
                continue;
            o.copy(V.mapSize);
            const ue = V.getFrameExtents();
            if (o.multiply(ue),
            l.copy(V.mapSize),
            (o.x > v || o.y > v) && (o.x > v && (l.x = Math.floor(v / ue.x),
            o.x = l.x * ue.x,
            V.mapSize.x = l.x),
            o.y > v && (l.y = Math.floor(v / ue.y),
            o.y = l.y * ue.y,
            V.mapSize.y = l.y)),
            V.map === null || se === !0 || ce === !0) {
                const U = this.type !== zi ? {
                    minFilter: hi,
                    magFilter: hi
                } : {};
                V.map !== null && V.map.dispose(),
                V.map = new Yr(o.x,o.y,U),
                V.map.texture.name = de.name + ".shadowMap",
                V.camera.updateProjectionMatrix()
            }
            s.setRenderTarget(V.map),
            s.clear();
            const re = V.getViewportCount();
            for (let U = 0; U < re; U++) {
                const ie = V.getViewport(U);
                u.set(l.x * ie.x, l.y * ie.y, l.x * ie.z, l.y * ie.w),
                oe.viewport(u),
                V.updateMatrices(de, U),
                r = V.getFrustum(),
                C(F, j, V.camera, de, this.type)
            }
            V.isPointLightShadow !== !0 && this.type === zi && N(V, j),
            V.needsUpdate = !1
        }
        g = this.type,
        y.needsUpdate = !1,
        s.setRenderTarget(b, R, I)
    }
    ;
    function N(k, F) {
        const j = e.update(T);
        x.defines.VSM_SAMPLES !== k.blurSamples && (x.defines.VSM_SAMPLES = k.blurSamples,
        S.defines.VSM_SAMPLES = k.blurSamples,
        x.needsUpdate = !0,
        S.needsUpdate = !0),
        k.mapPass === null && (k.mapPass = new Yr(o.x,o.y)),
        x.uniforms.shadow_pass.value = k.map.texture,
        x.uniforms.resolution.value = k.mapSize,
        x.uniforms.radius.value = k.radius,
        s.setRenderTarget(k.mapPass),
        s.clear(),
        s.renderBufferDirect(F, null, j, x, T, null),
        S.uniforms.shadow_pass.value = k.mapPass.texture,
        S.uniforms.resolution.value = k.mapSize,
        S.uniforms.radius.value = k.radius,
        s.setRenderTarget(k.map),
        s.clear(),
        s.renderBufferDirect(F, null, j, S, T, null)
    }
    function L(k, F, j, b) {
        let R = null;
        const I = j.isPointLight === !0 ? k.customDistanceMaterial : k.customDepthMaterial;
        if (I !== void 0)
            R = I;
        else if (R = j.isPointLight === !0 ? m : f,
        s.localClippingEnabled && F.clipShadows === !0 && Array.isArray(F.clippingPlanes) && F.clippingPlanes.length !== 0 || F.displacementMap && F.displacementScale !== 0 || F.alphaMap && F.alphaTest > 0 || F.map && F.alphaTest > 0 || F.alphaToCoverage === !0) {
            const oe = R.uuid
              , se = F.uuid;
            let ce = p[oe];
            ce === void 0 && (ce = {},
            p[oe] = ce);
            let ne = ce[se];
            ne === void 0 && (ne = R.clone(),
            ce[se] = ne,
            F.addEventListener("dispose", H)),
            R = ne
        }
        if (R.visible = F.visible,
        R.wireframe = F.wireframe,
        b === zi ? R.side = F.shadowSide !== null ? F.shadowSide : F.side : R.side = F.shadowSide !== null ? F.shadowSide : _[F.side],
        R.alphaMap = F.alphaMap,
        R.alphaTest = F.alphaToCoverage === !0 ? .5 : F.alphaTest,
        R.map = F.map,
        R.clipShadows = F.clipShadows,
        R.clippingPlanes = F.clippingPlanes,
        R.clipIntersection = F.clipIntersection,
        R.displacementMap = F.displacementMap,
        R.displacementScale = F.displacementScale,
        R.displacementBias = F.displacementBias,
        R.wireframeLinewidth = F.wireframeLinewidth,
        R.linewidth = F.linewidth,
        j.isPointLight === !0 && R.isMeshDistanceMaterial === !0) {
            const oe = s.properties.get(R);
            oe.light = j
        }
        return R
    }
    function C(k, F, j, b, R) {
        if (k.visible === !1)
            return;
        if (k.layers.test(F.layers) && (k.isMesh || k.isLine || k.isPoints) && (k.castShadow || k.receiveShadow && R === zi) && (!k.frustumCulled || r.intersectsObject(k))) {
            k.modelViewMatrix.multiplyMatrices(j.matrixWorldInverse, k.matrixWorld);
            const se = e.update(k)
              , ce = k.material;
            if (Array.isArray(ce)) {
                const ne = se.groups;
                for (let ae = 0, de = ne.length; ae < de; ae++) {
                    const V = ne[ae]
                      , ue = ce[V.materialIndex];
                    if (ue && ue.visible) {
                        const re = L(k, ue, b, R);
                        k.onBeforeShadow(s, k, F, j, se, re, V),
                        s.renderBufferDirect(j, null, se, re, k, V),
                        k.onAfterShadow(s, k, F, j, se, re, V)
                    }
                }
            } else if (ce.visible) {
                const ne = L(k, ce, b, R);
                k.onBeforeShadow(s, k, F, j, se, ne, null),
                s.renderBufferDirect(j, null, se, ne, k, null),
                k.onAfterShadow(s, k, F, j, se, ne, null)
            }
        }
        const oe = k.children;
        for (let se = 0, ce = oe.length; se < ce; se++)
            C(oe[se], F, j, b, R)
    }
    function H(k) {
        k.target.removeEventListener("dispose", H);
        for (const j in p) {
            const b = p[j]
              , R = k.target.uuid;
            R in b && (b[R].dispose(),
            delete b[R])
        }
    }
}
const sM = {
    [ed]: td,
    [nd]: sd,
    [id]: ad,
    [zs]: rd,
    [td]: ed,
    [sd]: nd,
    [ad]: id,
    [rd]: zs
};
function aM(s, e) {
    function n() {
        let G = !1;
        const Se = new Pt;
        let Ae = null;
        const De = new Pt(0,0,0,0);
        return {
            setMask: function(ye) {
                Ae !== ye && !G && (s.colorMask(ye, ye, ye, ye),
                Ae = ye)
            },
            setLocked: function(ye) {
                G = ye
            },
            setClear: function(ye, he, je, ot, Ct) {
                Ct === !0 && (ye *= ot,
                he *= ot,
                je *= ot),
                Se.set(ye, he, je, ot),
                De.equals(Se) === !1 && (s.clearColor(ye, he, je, ot),
                De.copy(Se))
            },
            reset: function() {
                G = !1,
                Ae = null,
                De.set(-1, 0, 0, 0)
            }
        }
    }
    function r() {
        let G = !1
          , Se = !1
          , Ae = null
          , De = null
          , ye = null;
        return {
            setReversed: function(he) {
                if (Se !== he) {
                    const je = e.get("EXT_clip_control");
                    he ? je.clipControlEXT(je.LOWER_LEFT_EXT, je.ZERO_TO_ONE_EXT) : je.clipControlEXT(je.LOWER_LEFT_EXT, je.NEGATIVE_ONE_TO_ONE_EXT),
                    Se = he;
                    const ot = ye;
                    ye = null,
                    this.setClear(ot)
                }
            },
            getReversed: function() {
                return Se
            },
            setTest: function(he) {
                he ? pe(s.DEPTH_TEST) : Ce(s.DEPTH_TEST)
            },
            setMask: function(he) {
                Ae !== he && !G && (s.depthMask(he),
                Ae = he)
            },
            setFunc: function(he) {
                if (Se && (he = sM[he]),
                De !== he) {
                    switch (he) {
                    case ed:
                        s.depthFunc(s.NEVER);
                        break;
                    case td:
                        s.depthFunc(s.ALWAYS);
                        break;
                    case nd:
                        s.depthFunc(s.LESS);
                        break;
                    case zs:
                        s.depthFunc(s.LEQUAL);
                        break;
                    case id:
                        s.depthFunc(s.EQUAL);
                        break;
                    case rd:
                        s.depthFunc(s.GEQUAL);
                        break;
                    case sd:
                        s.depthFunc(s.GREATER);
                        break;
                    case ad:
                        s.depthFunc(s.NOTEQUAL);
                        break;
                    default:
                        s.depthFunc(s.LEQUAL)
                    }
                    De = he
                }
            },
            setLocked: function(he) {
                G = he
            },
            setClear: function(he) {
                ye !== he && (Se && (he = 1 - he),
                s.clearDepth(he),
                ye = he)
            },
            reset: function() {
                G = !1,
                Ae = null,
                De = null,
                ye = null,
                Se = !1
            }
        }
    }
    function o() {
        let G = !1
          , Se = null
          , Ae = null
          , De = null
          , ye = null
          , he = null
          , je = null
          , ot = null
          , Ct = null;
        return {
            setTest: function(yt) {
                G || (yt ? pe(s.STENCIL_TEST) : Ce(s.STENCIL_TEST))
            },
            setMask: function(yt) {
                Se !== yt && !G && (s.stencilMask(yt),
                Se = yt)
            },
            setFunc: function(yt, Gn, un) {
                (Ae !== yt || De !== Gn || ye !== un) && (s.stencilFunc(yt, Gn, un),
                Ae = yt,
                De = Gn,
                ye = un)
            },
            setOp: function(yt, Gn, un) {
                (he !== yt || je !== Gn || ot !== un) && (s.stencilOp(yt, Gn, un),
                he = yt,
                je = Gn,
                ot = un)
            },
            setLocked: function(yt) {
                G = yt
            },
            setClear: function(yt) {
                Ct !== yt && (s.clearStencil(yt),
                Ct = yt)
            },
            reset: function() {
                G = !1,
                Se = null,
                Ae = null,
                De = null,
                ye = null,
                he = null,
                je = null,
                ot = null,
                Ct = null
            }
        }
    }
    const l = new n
      , u = new r
      , f = new o
      , m = new WeakMap
      , p = new WeakMap;
    let v = {}
      , _ = {}
      , x = new WeakMap
      , S = []
      , E = null
      , T = !1
      , y = null
      , g = null
      , N = null
      , L = null
      , C = null
      , H = null
      , k = null
      , F = new mt(0,0,0)
      , j = 0
      , b = !1
      , R = null
      , I = null
      , oe = null
      , se = null
      , ce = null;
    const ne = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let ae = !1
      , de = 0;
    const V = s.getParameter(s.VERSION);
    V.indexOf("WebGL") !== -1 ? (de = parseFloat(/^WebGL (\d)/.exec(V)[1]),
    ae = de >= 1) : V.indexOf("OpenGL ES") !== -1 && (de = parseFloat(/^OpenGL ES (\d)/.exec(V)[1]),
    ae = de >= 2);
    let ue = null
      , re = {};
    const U = s.getParameter(s.SCISSOR_BOX)
      , ie = s.getParameter(s.VIEWPORT)
      , ke = new Pt().fromArray(U)
      , ze = new Pt().fromArray(ie);
    function Q(G, Se, Ae, De) {
        const ye = new Uint8Array(4)
          , he = s.createTexture();
        s.bindTexture(G, he),
        s.texParameteri(G, s.TEXTURE_MIN_FILTER, s.NEAREST),
        s.texParameteri(G, s.TEXTURE_MAG_FILTER, s.NEAREST);
        for (let je = 0; je < Ae; je++)
            G === s.TEXTURE_3D || G === s.TEXTURE_2D_ARRAY ? s.texImage3D(Se, 0, s.RGBA, 1, 1, De, 0, s.RGBA, s.UNSIGNED_BYTE, ye) : s.texImage2D(Se + je, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, ye);
        return he
    }
    const me = {};
    me[s.TEXTURE_2D] = Q(s.TEXTURE_2D, s.TEXTURE_2D, 1),
    me[s.TEXTURE_CUBE_MAP] = Q(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    me[s.TEXTURE_2D_ARRAY] = Q(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1),
    me[s.TEXTURE_3D] = Q(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1),
    l.setClear(0, 0, 0, 1),
    u.setClear(1),
    f.setClear(0),
    pe(s.DEPTH_TEST),
    u.setFunc(zs),
    xt(!1),
    qe(Ip),
    pe(s.CULL_FACE),
    Tt(mr);
    function pe(G) {
        v[G] !== !0 && (s.enable(G),
        v[G] = !0)
    }
    function Ce(G) {
        v[G] !== !1 && (s.disable(G),
        v[G] = !1)
    }
    function Pe(G, Se) {
        return _[G] !== Se ? (s.bindFramebuffer(G, Se),
        _[G] = Se,
        G === s.DRAW_FRAMEBUFFER && (_[s.FRAMEBUFFER] = Se),
        G === s.FRAMEBUFFER && (_[s.DRAW_FRAMEBUFFER] = Se),
        !0) : !1
    }
    function Ke(G, Se) {
        let Ae = S
          , De = !1;
        if (G) {
            Ae = x.get(Se),
            Ae === void 0 && (Ae = [],
            x.set(Se, Ae));
            const ye = G.textures;
            if (Ae.length !== ye.length || Ae[0] !== s.COLOR_ATTACHMENT0) {
                for (let he = 0, je = ye.length; he < je; he++)
                    Ae[he] = s.COLOR_ATTACHMENT0 + he;
                Ae.length = ye.length,
                De = !0
            }
        } else
            Ae[0] !== s.BACK && (Ae[0] = s.BACK,
            De = !0);
        De && s.drawBuffers(Ae)
    }
    function Ut(G) {
        return E !== G ? (s.useProgram(G),
        E = G,
        !0) : !1
    }
    const gt = {
        [Vr]: s.FUNC_ADD,
        [u_]: s.FUNC_SUBTRACT,
        [d_]: s.FUNC_REVERSE_SUBTRACT
    };
    gt[f_] = s.MIN,
    gt[h_] = s.MAX;
    const z = {
        [p_]: s.ZERO,
        [m_]: s.ONE,
        [g_]: s.SRC_COLOR,
        [Qu]: s.SRC_ALPHA,
        [w_]: s.SRC_ALPHA_SATURATE,
        [y_]: s.DST_COLOR,
        [v_]: s.DST_ALPHA,
        [__]: s.ONE_MINUS_SRC_COLOR,
        [Zu]: s.ONE_MINUS_SRC_ALPHA,
        [S_]: s.ONE_MINUS_DST_COLOR,
        [x_]: s.ONE_MINUS_DST_ALPHA,
        [M_]: s.CONSTANT_COLOR,
        [E_]: s.ONE_MINUS_CONSTANT_COLOR,
        [T_]: s.CONSTANT_ALPHA,
        [A_]: s.ONE_MINUS_CONSTANT_ALPHA
    };
    function Tt(G, Se, Ae, De, ye, he, je, ot, Ct, yt) {
        if (G === mr) {
            T === !0 && (Ce(s.BLEND),
            T = !1);
            return
        }
        if (T === !1 && (pe(s.BLEND),
        T = !0),
        G !== c_) {
            if (G !== y || yt !== b) {
                if ((g !== Vr || C !== Vr) && (s.blendEquation(s.FUNC_ADD),
                g = Vr,
                C = Vr),
                yt)
                    switch (G) {
                    case Us:
                        s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Up:
                        s.blendFunc(s.ONE, s.ONE);
                        break;
                    case Fp:
                        s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                        break;
                    case Op:
                        s.blendFuncSeparate(s.DST_COLOR, s.ONE_MINUS_SRC_ALPHA, s.ZERO, s.ONE);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", G);
                        break
                    }
                else
                    switch (G) {
                    case Us:
                        s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Up:
                        s.blendFuncSeparate(s.SRC_ALPHA, s.ONE, s.ONE, s.ONE);
                        break;
                    case Fp:
                        console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
                        break;
                    case Op:
                        console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", G);
                        break
                    }
                N = null,
                L = null,
                H = null,
                k = null,
                F.set(0, 0, 0),
                j = 0,
                y = G,
                b = yt
            }
            return
        }
        ye = ye || Se,
        he = he || Ae,
        je = je || De,
        (Se !== g || ye !== C) && (s.blendEquationSeparate(gt[Se], gt[ye]),
        g = Se,
        C = ye),
        (Ae !== N || De !== L || he !== H || je !== k) && (s.blendFuncSeparate(z[Ae], z[De], z[he], z[je]),
        N = Ae,
        L = De,
        H = he,
        k = je),
        (ot.equals(F) === !1 || Ct !== j) && (s.blendColor(ot.r, ot.g, ot.b, Ct),
        F.copy(ot),
        j = Ct),
        y = G,
        b = !1
    }
    function Qe(G, Se) {
        G.side === ki ? Ce(s.CULL_FACE) : pe(s.CULL_FACE);
        let Ae = G.side === Nn;
        Se && (Ae = !Ae),
        xt(Ae),
        G.blending === Us && G.transparent === !1 ? Tt(mr) : Tt(G.blending, G.blendEquation, G.blendSrc, G.blendDst, G.blendEquationAlpha, G.blendSrcAlpha, G.blendDstAlpha, G.blendColor, G.blendAlpha, G.premultipliedAlpha),
        u.setFunc(G.depthFunc),
        u.setTest(G.depthTest),
        u.setMask(G.depthWrite),
        l.setMask(G.colorWrite);
        const De = G.stencilWrite;
        f.setTest(De),
        De && (f.setMask(G.stencilWriteMask),
        f.setFunc(G.stencilFunc, G.stencilRef, G.stencilFuncMask),
        f.setOp(G.stencilFail, G.stencilZFail, G.stencilZPass)),
        Fe(G.polygonOffset, G.polygonOffsetFactor, G.polygonOffsetUnits),
        G.alphaToCoverage === !0 ? pe(s.SAMPLE_ALPHA_TO_COVERAGE) : Ce(s.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function xt(G) {
        R !== G && (G ? s.frontFace(s.CW) : s.frontFace(s.CCW),
        R = G)
    }
    function qe(G) {
        G !== a_ ? (pe(s.CULL_FACE),
        G !== I && (G === Ip ? s.cullFace(s.BACK) : G === o_ ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : Ce(s.CULL_FACE),
        I = G
    }
    function Nt(G) {
        G !== oe && (ae && s.lineWidth(G),
        oe = G)
    }
    function Fe(G, Se, Ae) {
        G ? (pe(s.POLYGON_OFFSET_FILL),
        (se !== Se || ce !== Ae) && (s.polygonOffset(Se, Ae),
        se = Se,
        ce = Ae)) : Ce(s.POLYGON_OFFSET_FILL)
    }
    function lt(G) {
        G ? pe(s.SCISSOR_TEST) : Ce(s.SCISSOR_TEST)
    }
    function Ot(G) {
        G === void 0 && (G = s.TEXTURE0 + ne - 1),
        ue !== G && (s.activeTexture(G),
        ue = G)
    }
    function zt(G, Se, Ae) {
        Ae === void 0 && (ue === null ? Ae = s.TEXTURE0 + ne - 1 : Ae = ue);
        let De = re[Ae];
        De === void 0 && (De = {
            type: void 0,
            texture: void 0
        },
        re[Ae] = De),
        (De.type !== G || De.texture !== Se) && (ue !== Ae && (s.activeTexture(Ae),
        ue = Ae),
        s.bindTexture(G, Se || me[G]),
        De.type = G,
        De.texture = Se)
    }
    function P() {
        const G = re[ue];
        G !== void 0 && G.type !== void 0 && (s.bindTexture(G.type, null),
        G.type = void 0,
        G.texture = void 0)
    }
    function M() {
        try {
            s.compressedTexImage2D(...arguments)
        } catch (G) {
            console.error("THREE.WebGLState:", G)
        }
    }
    function $() {
        try {
            s.compressedTexImage3D(...arguments)
        } catch (G) {
            console.error("THREE.WebGLState:", G)
        }
    }
    function fe() {
        try {
            s.texSubImage2D(...arguments)
        } catch (G) {
            console.error("THREE.WebGLState:", G)
        }
    }
    function ve() {
        try {
            s.texSubImage3D(...arguments)
        } catch (G) {
            console.error("THREE.WebGLState:", G)
        }
    }
    function le() {
        try {
            s.compressedTexSubImage2D(...arguments)
        } catch (G) {
            console.error("THREE.WebGLState:", G)
        }
    }
    function Ye() {
        try {
            s.compressedTexSubImage3D(...arguments)
        } catch (G) {
            console.error("THREE.WebGLState:", G)
        }
    }
    function Te() {
        try {
            s.texStorage2D(...arguments)
        } catch (G) {
            console.error("THREE.WebGLState:", G)
        }
    }
    function Be() {
        try {
            s.texStorage3D(...arguments)
        } catch (G) {
            console.error("THREE.WebGLState:", G)
        }
    }
    function Je() {
        try {
            s.texImage2D(...arguments)
        } catch (G) {
            console.error("THREE.WebGLState:", G)
        }
    }
    function Me() {
        try {
            s.texImage3D(...arguments)
        } catch (G) {
            console.error("THREE.WebGLState:", G)
        }
    }
    function Ne(G) {
        ke.equals(G) === !1 && (s.scissor(G.x, G.y, G.z, G.w),
        ke.copy(G))
    }
    function it(G) {
        ze.equals(G) === !1 && (s.viewport(G.x, G.y, G.z, G.w),
        ze.copy(G))
    }
    function We(G, Se) {
        let Ae = p.get(Se);
        Ae === void 0 && (Ae = new WeakMap,
        p.set(Se, Ae));
        let De = Ae.get(G);
        De === void 0 && (De = s.getUniformBlockIndex(Se, G.name),
        Ae.set(G, De))
    }
    function Re(G, Se) {
        const De = p.get(Se).get(G);
        m.get(Se) !== De && (s.uniformBlockBinding(Se, De, G.__bindingPointIndex),
        m.set(Se, De))
    }
    function ct() {
        s.disable(s.BLEND),
        s.disable(s.CULL_FACE),
        s.disable(s.DEPTH_TEST),
        s.disable(s.POLYGON_OFFSET_FILL),
        s.disable(s.SCISSOR_TEST),
        s.disable(s.STENCIL_TEST),
        s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),
        s.blendEquation(s.FUNC_ADD),
        s.blendFunc(s.ONE, s.ZERO),
        s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO),
        s.blendColor(0, 0, 0, 0),
        s.colorMask(!0, !0, !0, !0),
        s.clearColor(0, 0, 0, 0),
        s.depthMask(!0),
        s.depthFunc(s.LESS),
        u.setReversed(!1),
        s.clearDepth(1),
        s.stencilMask(4294967295),
        s.stencilFunc(s.ALWAYS, 0, 4294967295),
        s.stencilOp(s.KEEP, s.KEEP, s.KEEP),
        s.clearStencil(0),
        s.cullFace(s.BACK),
        s.frontFace(s.CCW),
        s.polygonOffset(0, 0),
        s.activeTexture(s.TEXTURE0),
        s.bindFramebuffer(s.FRAMEBUFFER, null),
        s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
        s.bindFramebuffer(s.READ_FRAMEBUFFER, null),
        s.useProgram(null),
        s.lineWidth(1),
        s.scissor(0, 0, s.canvas.width, s.canvas.height),
        s.viewport(0, 0, s.canvas.width, s.canvas.height),
        v = {},
        ue = null,
        re = {},
        _ = {},
        x = new WeakMap,
        S = [],
        E = null,
        T = !1,
        y = null,
        g = null,
        N = null,
        L = null,
        C = null,
        H = null,
        k = null,
        F = new mt(0,0,0),
        j = 0,
        b = !1,
        R = null,
        I = null,
        oe = null,
        se = null,
        ce = null,
        ke.set(0, 0, s.canvas.width, s.canvas.height),
        ze.set(0, 0, s.canvas.width, s.canvas.height),
        l.reset(),
        u.reset(),
        f.reset()
    }
    return {
        buffers: {
            color: l,
            depth: u,
            stencil: f
        },
        enable: pe,
        disable: Ce,
        bindFramebuffer: Pe,
        drawBuffers: Ke,
        useProgram: Ut,
        setBlending: Tt,
        setMaterial: Qe,
        setFlipSided: xt,
        setCullFace: qe,
        setLineWidth: Nt,
        setPolygonOffset: Fe,
        setScissorTest: lt,
        activeTexture: Ot,
        bindTexture: zt,
        unbindTexture: P,
        compressedTexImage2D: M,
        compressedTexImage3D: $,
        texImage2D: Je,
        texImage3D: Me,
        updateUBOMapping: We,
        uniformBlockBinding: Re,
        texStorage2D: Te,
        texStorage3D: Be,
        texSubImage2D: fe,
        texSubImage3D: ve,
        compressedTexSubImage2D: le,
        compressedTexSubImage3D: Ye,
        scissor: Ne,
        viewport: it,
        reset: ct
    }
}
function oM(s, e, n, r, o, l, u) {
    const f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , p = new vt
      , v = new WeakMap;
    let _;
    const x = new WeakMap;
    let S = !1;
    try {
        S = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function E(P, M) {
        return S ? new OffscreenCanvas(P,M) : Ll("canvas")
    }
    function T(P, M, $) {
        let fe = 1;
        const ve = zt(P);
        if ((ve.width > $ || ve.height > $) && (fe = $ / Math.max(ve.width, ve.height)),
        fe < 1)
            if (typeof HTMLImageElement < "u" && P instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && P instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && P instanceof ImageBitmap || typeof VideoFrame < "u" && P instanceof VideoFrame) {
                const le = Math.floor(fe * ve.width)
                  , Ye = Math.floor(fe * ve.height);
                _ === void 0 && (_ = E(le, Ye));
                const Te = M ? E(le, Ye) : _;
                return Te.width = le,
                Te.height = Ye,
                Te.getContext("2d").drawImage(P, 0, 0, le, Ye),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ve.width + "x" + ve.height + ") to (" + le + "x" + Ye + ")."),
                Te
            } else
                return "data"in P && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ve.width + "x" + ve.height + ")."),
                P;
        return P
    }
    function y(P) {
        return P.generateMipmaps
    }
    function g(P) {
        s.generateMipmap(P)
    }
    function N(P) {
        return P.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : P.isWebGL3DRenderTarget ? s.TEXTURE_3D : P.isWebGLArrayRenderTarget || P.isCompressedArrayTexture ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D
    }
    function L(P, M, $, fe, ve=!1) {
        if (P !== null) {
            if (s[P] !== void 0)
                return s[P];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + P + "'")
        }
        let le = M;
        if (M === s.RED && ($ === s.FLOAT && (le = s.R32F),
        $ === s.HALF_FLOAT && (le = s.R16F),
        $ === s.UNSIGNED_BYTE && (le = s.R8)),
        M === s.RED_INTEGER && ($ === s.UNSIGNED_BYTE && (le = s.R8UI),
        $ === s.UNSIGNED_SHORT && (le = s.R16UI),
        $ === s.UNSIGNED_INT && (le = s.R32UI),
        $ === s.BYTE && (le = s.R8I),
        $ === s.SHORT && (le = s.R16I),
        $ === s.INT && (le = s.R32I)),
        M === s.RG && ($ === s.FLOAT && (le = s.RG32F),
        $ === s.HALF_FLOAT && (le = s.RG16F),
        $ === s.UNSIGNED_BYTE && (le = s.RG8)),
        M === s.RG_INTEGER && ($ === s.UNSIGNED_BYTE && (le = s.RG8UI),
        $ === s.UNSIGNED_SHORT && (le = s.RG16UI),
        $ === s.UNSIGNED_INT && (le = s.RG32UI),
        $ === s.BYTE && (le = s.RG8I),
        $ === s.SHORT && (le = s.RG16I),
        $ === s.INT && (le = s.RG32I)),
        M === s.RGB_INTEGER && ($ === s.UNSIGNED_BYTE && (le = s.RGB8UI),
        $ === s.UNSIGNED_SHORT && (le = s.RGB16UI),
        $ === s.UNSIGNED_INT && (le = s.RGB32UI),
        $ === s.BYTE && (le = s.RGB8I),
        $ === s.SHORT && (le = s.RGB16I),
        $ === s.INT && (le = s.RGB32I)),
        M === s.RGBA_INTEGER && ($ === s.UNSIGNED_BYTE && (le = s.RGBA8UI),
        $ === s.UNSIGNED_SHORT && (le = s.RGBA16UI),
        $ === s.UNSIGNED_INT && (le = s.RGBA32UI),
        $ === s.BYTE && (le = s.RGBA8I),
        $ === s.SHORT && (le = s.RGBA16I),
        $ === s.INT && (le = s.RGBA32I)),
        M === s.RGB && $ === s.UNSIGNED_INT_5_9_9_9_REV && (le = s.RGB9_E5),
        M === s.RGBA) {
            const Ye = ve ? Rl : Et.getTransfer(fe);
            $ === s.FLOAT && (le = s.RGBA32F),
            $ === s.HALF_FLOAT && (le = s.RGBA16F),
            $ === s.UNSIGNED_BYTE && (le = Ye === Lt ? s.SRGB8_ALPHA8 : s.RGBA8),
            $ === s.UNSIGNED_SHORT_4_4_4_4 && (le = s.RGBA4),
            $ === s.UNSIGNED_SHORT_5_5_5_1 && (le = s.RGB5_A1)
        }
        return (le === s.R16F || le === s.R32F || le === s.RG16F || le === s.RG32F || le === s.RGBA16F || le === s.RGBA32F) && e.get("EXT_color_buffer_float"),
        le
    }
    function C(P, M) {
        let $;
        return P ? M === null || M === Xr || M === Da ? $ = s.DEPTH24_STENCIL8 : M === Bi ? $ = s.DEPTH32F_STENCIL8 : M === Na && ($ = s.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === Xr || M === Da ? $ = s.DEPTH_COMPONENT24 : M === Bi ? $ = s.DEPTH_COMPONENT32F : M === Na && ($ = s.DEPTH_COMPONENT16),
        $
    }
    function H(P, M) {
        return y(P) === !0 || P.isFramebufferTexture && P.minFilter !== hi && P.minFilter !== xi ? Math.log2(Math.max(M.width, M.height)) + 1 : P.mipmaps !== void 0 && P.mipmaps.length > 0 ? P.mipmaps.length : P.isCompressedTexture && Array.isArray(P.image) ? M.mipmaps.length : 1
    }
    function k(P) {
        const M = P.target;
        M.removeEventListener("dispose", k),
        j(M),
        M.isVideoTexture && v.delete(M)
    }
    function F(P) {
        const M = P.target;
        M.removeEventListener("dispose", F),
        R(M)
    }
    function j(P) {
        const M = r.get(P);
        if (M.__webglInit === void 0)
            return;
        const $ = P.source
          , fe = x.get($);
        if (fe) {
            const ve = fe[M.__cacheKey];
            ve.usedTimes--,
            ve.usedTimes === 0 && b(P),
            Object.keys(fe).length === 0 && x.delete($)
        }
        r.remove(P)
    }
    function b(P) {
        const M = r.get(P);
        s.deleteTexture(M.__webglTexture);
        const $ = P.source
          , fe = x.get($);
        delete fe[M.__cacheKey],
        u.memory.textures--
    }
    function R(P) {
        const M = r.get(P);
        if (P.depthTexture && (P.depthTexture.dispose(),
        r.remove(P.depthTexture)),
        P.isWebGLCubeRenderTarget)
            for (let fe = 0; fe < 6; fe++) {
                if (Array.isArray(M.__webglFramebuffer[fe]))
                    for (let ve = 0; ve < M.__webglFramebuffer[fe].length; ve++)
                        s.deleteFramebuffer(M.__webglFramebuffer[fe][ve]);
                else
                    s.deleteFramebuffer(M.__webglFramebuffer[fe]);
                M.__webglDepthbuffer && s.deleteRenderbuffer(M.__webglDepthbuffer[fe])
            }
        else {
            if (Array.isArray(M.__webglFramebuffer))
                for (let fe = 0; fe < M.__webglFramebuffer.length; fe++)
                    s.deleteFramebuffer(M.__webglFramebuffer[fe]);
            else
                s.deleteFramebuffer(M.__webglFramebuffer);
            if (M.__webglDepthbuffer && s.deleteRenderbuffer(M.__webglDepthbuffer),
            M.__webglMultisampledFramebuffer && s.deleteFramebuffer(M.__webglMultisampledFramebuffer),
            M.__webglColorRenderbuffer)
                for (let fe = 0; fe < M.__webglColorRenderbuffer.length; fe++)
                    M.__webglColorRenderbuffer[fe] && s.deleteRenderbuffer(M.__webglColorRenderbuffer[fe]);
            M.__webglDepthRenderbuffer && s.deleteRenderbuffer(M.__webglDepthRenderbuffer)
        }
        const $ = P.textures;
        for (let fe = 0, ve = $.length; fe < ve; fe++) {
            const le = r.get($[fe]);
            le.__webglTexture && (s.deleteTexture(le.__webglTexture),
            u.memory.textures--),
            r.remove($[fe])
        }
        r.remove(P)
    }
    let I = 0;
    function oe() {
        I = 0
    }
    function se() {
        const P = I;
        return P >= o.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + P + " texture units while this GPU supports only " + o.maxTextures),
        I += 1,
        P
    }
    function ce(P) {
        const M = [];
        return M.push(P.wrapS),
        M.push(P.wrapT),
        M.push(P.wrapR || 0),
        M.push(P.magFilter),
        M.push(P.minFilter),
        M.push(P.anisotropy),
        M.push(P.internalFormat),
        M.push(P.format),
        M.push(P.type),
        M.push(P.generateMipmaps),
        M.push(P.premultiplyAlpha),
        M.push(P.flipY),
        M.push(P.unpackAlignment),
        M.push(P.colorSpace),
        M.join()
    }
    function ne(P, M) {
        const $ = r.get(P);
        if (P.isVideoTexture && lt(P),
        P.isRenderTargetTexture === !1 && P.isExternalTexture !== !0 && P.version > 0 && $.__version !== P.version) {
            const fe = P.image;
            if (fe === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (fe.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                me($, P, M);
                return
            }
        } else
            P.isExternalTexture && ($.__webglTexture = P.sourceTexture ? P.sourceTexture : null);
        n.bindTexture(s.TEXTURE_2D, $.__webglTexture, s.TEXTURE0 + M)
    }
    function ae(P, M) {
        const $ = r.get(P);
        if (P.isRenderTargetTexture === !1 && P.version > 0 && $.__version !== P.version) {
            me($, P, M);
            return
        }
        n.bindTexture(s.TEXTURE_2D_ARRAY, $.__webglTexture, s.TEXTURE0 + M)
    }
    function de(P, M) {
        const $ = r.get(P);
        if (P.isRenderTargetTexture === !1 && P.version > 0 && $.__version !== P.version) {
            me($, P, M);
            return
        }
        n.bindTexture(s.TEXTURE_3D, $.__webglTexture, s.TEXTURE0 + M)
    }
    function V(P, M) {
        const $ = r.get(P);
        if (P.version > 0 && $.__version !== P.version) {
            pe($, P, M);
            return
        }
        n.bindTexture(s.TEXTURE_CUBE_MAP, $.__webglTexture, s.TEXTURE0 + M)
    }
    const ue = {
        [cd]: s.REPEAT,
        [Gr]: s.CLAMP_TO_EDGE,
        [ud]: s.MIRRORED_REPEAT
    }
      , re = {
        [hi]: s.NEAREST,
        [F_]: s.NEAREST_MIPMAP_NEAREST,
        [$o]: s.NEAREST_MIPMAP_LINEAR,
        [xi]: s.LINEAR,
        [vu]: s.LINEAR_MIPMAP_NEAREST,
        [Wr]: s.LINEAR_MIPMAP_LINEAR
    }
      , U = {
        [B_]: s.NEVER,
        [X_]: s.ALWAYS,
        [H_]: s.LESS,
        [Zm]: s.LEQUAL,
        [V_]: s.EQUAL,
        [W_]: s.GEQUAL,
        [j_]: s.GREATER,
        [G_]: s.NOTEQUAL
    };
    function ie(P, M) {
        if (M.type === Bi && e.has("OES_texture_float_linear") === !1 && (M.magFilter === xi || M.magFilter === vu || M.magFilter === $o || M.magFilter === Wr || M.minFilter === xi || M.minFilter === vu || M.minFilter === $o || M.minFilter === Wr) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        s.texParameteri(P, s.TEXTURE_WRAP_S, ue[M.wrapS]),
        s.texParameteri(P, s.TEXTURE_WRAP_T, ue[M.wrapT]),
        (P === s.TEXTURE_3D || P === s.TEXTURE_2D_ARRAY) && s.texParameteri(P, s.TEXTURE_WRAP_R, ue[M.wrapR]),
        s.texParameteri(P, s.TEXTURE_MAG_FILTER, re[M.magFilter]),
        s.texParameteri(P, s.TEXTURE_MIN_FILTER, re[M.minFilter]),
        M.compareFunction && (s.texParameteri(P, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE),
        s.texParameteri(P, s.TEXTURE_COMPARE_FUNC, U[M.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (M.magFilter === hi || M.minFilter !== $o && M.minFilter !== Wr || M.type === Bi && e.has("OES_texture_float_linear") === !1)
                return;
            if (M.anisotropy > 1 || r.get(M).__currentAnisotropy) {
                const $ = e.get("EXT_texture_filter_anisotropic");
                s.texParameterf(P, $.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, o.getMaxAnisotropy())),
                r.get(M).__currentAnisotropy = M.anisotropy
            }
        }
    }
    function ke(P, M) {
        let $ = !1;
        P.__webglInit === void 0 && (P.__webglInit = !0,
        M.addEventListener("dispose", k));
        const fe = M.source;
        let ve = x.get(fe);
        ve === void 0 && (ve = {},
        x.set(fe, ve));
        const le = ce(M);
        if (le !== P.__cacheKey) {
            ve[le] === void 0 && (ve[le] = {
                texture: s.createTexture(),
                usedTimes: 0
            },
            u.memory.textures++,
            $ = !0),
            ve[le].usedTimes++;
            const Ye = ve[P.__cacheKey];
            Ye !== void 0 && (ve[P.__cacheKey].usedTimes--,
            Ye.usedTimes === 0 && b(M)),
            P.__cacheKey = le,
            P.__webglTexture = ve[le].texture
        }
        return $
    }
    function ze(P, M, $) {
        return Math.floor(Math.floor(P / $) / M)
    }
    function Q(P, M, $, fe) {
        const le = P.updateRanges;
        if (le.length === 0)
            n.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, M.width, M.height, $, fe, M.data);
        else {
            le.sort( (Me, Ne) => Me.start - Ne.start);
            let Ye = 0;
            for (let Me = 1; Me < le.length; Me++) {
                const Ne = le[Ye]
                  , it = le[Me]
                  , We = Ne.start + Ne.count
                  , Re = ze(it.start, M.width, 4)
                  , ct = ze(Ne.start, M.width, 4);
                it.start <= We + 1 && Re === ct && ze(it.start + it.count - 1, M.width, 4) === Re ? Ne.count = Math.max(Ne.count, it.start + it.count - Ne.start) : (++Ye,
                le[Ye] = it)
            }
            le.length = Ye + 1;
            const Te = s.getParameter(s.UNPACK_ROW_LENGTH)
              , Be = s.getParameter(s.UNPACK_SKIP_PIXELS)
              , Je = s.getParameter(s.UNPACK_SKIP_ROWS);
            s.pixelStorei(s.UNPACK_ROW_LENGTH, M.width);
            for (let Me = 0, Ne = le.length; Me < Ne; Me++) {
                const it = le[Me]
                  , We = Math.floor(it.start / 4)
                  , Re = Math.ceil(it.count / 4)
                  , ct = We % M.width
                  , G = Math.floor(We / M.width)
                  , Se = Re
                  , Ae = 1;
                s.pixelStorei(s.UNPACK_SKIP_PIXELS, ct),
                s.pixelStorei(s.UNPACK_SKIP_ROWS, G),
                n.texSubImage2D(s.TEXTURE_2D, 0, ct, G, Se, Ae, $, fe, M.data)
            }
            P.clearUpdateRanges(),
            s.pixelStorei(s.UNPACK_ROW_LENGTH, Te),
            s.pixelStorei(s.UNPACK_SKIP_PIXELS, Be),
            s.pixelStorei(s.UNPACK_SKIP_ROWS, Je)
        }
    }
    function me(P, M, $) {
        let fe = s.TEXTURE_2D;
        (M.isDataArrayTexture || M.isCompressedArrayTexture) && (fe = s.TEXTURE_2D_ARRAY),
        M.isData3DTexture && (fe = s.TEXTURE_3D);
        const ve = ke(P, M)
          , le = M.source;
        n.bindTexture(fe, P.__webglTexture, s.TEXTURE0 + $);
        const Ye = r.get(le);
        if (le.version !== Ye.__version || ve === !0) {
            n.activeTexture(s.TEXTURE0 + $);
            const Te = Et.getPrimaries(Et.workingColorSpace)
              , Be = M.colorSpace === pr ? null : Et.getPrimaries(M.colorSpace)
              , Je = M.colorSpace === pr || Te === Be ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, M.flipY),
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha),
            s.pixelStorei(s.UNPACK_ALIGNMENT, M.unpackAlignment),
            s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Je);
            let Me = T(M.image, !1, o.maxTextureSize);
            Me = Ot(M, Me);
            const Ne = l.convert(M.format, M.colorSpace)
              , it = l.convert(M.type);
            let We = L(M.internalFormat, Ne, it, M.colorSpace, M.isVideoTexture);
            ie(fe, M);
            let Re;
            const ct = M.mipmaps
              , G = M.isVideoTexture !== !0
              , Se = Ye.__version === void 0 || ve === !0
              , Ae = le.dataReady
              , De = H(M, Me);
            if (M.isDepthTexture)
                We = C(M.format === Ua, M.type),
                Se && (G ? n.texStorage2D(s.TEXTURE_2D, 1, We, Me.width, Me.height) : n.texImage2D(s.TEXTURE_2D, 0, We, Me.width, Me.height, 0, Ne, it, null));
            else if (M.isDataTexture)
                if (ct.length > 0) {
                    G && Se && n.texStorage2D(s.TEXTURE_2D, De, We, ct[0].width, ct[0].height);
                    for (let ye = 0, he = ct.length; ye < he; ye++)
                        Re = ct[ye],
                        G ? Ae && n.texSubImage2D(s.TEXTURE_2D, ye, 0, 0, Re.width, Re.height, Ne, it, Re.data) : n.texImage2D(s.TEXTURE_2D, ye, We, Re.width, Re.height, 0, Ne, it, Re.data);
                    M.generateMipmaps = !1
                } else
                    G ? (Se && n.texStorage2D(s.TEXTURE_2D, De, We, Me.width, Me.height),
                    Ae && Q(M, Me, Ne, it)) : n.texImage2D(s.TEXTURE_2D, 0, We, Me.width, Me.height, 0, Ne, it, Me.data);
            else if (M.isCompressedTexture)
                if (M.isCompressedArrayTexture) {
                    G && Se && n.texStorage3D(s.TEXTURE_2D_ARRAY, De, We, ct[0].width, ct[0].height, Me.depth);
                    for (let ye = 0, he = ct.length; ye < he; ye++)
                        if (Re = ct[ye],
                        M.format !== di)
                            if (Ne !== null)
                                if (G) {
                                    if (Ae)
                                        if (M.layerUpdates.size > 0) {
                                            const je = gm(Re.width, Re.height, M.format, M.type);
                                            for (const ot of M.layerUpdates) {
                                                const Ct = Re.data.subarray(ot * je / Re.data.BYTES_PER_ELEMENT, (ot + 1) * je / Re.data.BYTES_PER_ELEMENT);
                                                n.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, ye, 0, 0, ot, Re.width, Re.height, 1, Ne, Ct)
                                            }
                                            M.clearLayerUpdates()
                                        } else
                                            n.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, ye, 0, 0, 0, Re.width, Re.height, Me.depth, Ne, Re.data)
                                } else
                                    n.compressedTexImage3D(s.TEXTURE_2D_ARRAY, ye, We, Re.width, Re.height, Me.depth, 0, Re.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            G ? Ae && n.texSubImage3D(s.TEXTURE_2D_ARRAY, ye, 0, 0, 0, Re.width, Re.height, Me.depth, Ne, it, Re.data) : n.texImage3D(s.TEXTURE_2D_ARRAY, ye, We, Re.width, Re.height, Me.depth, 0, Ne, it, Re.data)
                } else {
                    G && Se && n.texStorage2D(s.TEXTURE_2D, De, We, ct[0].width, ct[0].height);
                    for (let ye = 0, he = ct.length; ye < he; ye++)
                        Re = ct[ye],
                        M.format !== di ? Ne !== null ? G ? Ae && n.compressedTexSubImage2D(s.TEXTURE_2D, ye, 0, 0, Re.width, Re.height, Ne, Re.data) : n.compressedTexImage2D(s.TEXTURE_2D, ye, We, Re.width, Re.height, 0, Re.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : G ? Ae && n.texSubImage2D(s.TEXTURE_2D, ye, 0, 0, Re.width, Re.height, Ne, it, Re.data) : n.texImage2D(s.TEXTURE_2D, ye, We, Re.width, Re.height, 0, Ne, it, Re.data)
                }
            else if (M.isDataArrayTexture)
                if (G) {
                    if (Se && n.texStorage3D(s.TEXTURE_2D_ARRAY, De, We, Me.width, Me.height, Me.depth),
                    Ae)
                        if (M.layerUpdates.size > 0) {
                            const ye = gm(Me.width, Me.height, M.format, M.type);
                            for (const he of M.layerUpdates) {
                                const je = Me.data.subarray(he * ye / Me.data.BYTES_PER_ELEMENT, (he + 1) * ye / Me.data.BYTES_PER_ELEMENT);
                                n.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, he, Me.width, Me.height, 1, Ne, it, je)
                            }
                            M.clearLayerUpdates()
                        } else
                            n.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Me.width, Me.height, Me.depth, Ne, it, Me.data)
                } else
                    n.texImage3D(s.TEXTURE_2D_ARRAY, 0, We, Me.width, Me.height, Me.depth, 0, Ne, it, Me.data);
            else if (M.isData3DTexture)
                G ? (Se && n.texStorage3D(s.TEXTURE_3D, De, We, Me.width, Me.height, Me.depth),
                Ae && n.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, Me.width, Me.height, Me.depth, Ne, it, Me.data)) : n.texImage3D(s.TEXTURE_3D, 0, We, Me.width, Me.height, Me.depth, 0, Ne, it, Me.data);
            else if (M.isFramebufferTexture) {
                if (Se)
                    if (G)
                        n.texStorage2D(s.TEXTURE_2D, De, We, Me.width, Me.height);
                    else {
                        let ye = Me.width
                          , he = Me.height;
                        for (let je = 0; je < De; je++)
                            n.texImage2D(s.TEXTURE_2D, je, We, ye, he, 0, Ne, it, null),
                            ye >>= 1,
                            he >>= 1
                    }
            } else if (ct.length > 0) {
                if (G && Se) {
                    const ye = zt(ct[0]);
                    n.texStorage2D(s.TEXTURE_2D, De, We, ye.width, ye.height)
                }
                for (let ye = 0, he = ct.length; ye < he; ye++)
                    Re = ct[ye],
                    G ? Ae && n.texSubImage2D(s.TEXTURE_2D, ye, 0, 0, Ne, it, Re) : n.texImage2D(s.TEXTURE_2D, ye, We, Ne, it, Re);
                M.generateMipmaps = !1
            } else if (G) {
                if (Se) {
                    const ye = zt(Me);
                    n.texStorage2D(s.TEXTURE_2D, De, We, ye.width, ye.height)
                }
                Ae && n.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Ne, it, Me)
            } else
                n.texImage2D(s.TEXTURE_2D, 0, We, Ne, it, Me);
            y(M) && g(fe),
            Ye.__version = le.version,
            M.onUpdate && M.onUpdate(M)
        }
        P.__version = M.version
    }
    function pe(P, M, $) {
        if (M.image.length !== 6)
            return;
        const fe = ke(P, M)
          , ve = M.source;
        n.bindTexture(s.TEXTURE_CUBE_MAP, P.__webglTexture, s.TEXTURE0 + $);
        const le = r.get(ve);
        if (ve.version !== le.__version || fe === !0) {
            n.activeTexture(s.TEXTURE0 + $);
            const Ye = Et.getPrimaries(Et.workingColorSpace)
              , Te = M.colorSpace === pr ? null : Et.getPrimaries(M.colorSpace)
              , Be = M.colorSpace === pr || Ye === Te ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, M.flipY),
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha),
            s.pixelStorei(s.UNPACK_ALIGNMENT, M.unpackAlignment),
            s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Be);
            const Je = M.isCompressedTexture || M.image[0].isCompressedTexture
              , Me = M.image[0] && M.image[0].isDataTexture
              , Ne = [];
            for (let he = 0; he < 6; he++)
                !Je && !Me ? Ne[he] = T(M.image[he], !0, o.maxCubemapSize) : Ne[he] = Me ? M.image[he].image : M.image[he],
                Ne[he] = Ot(M, Ne[he]);
            const it = Ne[0]
              , We = l.convert(M.format, M.colorSpace)
              , Re = l.convert(M.type)
              , ct = L(M.internalFormat, We, Re, M.colorSpace)
              , G = M.isVideoTexture !== !0
              , Se = le.__version === void 0 || fe === !0
              , Ae = ve.dataReady;
            let De = H(M, it);
            ie(s.TEXTURE_CUBE_MAP, M);
            let ye;
            if (Je) {
                G && Se && n.texStorage2D(s.TEXTURE_CUBE_MAP, De, ct, it.width, it.height);
                for (let he = 0; he < 6; he++) {
                    ye = Ne[he].mipmaps;
                    for (let je = 0; je < ye.length; je++) {
                        const ot = ye[je];
                        M.format !== di ? We !== null ? G ? Ae && n.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, je, 0, 0, ot.width, ot.height, We, ot.data) : n.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, je, ct, ot.width, ot.height, 0, ot.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : G ? Ae && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, je, 0, 0, ot.width, ot.height, We, Re, ot.data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, je, ct, ot.width, ot.height, 0, We, Re, ot.data)
                    }
                }
            } else {
                if (ye = M.mipmaps,
                G && Se) {
                    ye.length > 0 && De++;
                    const he = zt(Ne[0]);
                    n.texStorage2D(s.TEXTURE_CUBE_MAP, De, ct, he.width, he.height)
                }
                for (let he = 0; he < 6; he++)
                    if (Me) {
                        G ? Ae && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, 0, 0, 0, Ne[he].width, Ne[he].height, We, Re, Ne[he].data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, 0, ct, Ne[he].width, Ne[he].height, 0, We, Re, Ne[he].data);
                        for (let je = 0; je < ye.length; je++) {
                            const Ct = ye[je].image[he].image;
                            G ? Ae && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, je + 1, 0, 0, Ct.width, Ct.height, We, Re, Ct.data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, je + 1, ct, Ct.width, Ct.height, 0, We, Re, Ct.data)
                        }
                    } else {
                        G ? Ae && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, 0, 0, 0, We, Re, Ne[he]) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, 0, ct, We, Re, Ne[he]);
                        for (let je = 0; je < ye.length; je++) {
                            const ot = ye[je];
                            G ? Ae && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, je + 1, 0, 0, We, Re, ot.image[he]) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + he, je + 1, ct, We, Re, ot.image[he])
                        }
                    }
            }
            y(M) && g(s.TEXTURE_CUBE_MAP),
            le.__version = ve.version,
            M.onUpdate && M.onUpdate(M)
        }
        P.__version = M.version
    }
    function Ce(P, M, $, fe, ve, le) {
        const Ye = l.convert($.format, $.colorSpace)
          , Te = l.convert($.type)
          , Be = L($.internalFormat, Ye, Te, $.colorSpace)
          , Je = r.get(M)
          , Me = r.get($);
        if (Me.__renderTarget = M,
        !Je.__hasExternalTextures) {
            const Ne = Math.max(1, M.width >> le)
              , it = Math.max(1, M.height >> le);
            ve === s.TEXTURE_3D || ve === s.TEXTURE_2D_ARRAY ? n.texImage3D(ve, le, Be, Ne, it, M.depth, 0, Ye, Te, null) : n.texImage2D(ve, le, Be, Ne, it, 0, Ye, Te, null)
        }
        n.bindFramebuffer(s.FRAMEBUFFER, P),
        Fe(M) ? f.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, fe, ve, Me.__webglTexture, 0, Nt(M)) : (ve === s.TEXTURE_2D || ve >= s.TEXTURE_CUBE_MAP_POSITIVE_X && ve <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, fe, ve, Me.__webglTexture, le),
        n.bindFramebuffer(s.FRAMEBUFFER, null)
    }
    function Pe(P, M, $) {
        if (s.bindRenderbuffer(s.RENDERBUFFER, P),
        M.depthBuffer) {
            const fe = M.depthTexture
              , ve = fe && fe.isDepthTexture ? fe.type : null
              , le = C(M.stencilBuffer, ve)
              , Ye = M.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
              , Te = Nt(M);
            Fe(M) ? f.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Te, le, M.width, M.height) : $ ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Te, le, M.width, M.height) : s.renderbufferStorage(s.RENDERBUFFER, le, M.width, M.height),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, Ye, s.RENDERBUFFER, P)
        } else {
            const fe = M.textures;
            for (let ve = 0; ve < fe.length; ve++) {
                const le = fe[ve]
                  , Ye = l.convert(le.format, le.colorSpace)
                  , Te = l.convert(le.type)
                  , Be = L(le.internalFormat, Ye, Te, le.colorSpace)
                  , Je = Nt(M);
                $ && Fe(M) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Je, Be, M.width, M.height) : Fe(M) ? f.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Je, Be, M.width, M.height) : s.renderbufferStorage(s.RENDERBUFFER, Be, M.width, M.height)
            }
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null)
    }
    function Ke(P, M) {
        if (M && M.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (n.bindFramebuffer(s.FRAMEBUFFER, P),
        !(M.depthTexture && M.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        const fe = r.get(M.depthTexture);
        fe.__renderTarget = M,
        (!fe.__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width,
        M.depthTexture.image.height = M.height,
        M.depthTexture.needsUpdate = !0),
        ne(M.depthTexture, 0);
        const ve = fe.__webglTexture
          , le = Nt(M);
        if (M.depthTexture.format === Ia)
            Fe(M) ? f.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, ve, 0, le) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, ve, 0);
        else if (M.depthTexture.format === Ua)
            Fe(M) ? f.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, ve, 0, le) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, ve, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Ut(P) {
        const M = r.get(P)
          , $ = P.isWebGLCubeRenderTarget === !0;
        if (M.__boundDepthTexture !== P.depthTexture) {
            const fe = P.depthTexture;
            if (M.__depthDisposeCallback && M.__depthDisposeCallback(),
            fe) {
                const ve = () => {
                    delete M.__boundDepthTexture,
                    delete M.__depthDisposeCallback,
                    fe.removeEventListener("dispose", ve)
                }
                ;
                fe.addEventListener("dispose", ve),
                M.__depthDisposeCallback = ve
            }
            M.__boundDepthTexture = fe
        }
        if (P.depthTexture && !M.__autoAllocateDepthBuffer) {
            if ($)
                throw new Error("target.depthTexture not supported in Cube render targets");
            const fe = P.texture.mipmaps;
            fe && fe.length > 0 ? Ke(M.__webglFramebuffer[0], P) : Ke(M.__webglFramebuffer, P)
        } else if ($) {
            M.__webglDepthbuffer = [];
            for (let fe = 0; fe < 6; fe++)
                if (n.bindFramebuffer(s.FRAMEBUFFER, M.__webglFramebuffer[fe]),
                M.__webglDepthbuffer[fe] === void 0)
                    M.__webglDepthbuffer[fe] = s.createRenderbuffer(),
                    Pe(M.__webglDepthbuffer[fe], P, !1);
                else {
                    const ve = P.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
                      , le = M.__webglDepthbuffer[fe];
                    s.bindRenderbuffer(s.RENDERBUFFER, le),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, ve, s.RENDERBUFFER, le)
                }
        } else {
            const fe = P.texture.mipmaps;
            if (fe && fe.length > 0 ? n.bindFramebuffer(s.FRAMEBUFFER, M.__webglFramebuffer[0]) : n.bindFramebuffer(s.FRAMEBUFFER, M.__webglFramebuffer),
            M.__webglDepthbuffer === void 0)
                M.__webglDepthbuffer = s.createRenderbuffer(),
                Pe(M.__webglDepthbuffer, P, !1);
            else {
                const ve = P.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
                  , le = M.__webglDepthbuffer;
                s.bindRenderbuffer(s.RENDERBUFFER, le),
                s.framebufferRenderbuffer(s.FRAMEBUFFER, ve, s.RENDERBUFFER, le)
            }
        }
        n.bindFramebuffer(s.FRAMEBUFFER, null)
    }
    function gt(P, M, $) {
        const fe = r.get(P);
        M !== void 0 && Ce(fe.__webglFramebuffer, P, P.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0),
        $ !== void 0 && Ut(P)
    }
    function z(P) {
        const M = P.texture
          , $ = r.get(P)
          , fe = r.get(M);
        P.addEventListener("dispose", F);
        const ve = P.textures
          , le = P.isWebGLCubeRenderTarget === !0
          , Ye = ve.length > 1;
        if (Ye || (fe.__webglTexture === void 0 && (fe.__webglTexture = s.createTexture()),
        fe.__version = M.version,
        u.memory.textures++),
        le) {
            $.__webglFramebuffer = [];
            for (let Te = 0; Te < 6; Te++)
                if (M.mipmaps && M.mipmaps.length > 0) {
                    $.__webglFramebuffer[Te] = [];
                    for (let Be = 0; Be < M.mipmaps.length; Be++)
                        $.__webglFramebuffer[Te][Be] = s.createFramebuffer()
                } else
                    $.__webglFramebuffer[Te] = s.createFramebuffer()
        } else {
            if (M.mipmaps && M.mipmaps.length > 0) {
                $.__webglFramebuffer = [];
                for (let Te = 0; Te < M.mipmaps.length; Te++)
                    $.__webglFramebuffer[Te] = s.createFramebuffer()
            } else
                $.__webglFramebuffer = s.createFramebuffer();
            if (Ye)
                for (let Te = 0, Be = ve.length; Te < Be; Te++) {
                    const Je = r.get(ve[Te]);
                    Je.__webglTexture === void 0 && (Je.__webglTexture = s.createTexture(),
                    u.memory.textures++)
                }
            if (P.samples > 0 && Fe(P) === !1) {
                $.__webglMultisampledFramebuffer = s.createFramebuffer(),
                $.__webglColorRenderbuffer = [],
                n.bindFramebuffer(s.FRAMEBUFFER, $.__webglMultisampledFramebuffer);
                for (let Te = 0; Te < ve.length; Te++) {
                    const Be = ve[Te];
                    $.__webglColorRenderbuffer[Te] = s.createRenderbuffer(),
                    s.bindRenderbuffer(s.RENDERBUFFER, $.__webglColorRenderbuffer[Te]);
                    const Je = l.convert(Be.format, Be.colorSpace)
                      , Me = l.convert(Be.type)
                      , Ne = L(Be.internalFormat, Je, Me, Be.colorSpace, P.isXRRenderTarget === !0)
                      , it = Nt(P);
                    s.renderbufferStorageMultisample(s.RENDERBUFFER, it, Ne, P.width, P.height),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Te, s.RENDERBUFFER, $.__webglColorRenderbuffer[Te])
                }
                s.bindRenderbuffer(s.RENDERBUFFER, null),
                P.depthBuffer && ($.__webglDepthRenderbuffer = s.createRenderbuffer(),
                Pe($.__webglDepthRenderbuffer, P, !0)),
                n.bindFramebuffer(s.FRAMEBUFFER, null)
            }
        }
        if (le) {
            n.bindTexture(s.TEXTURE_CUBE_MAP, fe.__webglTexture),
            ie(s.TEXTURE_CUBE_MAP, M);
            for (let Te = 0; Te < 6; Te++)
                if (M.mipmaps && M.mipmaps.length > 0)
                    for (let Be = 0; Be < M.mipmaps.length; Be++)
                        Ce($.__webglFramebuffer[Te][Be], P, M, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Be);
                else
                    Ce($.__webglFramebuffer[Te], P, M, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0);
            y(M) && g(s.TEXTURE_CUBE_MAP),
            n.unbindTexture()
        } else if (Ye) {
            for (let Te = 0, Be = ve.length; Te < Be; Te++) {
                const Je = ve[Te]
                  , Me = r.get(Je);
                let Ne = s.TEXTURE_2D;
                (P.isWebGL3DRenderTarget || P.isWebGLArrayRenderTarget) && (Ne = P.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY),
                n.bindTexture(Ne, Me.__webglTexture),
                ie(Ne, Je),
                Ce($.__webglFramebuffer, P, Je, s.COLOR_ATTACHMENT0 + Te, Ne, 0),
                y(Je) && g(Ne)
            }
            n.unbindTexture()
        } else {
            let Te = s.TEXTURE_2D;
            if ((P.isWebGL3DRenderTarget || P.isWebGLArrayRenderTarget) && (Te = P.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY),
            n.bindTexture(Te, fe.__webglTexture),
            ie(Te, M),
            M.mipmaps && M.mipmaps.length > 0)
                for (let Be = 0; Be < M.mipmaps.length; Be++)
                    Ce($.__webglFramebuffer[Be], P, M, s.COLOR_ATTACHMENT0, Te, Be);
            else
                Ce($.__webglFramebuffer, P, M, s.COLOR_ATTACHMENT0, Te, 0);
            y(M) && g(Te),
            n.unbindTexture()
        }
        P.depthBuffer && Ut(P)
    }
    function Tt(P) {
        const M = P.textures;
        for (let $ = 0, fe = M.length; $ < fe; $++) {
            const ve = M[$];
            if (y(ve)) {
                const le = N(P)
                  , Ye = r.get(ve).__webglTexture;
                n.bindTexture(le, Ye),
                g(le),
                n.unbindTexture()
            }
        }
    }
    const Qe = []
      , xt = [];
    function qe(P) {
        if (P.samples > 0) {
            if (Fe(P) === !1) {
                const M = P.textures
                  , $ = P.width
                  , fe = P.height;
                let ve = s.COLOR_BUFFER_BIT;
                const le = P.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
                  , Ye = r.get(P)
                  , Te = M.length > 1;
                if (Te)
                    for (let Je = 0; Je < M.length; Je++)
                        n.bindFramebuffer(s.FRAMEBUFFER, Ye.__webglMultisampledFramebuffer),
                        s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Je, s.RENDERBUFFER, null),
                        n.bindFramebuffer(s.FRAMEBUFFER, Ye.__webglFramebuffer),
                        s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Je, s.TEXTURE_2D, null, 0);
                n.bindFramebuffer(s.READ_FRAMEBUFFER, Ye.__webglMultisampledFramebuffer);
                const Be = P.texture.mipmaps;
                Be && Be.length > 0 ? n.bindFramebuffer(s.DRAW_FRAMEBUFFER, Ye.__webglFramebuffer[0]) : n.bindFramebuffer(s.DRAW_FRAMEBUFFER, Ye.__webglFramebuffer);
                for (let Je = 0; Je < M.length; Je++) {
                    if (P.resolveDepthBuffer && (P.depthBuffer && (ve |= s.DEPTH_BUFFER_BIT),
                    P.stencilBuffer && P.resolveStencilBuffer && (ve |= s.STENCIL_BUFFER_BIT)),
                    Te) {
                        s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Ye.__webglColorRenderbuffer[Je]);
                        const Me = r.get(M[Je]).__webglTexture;
                        s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, Me, 0)
                    }
                    s.blitFramebuffer(0, 0, $, fe, 0, 0, $, fe, ve, s.NEAREST),
                    m === !0 && (Qe.length = 0,
                    xt.length = 0,
                    Qe.push(s.COLOR_ATTACHMENT0 + Je),
                    P.depthBuffer && P.resolveDepthBuffer === !1 && (Qe.push(le),
                    xt.push(le),
                    s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, xt)),
                    s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Qe))
                }
                if (n.bindFramebuffer(s.READ_FRAMEBUFFER, null),
                n.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
                Te)
                    for (let Je = 0; Je < M.length; Je++) {
                        n.bindFramebuffer(s.FRAMEBUFFER, Ye.__webglMultisampledFramebuffer),
                        s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Je, s.RENDERBUFFER, Ye.__webglColorRenderbuffer[Je]);
                        const Me = r.get(M[Je]).__webglTexture;
                        n.bindFramebuffer(s.FRAMEBUFFER, Ye.__webglFramebuffer),
                        s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Je, s.TEXTURE_2D, Me, 0)
                    }
                n.bindFramebuffer(s.DRAW_FRAMEBUFFER, Ye.__webglMultisampledFramebuffer)
            } else if (P.depthBuffer && P.resolveDepthBuffer === !1 && m) {
                const M = P.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
                s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [M])
            }
        }
    }
    function Nt(P) {
        return Math.min(o.maxSamples, P.samples)
    }
    function Fe(P) {
        const M = r.get(P);
        return P.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && M.__useRenderToTexture !== !1
    }
    function lt(P) {
        const M = u.render.frame;
        v.get(P) !== M && (v.set(P, M),
        P.update())
    }
    function Ot(P, M) {
        const $ = P.colorSpace
          , fe = P.format
          , ve = P.type;
        return P.isCompressedTexture === !0 || P.isVideoTexture === !0 || $ !== Hs && $ !== pr && (Et.getTransfer($) === Lt ? (fe !== di || ve !== Si) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", $)),
        M
    }
    function zt(P) {
        return typeof HTMLImageElement < "u" && P instanceof HTMLImageElement ? (p.width = P.naturalWidth || P.width,
        p.height = P.naturalHeight || P.height) : typeof VideoFrame < "u" && P instanceof VideoFrame ? (p.width = P.displayWidth,
        p.height = P.displayHeight) : (p.width = P.width,
        p.height = P.height),
        p
    }
    this.allocateTextureUnit = se,
    this.resetTextureUnits = oe,
    this.setTexture2D = ne,
    this.setTexture2DArray = ae,
    this.setTexture3D = de,
    this.setTextureCube = V,
    this.rebindTextures = gt,
    this.setupRenderTarget = z,
    this.updateRenderTargetMipmap = Tt,
    this.updateMultisampleRenderTarget = qe,
    this.setupDepthRenderbuffer = Ut,
    this.setupFrameBufferTexture = Ce,
    this.useMultisampledRTT = Fe
}
function lM(s, e) {
    function n(r, o=pr) {
        let l;
        const u = Et.getTransfer(o);
        if (r === Si)
            return s.UNSIGNED_BYTE;
        if (r === Gd)
            return s.UNSIGNED_SHORT_4_4_4_4;
        if (r === Wd)
            return s.UNSIGNED_SHORT_5_5_5_1;
        if (r === Xm)
            return s.UNSIGNED_INT_5_9_9_9_REV;
        if (r === Gm)
            return s.BYTE;
        if (r === Wm)
            return s.SHORT;
        if (r === Na)
            return s.UNSIGNED_SHORT;
        if (r === jd)
            return s.INT;
        if (r === Xr)
            return s.UNSIGNED_INT;
        if (r === Bi)
            return s.FLOAT;
        if (r === Fa)
            return s.HALF_FLOAT;
        if (r === Ym)
            return s.ALPHA;
        if (r === Jm)
            return s.RGB;
        if (r === di)
            return s.RGBA;
        if (r === Ia)
            return s.DEPTH_COMPONENT;
        if (r === Ua)
            return s.DEPTH_STENCIL;
        if (r === qm)
            return s.RED;
        if (r === Xd)
            return s.RED_INTEGER;
        if (r === $m)
            return s.RG;
        if (r === Yd)
            return s.RG_INTEGER;
        if (r === Jd)
            return s.RGBA_INTEGER;
        if (r === wl || r === Ml || r === El || r === Tl)
            if (u === Lt)
                if (l = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                l !== null) {
                    if (r === wl)
                        return l.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (r === Ml)
                        return l.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (r === El)
                        return l.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (r === Tl)
                        return l.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (l = e.get("WEBGL_compressed_texture_s3tc"),
            l !== null) {
                if (r === wl)
                    return l.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (r === Ml)
                    return l.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (r === El)
                    return l.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (r === Tl)
                    return l.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (r === dd || r === fd || r === hd || r === pd)
            if (l = e.get("WEBGL_compressed_texture_pvrtc"),
            l !== null) {
                if (r === dd)
                    return l.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (r === fd)
                    return l.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (r === hd)
                    return l.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (r === pd)
                    return l.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (r === md || r === gd || r === _d)
            if (l = e.get("WEBGL_compressed_texture_etc"),
            l !== null) {
                if (r === md || r === gd)
                    return u === Lt ? l.COMPRESSED_SRGB8_ETC2 : l.COMPRESSED_RGB8_ETC2;
                if (r === _d)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : l.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (r === vd || r === xd || r === yd || r === Sd || r === wd || r === Md || r === Ed || r === Td || r === Ad || r === Cd || r === Rd || r === bd || r === Ld || r === Pd)
            if (l = e.get("WEBGL_compressed_texture_astc"),
            l !== null) {
                if (r === vd)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : l.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (r === xd)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : l.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (r === yd)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : l.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (r === Sd)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : l.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (r === wd)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : l.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (r === Md)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : l.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (r === Ed)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : l.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (r === Td)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : l.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (r === Ad)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : l.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (r === Cd)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : l.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (r === Rd)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : l.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (r === bd)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : l.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (r === Ld)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : l.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (r === Pd)
                    return u === Lt ? l.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : l.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (r === Al || r === Nd || r === Dd)
            if (l = e.get("EXT_texture_compression_bptc"),
            l !== null) {
                if (r === Al)
                    return u === Lt ? l.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : l.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (r === Nd)
                    return l.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (r === Dd)
                    return l.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (r === Km || r === Id || r === Ud || r === Fd)
            if (l = e.get("EXT_texture_compression_rgtc"),
            l !== null) {
                if (r === Al)
                    return l.COMPRESSED_RED_RGTC1_EXT;
                if (r === Id)
                    return l.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (r === Ud)
                    return l.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (r === Fd)
                    return l.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return r === Da ? s.UNSIGNED_INT_24_8 : s[r] !== void 0 ? s[r] : null
    }
    return {
        convert: n
    }
}
class vg extends Dn {
    constructor(e=null) {
        super(),
        this.sourceTexture = e,
        this.isExternalTexture = !0
    }
}
const cM = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , uM = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class dM {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, n) {
        if (this.texture === null) {
            const r = new vg(e.texture);
            (e.depthNear !== n.depthNear || e.depthFar !== n.depthFar) && (this.depthNear = e.depthNear,
            this.depthFar = e.depthFar),
            this.texture = r
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const n = e.cameras[0].viewport
              , r = new vr({
                vertexShader: cM,
                fragmentShader: uM,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: n.z
                    },
                    depthHeight: {
                        value: n.w
                    }
                }
            });
            this.mesh = new fi(new Il(20,20),r)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class fM extends js {
    constructor(e, n) {
        super();
        const r = this;
        let o = null
          , l = 1
          , u = null
          , f = "local-floor"
          , m = 1
          , p = null
          , v = null
          , _ = null
          , x = null
          , S = null
          , E = null;
        const T = new dM
          , y = {}
          , g = n.getContextAttributes();
        let N = null
          , L = null;
        const C = []
          , H = []
          , k = new vt;
        let F = null;
        const j = new jn;
        j.viewport = new Pt;
        const b = new jn;
        b.viewport = new Pt;
        const R = [j, b]
          , I = new Nv;
        let oe = null
          , se = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(Q) {
            let me = C[Q];
            return me === void 0 && (me = new Hu,
            C[Q] = me),
            me.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(Q) {
            let me = C[Q];
            return me === void 0 && (me = new Hu,
            C[Q] = me),
            me.getGripSpace()
        }
        ,
        this.getHand = function(Q) {
            let me = C[Q];
            return me === void 0 && (me = new Hu,
            C[Q] = me),
            me.getHandSpace()
        }
        ;
        function ce(Q) {
            const me = H.indexOf(Q.inputSource);
            if (me === -1)
                return;
            const pe = C[me];
            pe !== void 0 && (pe.update(Q.inputSource, Q.frame, p || u),
            pe.dispatchEvent({
                type: Q.type,
                data: Q.inputSource
            }))
        }
        function ne() {
            o.removeEventListener("select", ce),
            o.removeEventListener("selectstart", ce),
            o.removeEventListener("selectend", ce),
            o.removeEventListener("squeeze", ce),
            o.removeEventListener("squeezestart", ce),
            o.removeEventListener("squeezeend", ce),
            o.removeEventListener("end", ne),
            o.removeEventListener("inputsourceschange", ae);
            for (let Q = 0; Q < C.length; Q++) {
                const me = H[Q];
                me !== null && (H[Q] = null,
                C[Q].disconnect(me))
            }
            oe = null,
            se = null,
            T.reset();
            for (const Q in y)
                delete y[Q];
            e.setRenderTarget(N),
            S = null,
            x = null,
            _ = null,
            o = null,
            L = null,
            ze.stop(),
            r.isPresenting = !1,
            e.setPixelRatio(F),
            e.setSize(k.width, k.height, !1),
            r.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(Q) {
            l = Q,
            r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(Q) {
            f = Q,
            r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return p || u
        }
        ,
        this.setReferenceSpace = function(Q) {
            p = Q
        }
        ,
        this.getBaseLayer = function() {
            return x !== null ? x : S
        }
        ,
        this.getBinding = function() {
            return _
        }
        ,
        this.getFrame = function() {
            return E
        }
        ,
        this.getSession = function() {
            return o
        }
        ,
        this.setSession = async function(Q) {
            if (o = Q,
            o !== null) {
                if (N = e.getRenderTarget(),
                o.addEventListener("select", ce),
                o.addEventListener("selectstart", ce),
                o.addEventListener("selectend", ce),
                o.addEventListener("squeeze", ce),
                o.addEventListener("squeezestart", ce),
                o.addEventListener("squeezeend", ce),
                o.addEventListener("end", ne),
                o.addEventListener("inputsourceschange", ae),
                g.xrCompatible !== !0 && await n.makeXRCompatible(),
                F = e.getPixelRatio(),
                e.getSize(k),
                typeof XRWebGLBinding < "u" && (_ = new XRWebGLBinding(o,n)),
                _ !== null && "createProjectionLayer"in XRWebGLBinding.prototype) {
                    let pe = null
                      , Ce = null
                      , Pe = null;
                    g.depth && (Pe = g.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24,
                    pe = g.stencil ? Ua : Ia,
                    Ce = g.stencil ? Da : Xr);
                    const Ke = {
                        colorFormat: n.RGBA8,
                        depthFormat: Pe,
                        scaleFactor: l
                    };
                    x = _.createProjectionLayer(Ke),
                    o.updateRenderState({
                        layers: [x]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(x.textureWidth, x.textureHeight, !1),
                    L = new Yr(x.textureWidth,x.textureHeight,{
                        format: di,
                        type: Si,
                        depthTexture: new dg(x.textureWidth,x.textureHeight,Ce,void 0,void 0,void 0,void 0,void 0,void 0,pe),
                        stencilBuffer: g.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: g.antialias ? 4 : 0,
                        resolveDepthBuffer: x.ignoreDepthValues === !1,
                        resolveStencilBuffer: x.ignoreDepthValues === !1
                    })
                } else {
                    const pe = {
                        antialias: g.antialias,
                        alpha: !0,
                        depth: g.depth,
                        stencil: g.stencil,
                        framebufferScaleFactor: l
                    };
                    S = new XRWebGLLayer(o,n,pe),
                    o.updateRenderState({
                        baseLayer: S
                    }),
                    e.setPixelRatio(1),
                    e.setSize(S.framebufferWidth, S.framebufferHeight, !1),
                    L = new Yr(S.framebufferWidth,S.framebufferHeight,{
                        format: di,
                        type: Si,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: g.stencil,
                        resolveDepthBuffer: S.ignoreDepthValues === !1,
                        resolveStencilBuffer: S.ignoreDepthValues === !1
                    })
                }
                L.isXRRenderTarget = !0,
                this.setFoveation(m),
                p = null,
                u = await o.requestReferenceSpace(f),
                ze.setContext(o),
                ze.start(),
                r.isPresenting = !0,
                r.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (o !== null)
                return o.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return T.getDepthTexture()
        }
        ;
        function ae(Q) {
            for (let me = 0; me < Q.removed.length; me++) {
                const pe = Q.removed[me]
                  , Ce = H.indexOf(pe);
                Ce >= 0 && (H[Ce] = null,
                C[Ce].disconnect(pe))
            }
            for (let me = 0; me < Q.added.length; me++) {
                const pe = Q.added[me];
                let Ce = H.indexOf(pe);
                if (Ce === -1) {
                    for (let Ke = 0; Ke < C.length; Ke++)
                        if (Ke >= H.length) {
                            H.push(pe),
                            Ce = Ke;
                            break
                        } else if (H[Ke] === null) {
                            H[Ke] = pe,
                            Ce = Ke;
                            break
                        }
                    if (Ce === -1)
                        break
                }
                const Pe = C[Ce];
                Pe && Pe.connect(pe)
            }
        }
        const de = new J
          , V = new J;
        function ue(Q, me, pe) {
            de.setFromMatrixPosition(me.matrixWorld),
            V.setFromMatrixPosition(pe.matrixWorld);
            const Ce = de.distanceTo(V)
              , Pe = me.projectionMatrix.elements
              , Ke = pe.projectionMatrix.elements
              , Ut = Pe[14] / (Pe[10] - 1)
              , gt = Pe[14] / (Pe[10] + 1)
              , z = (Pe[9] + 1) / Pe[5]
              , Tt = (Pe[9] - 1) / Pe[5]
              , Qe = (Pe[8] - 1) / Pe[0]
              , xt = (Ke[8] + 1) / Ke[0]
              , qe = Ut * Qe
              , Nt = Ut * xt
              , Fe = Ce / (-Qe + xt)
              , lt = Fe * -Qe;
            if (me.matrixWorld.decompose(Q.position, Q.quaternion, Q.scale),
            Q.translateX(lt),
            Q.translateZ(Fe),
            Q.matrixWorld.compose(Q.position, Q.quaternion, Q.scale),
            Q.matrixWorldInverse.copy(Q.matrixWorld).invert(),
            Pe[10] === -1)
                Q.projectionMatrix.copy(me.projectionMatrix),
                Q.projectionMatrixInverse.copy(me.projectionMatrixInverse);
            else {
                const Ot = Ut + Fe
                  , zt = gt + Fe
                  , P = qe - lt
                  , M = Nt + (Ce - lt)
                  , $ = z * gt / zt * Ot
                  , fe = Tt * gt / zt * Ot;
                Q.projectionMatrix.makePerspective(P, M, $, fe, Ot, zt),
                Q.projectionMatrixInverse.copy(Q.projectionMatrix).invert()
            }
        }
        function re(Q, me) {
            me === null ? Q.matrixWorld.copy(Q.matrix) : Q.matrixWorld.multiplyMatrices(me.matrixWorld, Q.matrix),
            Q.matrixWorldInverse.copy(Q.matrixWorld).invert()
        }
        this.updateCamera = function(Q) {
            if (o === null)
                return;
            let me = Q.near
              , pe = Q.far;
            T.texture !== null && (T.depthNear > 0 && (me = T.depthNear),
            T.depthFar > 0 && (pe = T.depthFar)),
            I.near = b.near = j.near = me,
            I.far = b.far = j.far = pe,
            (oe !== I.near || se !== I.far) && (o.updateRenderState({
                depthNear: I.near,
                depthFar: I.far
            }),
            oe = I.near,
            se = I.far),
            I.layers.mask = Q.layers.mask | 6,
            j.layers.mask = I.layers.mask & 3,
            b.layers.mask = I.layers.mask & 5;
            const Ce = Q.parent
              , Pe = I.cameras;
            re(I, Ce);
            for (let Ke = 0; Ke < Pe.length; Ke++)
                re(Pe[Ke], Ce);
            Pe.length === 2 ? ue(I, j, b) : I.projectionMatrix.copy(j.projectionMatrix),
            U(Q, I, Ce)
        }
        ;
        function U(Q, me, pe) {
            pe === null ? Q.matrix.copy(me.matrixWorld) : (Q.matrix.copy(pe.matrixWorld),
            Q.matrix.invert(),
            Q.matrix.multiply(me.matrixWorld)),
            Q.matrix.decompose(Q.position, Q.quaternion, Q.scale),
            Q.updateMatrixWorld(!0),
            Q.projectionMatrix.copy(me.projectionMatrix),
            Q.projectionMatrixInverse.copy(me.projectionMatrixInverse),
            Q.isPerspectiveCamera && (Q.fov = Od * 2 * Math.atan(1 / Q.projectionMatrix.elements[5]),
            Q.zoom = 1)
        }
        this.getCamera = function() {
            return I
        }
        ,
        this.getFoveation = function() {
            if (!(x === null && S === null))
                return m
        }
        ,
        this.setFoveation = function(Q) {
            m = Q,
            x !== null && (x.fixedFoveation = Q),
            S !== null && S.fixedFoveation !== void 0 && (S.fixedFoveation = Q)
        }
        ,
        this.hasDepthSensing = function() {
            return T.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return T.getMesh(I)
        }
        ,
        this.getCameraTexture = function(Q) {
            return y[Q]
        }
        ;
        let ie = null;
        function ke(Q, me) {
            if (v = me.getViewerPose(p || u),
            E = me,
            v !== null) {
                const pe = v.views;
                S !== null && (e.setRenderTargetFramebuffer(L, S.framebuffer),
                e.setRenderTarget(L));
                let Ce = !1;
                pe.length !== I.cameras.length && (I.cameras.length = 0,
                Ce = !0);
                for (let gt = 0; gt < pe.length; gt++) {
                    const z = pe[gt];
                    let Tt = null;
                    if (S !== null)
                        Tt = S.getViewport(z);
                    else {
                        const xt = _.getViewSubImage(x, z);
                        Tt = xt.viewport,
                        gt === 0 && (e.setRenderTargetTextures(L, xt.colorTexture, xt.depthStencilTexture),
                        e.setRenderTarget(L))
                    }
                    let Qe = R[gt];
                    Qe === void 0 && (Qe = new jn,
                    Qe.layers.enable(gt),
                    Qe.viewport = new Pt,
                    R[gt] = Qe),
                    Qe.matrix.fromArray(z.transform.matrix),
                    Qe.matrix.decompose(Qe.position, Qe.quaternion, Qe.scale),
                    Qe.projectionMatrix.fromArray(z.projectionMatrix),
                    Qe.projectionMatrixInverse.copy(Qe.projectionMatrix).invert(),
                    Qe.viewport.set(Tt.x, Tt.y, Tt.width, Tt.height),
                    gt === 0 && (I.matrix.copy(Qe.matrix),
                    I.matrix.decompose(I.position, I.quaternion, I.scale)),
                    Ce === !0 && I.cameras.push(Qe)
                }
                const Pe = o.enabledFeatures;
                if (Pe && Pe.includes("depth-sensing") && o.depthUsage == "gpu-optimized" && _) {
                    const gt = _.getDepthInformation(pe[0]);
                    gt && gt.isValid && gt.texture && T.init(gt, o.renderState)
                }
                if (Pe && Pe.includes("camera-access") && (e.state.unbindTexture(),
                _))
                    for (let gt = 0; gt < pe.length; gt++) {
                        const z = pe[gt].camera;
                        if (z) {
                            let Tt = y[z];
                            Tt || (Tt = new vg,
                            y[z] = Tt);
                            const Qe = _.getCameraImage(z);
                            Tt.sourceTexture = Qe
                        }
                    }
            }
            for (let pe = 0; pe < C.length; pe++) {
                const Ce = H[pe]
                  , Pe = C[pe];
                Ce !== null && Pe !== void 0 && Pe.update(Ce, me, p || u)
            }
            ie && ie(Q, me),
            me.detectedPlanes && r.dispatchEvent({
                type: "planesdetected",
                data: me
            }),
            E = null
        }
        const ze = new hg;
        ze.setAnimationLoop(ke),
        this.setAnimationLoop = function(Q) {
            ie = Q
        }
        ,
        this.dispose = function() {}
    }
}
const kr = new wi
  , hM = new Vt;
function pM(s, e) {
    function n(y, g) {
        y.matrixAutoUpdate === !0 && y.updateMatrix(),
        g.value.copy(y.matrix)
    }
    function r(y, g) {
        g.color.getRGB(y.fogColor.value, og(s)),
        g.isFog ? (y.fogNear.value = g.near,
        y.fogFar.value = g.far) : g.isFogExp2 && (y.fogDensity.value = g.density)
    }
    function o(y, g, N, L, C) {
        g.isMeshBasicMaterial || g.isMeshLambertMaterial ? l(y, g) : g.isMeshToonMaterial ? (l(y, g),
        _(y, g)) : g.isMeshPhongMaterial ? (l(y, g),
        v(y, g)) : g.isMeshStandardMaterial ? (l(y, g),
        x(y, g),
        g.isMeshPhysicalMaterial && S(y, g, C)) : g.isMeshMatcapMaterial ? (l(y, g),
        E(y, g)) : g.isMeshDepthMaterial ? l(y, g) : g.isMeshDistanceMaterial ? (l(y, g),
        T(y, g)) : g.isMeshNormalMaterial ? l(y, g) : g.isLineBasicMaterial ? (u(y, g),
        g.isLineDashedMaterial && f(y, g)) : g.isPointsMaterial ? m(y, g, N, L) : g.isSpriteMaterial ? p(y, g) : g.isShadowMaterial ? (y.color.value.copy(g.color),
        y.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1)
    }
    function l(y, g) {
        y.opacity.value = g.opacity,
        g.color && y.diffuse.value.copy(g.color),
        g.emissive && y.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
        g.map && (y.map.value = g.map,
        n(g.map, y.mapTransform)),
        g.alphaMap && (y.alphaMap.value = g.alphaMap,
        n(g.alphaMap, y.alphaMapTransform)),
        g.bumpMap && (y.bumpMap.value = g.bumpMap,
        n(g.bumpMap, y.bumpMapTransform),
        y.bumpScale.value = g.bumpScale,
        g.side === Nn && (y.bumpScale.value *= -1)),
        g.normalMap && (y.normalMap.value = g.normalMap,
        n(g.normalMap, y.normalMapTransform),
        y.normalScale.value.copy(g.normalScale),
        g.side === Nn && y.normalScale.value.negate()),
        g.displacementMap && (y.displacementMap.value = g.displacementMap,
        n(g.displacementMap, y.displacementMapTransform),
        y.displacementScale.value = g.displacementScale,
        y.displacementBias.value = g.displacementBias),
        g.emissiveMap && (y.emissiveMap.value = g.emissiveMap,
        n(g.emissiveMap, y.emissiveMapTransform)),
        g.specularMap && (y.specularMap.value = g.specularMap,
        n(g.specularMap, y.specularMapTransform)),
        g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
        const N = e.get(g)
          , L = N.envMap
          , C = N.envMapRotation;
        L && (y.envMap.value = L,
        kr.copy(C),
        kr.x *= -1,
        kr.y *= -1,
        kr.z *= -1,
        L.isCubeTexture && L.isRenderTargetTexture === !1 && (kr.y *= -1,
        kr.z *= -1),
        y.envMapRotation.value.setFromMatrix4(hM.makeRotationFromEuler(kr)),
        y.flipEnvMap.value = L.isCubeTexture && L.isRenderTargetTexture === !1 ? -1 : 1,
        y.reflectivity.value = g.reflectivity,
        y.ior.value = g.ior,
        y.refractionRatio.value = g.refractionRatio),
        g.lightMap && (y.lightMap.value = g.lightMap,
        y.lightMapIntensity.value = g.lightMapIntensity,
        n(g.lightMap, y.lightMapTransform)),
        g.aoMap && (y.aoMap.value = g.aoMap,
        y.aoMapIntensity.value = g.aoMapIntensity,
        n(g.aoMap, y.aoMapTransform))
    }
    function u(y, g) {
        y.diffuse.value.copy(g.color),
        y.opacity.value = g.opacity,
        g.map && (y.map.value = g.map,
        n(g.map, y.mapTransform))
    }
    function f(y, g) {
        y.dashSize.value = g.dashSize,
        y.totalSize.value = g.dashSize + g.gapSize,
        y.scale.value = g.scale
    }
    function m(y, g, N, L) {
        y.diffuse.value.copy(g.color),
        y.opacity.value = g.opacity,
        y.size.value = g.size * N,
        y.scale.value = L * .5,
        g.map && (y.map.value = g.map,
        n(g.map, y.uvTransform)),
        g.alphaMap && (y.alphaMap.value = g.alphaMap,
        n(g.alphaMap, y.alphaMapTransform)),
        g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest)
    }
    function p(y, g) {
        y.diffuse.value.copy(g.color),
        y.opacity.value = g.opacity,
        y.rotation.value = g.rotation,
        g.map && (y.map.value = g.map,
        n(g.map, y.mapTransform)),
        g.alphaMap && (y.alphaMap.value = g.alphaMap,
        n(g.alphaMap, y.alphaMapTransform)),
        g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest)
    }
    function v(y, g) {
        y.specular.value.copy(g.specular),
        y.shininess.value = Math.max(g.shininess, 1e-4)
    }
    function _(y, g) {
        g.gradientMap && (y.gradientMap.value = g.gradientMap)
    }
    function x(y, g) {
        y.metalness.value = g.metalness,
        g.metalnessMap && (y.metalnessMap.value = g.metalnessMap,
        n(g.metalnessMap, y.metalnessMapTransform)),
        y.roughness.value = g.roughness,
        g.roughnessMap && (y.roughnessMap.value = g.roughnessMap,
        n(g.roughnessMap, y.roughnessMapTransform)),
        g.envMap && (y.envMapIntensity.value = g.envMapIntensity)
    }
    function S(y, g, N) {
        y.ior.value = g.ior,
        g.sheen > 0 && (y.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        y.sheenRoughness.value = g.sheenRoughness,
        g.sheenColorMap && (y.sheenColorMap.value = g.sheenColorMap,
        n(g.sheenColorMap, y.sheenColorMapTransform)),
        g.sheenRoughnessMap && (y.sheenRoughnessMap.value = g.sheenRoughnessMap,
        n(g.sheenRoughnessMap, y.sheenRoughnessMapTransform))),
        g.clearcoat > 0 && (y.clearcoat.value = g.clearcoat,
        y.clearcoatRoughness.value = g.clearcoatRoughness,
        g.clearcoatMap && (y.clearcoatMap.value = g.clearcoatMap,
        n(g.clearcoatMap, y.clearcoatMapTransform)),
        g.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap,
        n(g.clearcoatRoughnessMap, y.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap && (y.clearcoatNormalMap.value = g.clearcoatNormalMap,
        n(g.clearcoatNormalMap, y.clearcoatNormalMapTransform),
        y.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
        g.side === Nn && y.clearcoatNormalScale.value.negate())),
        g.dispersion > 0 && (y.dispersion.value = g.dispersion),
        g.iridescence > 0 && (y.iridescence.value = g.iridescence,
        y.iridescenceIOR.value = g.iridescenceIOR,
        y.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0],
        y.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1],
        g.iridescenceMap && (y.iridescenceMap.value = g.iridescenceMap,
        n(g.iridescenceMap, y.iridescenceMapTransform)),
        g.iridescenceThicknessMap && (y.iridescenceThicknessMap.value = g.iridescenceThicknessMap,
        n(g.iridescenceThicknessMap, y.iridescenceThicknessMapTransform))),
        g.transmission > 0 && (y.transmission.value = g.transmission,
        y.transmissionSamplerMap.value = N.texture,
        y.transmissionSamplerSize.value.set(N.width, N.height),
        g.transmissionMap && (y.transmissionMap.value = g.transmissionMap,
        n(g.transmissionMap, y.transmissionMapTransform)),
        y.thickness.value = g.thickness,
        g.thicknessMap && (y.thicknessMap.value = g.thicknessMap,
        n(g.thicknessMap, y.thicknessMapTransform)),
        y.attenuationDistance.value = g.attenuationDistance,
        y.attenuationColor.value.copy(g.attenuationColor)),
        g.anisotropy > 0 && (y.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)),
        g.anisotropyMap && (y.anisotropyMap.value = g.anisotropyMap,
        n(g.anisotropyMap, y.anisotropyMapTransform))),
        y.specularIntensity.value = g.specularIntensity,
        y.specularColor.value.copy(g.specularColor),
        g.specularColorMap && (y.specularColorMap.value = g.specularColorMap,
        n(g.specularColorMap, y.specularColorMapTransform)),
        g.specularIntensityMap && (y.specularIntensityMap.value = g.specularIntensityMap,
        n(g.specularIntensityMap, y.specularIntensityMapTransform))
    }
    function E(y, g) {
        g.matcap && (y.matcap.value = g.matcap)
    }
    function T(y, g) {
        const N = e.get(g).light;
        y.referencePosition.value.setFromMatrixPosition(N.matrixWorld),
        y.nearDistance.value = N.shadow.camera.near,
        y.farDistance.value = N.shadow.camera.far
    }
    return {
        refreshFogUniforms: r,
        refreshMaterialUniforms: o
    }
}
function mM(s, e, n, r) {
    let o = {}
      , l = {}
      , u = [];
    const f = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
    function m(N, L) {
        const C = L.program;
        r.uniformBlockBinding(N, C)
    }
    function p(N, L) {
        let C = o[N.id];
        C === void 0 && (E(N),
        C = v(N),
        o[N.id] = C,
        N.addEventListener("dispose", y));
        const H = L.program;
        r.updateUBOMapping(N, H);
        const k = e.render.frame;
        l[N.id] !== k && (x(N),
        l[N.id] = k)
    }
    function v(N) {
        const L = _();
        N.__bindingPointIndex = L;
        const C = s.createBuffer()
          , H = N.__size
          , k = N.usage;
        return s.bindBuffer(s.UNIFORM_BUFFER, C),
        s.bufferData(s.UNIFORM_BUFFER, H, k),
        s.bindBuffer(s.UNIFORM_BUFFER, null),
        s.bindBufferBase(s.UNIFORM_BUFFER, L, C),
        C
    }
    function _() {
        for (let N = 0; N < f; N++)
            if (u.indexOf(N) === -1)
                return u.push(N),
                N;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function x(N) {
        const L = o[N.id]
          , C = N.uniforms
          , H = N.__cache;
        s.bindBuffer(s.UNIFORM_BUFFER, L);
        for (let k = 0, F = C.length; k < F; k++) {
            const j = Array.isArray(C[k]) ? C[k] : [C[k]];
            for (let b = 0, R = j.length; b < R; b++) {
                const I = j[b];
                if (S(I, k, b, H) === !0) {
                    const oe = I.__offset
                      , se = Array.isArray(I.value) ? I.value : [I.value];
                    let ce = 0;
                    for (let ne = 0; ne < se.length; ne++) {
                        const ae = se[ne]
                          , de = T(ae);
                        typeof ae == "number" || typeof ae == "boolean" ? (I.__data[0] = ae,
                        s.bufferSubData(s.UNIFORM_BUFFER, oe + ce, I.__data)) : ae.isMatrix3 ? (I.__data[0] = ae.elements[0],
                        I.__data[1] = ae.elements[1],
                        I.__data[2] = ae.elements[2],
                        I.__data[3] = 0,
                        I.__data[4] = ae.elements[3],
                        I.__data[5] = ae.elements[4],
                        I.__data[6] = ae.elements[5],
                        I.__data[7] = 0,
                        I.__data[8] = ae.elements[6],
                        I.__data[9] = ae.elements[7],
                        I.__data[10] = ae.elements[8],
                        I.__data[11] = 0) : (ae.toArray(I.__data, ce),
                        ce += de.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    s.bufferSubData(s.UNIFORM_BUFFER, oe, I.__data)
                }
            }
        }
        s.bindBuffer(s.UNIFORM_BUFFER, null)
    }
    function S(N, L, C, H) {
        const k = N.value
          , F = L + "_" + C;
        if (H[F] === void 0)
            return typeof k == "number" || typeof k == "boolean" ? H[F] = k : H[F] = k.clone(),
            !0;
        {
            const j = H[F];
            if (typeof k == "number" || typeof k == "boolean") {
                if (j !== k)
                    return H[F] = k,
                    !0
            } else if (j.equals(k) === !1)
                return j.copy(k),
                !0
        }
        return !1
    }
    function E(N) {
        const L = N.uniforms;
        let C = 0;
        const H = 16;
        for (let F = 0, j = L.length; F < j; F++) {
            const b = Array.isArray(L[F]) ? L[F] : [L[F]];
            for (let R = 0, I = b.length; R < I; R++) {
                const oe = b[R]
                  , se = Array.isArray(oe.value) ? oe.value : [oe.value];
                for (let ce = 0, ne = se.length; ce < ne; ce++) {
                    const ae = se[ce]
                      , de = T(ae)
                      , V = C % H
                      , ue = V % de.boundary
                      , re = V + ue;
                    C += ue,
                    re !== 0 && H - re < de.storage && (C += H - re),
                    oe.__data = new Float32Array(de.storage / Float32Array.BYTES_PER_ELEMENT),
                    oe.__offset = C,
                    C += de.storage
                }
            }
        }
        const k = C % H;
        return k > 0 && (C += H - k),
        N.__size = C,
        N.__cache = {},
        this
    }
    function T(N) {
        const L = {
            boundary: 0,
            storage: 0
        };
        return typeof N == "number" || typeof N == "boolean" ? (L.boundary = 4,
        L.storage = 4) : N.isVector2 ? (L.boundary = 8,
        L.storage = 8) : N.isVector3 || N.isColor ? (L.boundary = 16,
        L.storage = 12) : N.isVector4 ? (L.boundary = 16,
        L.storage = 16) : N.isMatrix3 ? (L.boundary = 48,
        L.storage = 48) : N.isMatrix4 ? (L.boundary = 64,
        L.storage = 64) : N.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", N),
        L
    }
    function y(N) {
        const L = N.target;
        L.removeEventListener("dispose", y);
        const C = u.indexOf(L.__bindingPointIndex);
        u.splice(C, 1),
        s.deleteBuffer(o[L.id]),
        delete o[L.id],
        delete l[L.id]
    }
    function g() {
        for (const N in o)
            s.deleteBuffer(o[N]);
        u = [],
        o = {},
        l = {}
    }
    return {
        bind: m,
        update: p,
        dispose: g
    }
}
class gM {
    constructor(e={}) {
        const {canvas: n=J_(), context: r=null, depth: o=!0, stencil: l=!1, alpha: u=!1, antialias: f=!1, premultipliedAlpha: m=!0, preserveDrawingBuffer: p=!1, powerPreference: v="default", failIfMajorPerformanceCaveat: _=!1, reversedDepthBuffer: x=!1} = e;
        this.isWebGLRenderer = !0;
        let S;
        if (r !== null) {
            if (typeof WebGLRenderingContext < "u" && r instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            S = r.getContextAttributes().alpha
        } else
            S = u;
        const E = new Uint32Array(4)
          , T = new Int32Array(4);
        let y = null
          , g = null;
        const N = []
          , L = [];
        this.domElement = n,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.toneMapping = gr,
        this.toneMappingExposure = 1,
        this.transmissionResolutionScale = 1;
        const C = this;
        let H = !1;
        this._outputColorSpace = Qn;
        let k = 0
          , F = 0
          , j = null
          , b = -1
          , R = null;
        const I = new Pt
          , oe = new Pt;
        let se = null;
        const ce = new mt(0);
        let ne = 0
          , ae = n.width
          , de = n.height
          , V = 1
          , ue = null
          , re = null;
        const U = new Pt(0,0,ae,de)
          , ie = new Pt(0,0,ae,de);
        let ke = !1;
        const ze = new Kd;
        let Q = !1
          , me = !1;
        const pe = new Vt
          , Ce = new J
          , Pe = new Pt
          , Ke = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let Ut = !1;
        function gt() {
            return j === null ? V : 1
        }
        let z = r;
        function Tt(A, Y) {
            return n.getContext(A, Y)
        }
        try {
            const A = {
                alpha: !0,
                depth: o,
                stencil: l,
                antialias: f,
                premultipliedAlpha: m,
                preserveDrawingBuffer: p,
                powerPreference: v,
                failIfMajorPerformanceCaveat: _
            };
            if ("setAttribute"in n && n.setAttribute("data-engine", `three.js r${Vd}`),
            n.addEventListener("webglcontextlost", Ae, !1),
            n.addEventListener("webglcontextrestored", De, !1),
            n.addEventListener("webglcontextcreationerror", ye, !1),
            z === null) {
                const Y = "webgl2";
                if (z = Tt(Y, A),
                z === null)
                    throw Tt(Y) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (A) {
            throw console.error("THREE.WebGLRenderer: " + A.message),
            A
        }
        let Qe, xt, qe, Nt, Fe, lt, Ot, zt, P, M, $, fe, ve, le, Ye, Te, Be, Je, Me, Ne, it, We, Re, ct;
        function G() {
            Qe = new AS(z),
            Qe.init(),
            We = new lM(z,Qe),
            xt = new xS(z,Qe,e,We),
            qe = new aM(z,Qe),
            xt.reversedDepthBuffer && x && qe.buffers.depth.setReversed(!0),
            Nt = new bS(z),
            Fe = new Yw,
            lt = new oM(z,Qe,qe,Fe,xt,We,Nt),
            Ot = new SS(C),
            zt = new TS(C),
            P = new Uv(z),
            Re = new _S(z,P),
            M = new CS(z,P,Nt,Re),
            $ = new PS(z,M,P,Nt),
            Me = new LS(z,xt,lt),
            Te = new yS(Fe),
            fe = new Xw(C,Ot,zt,Qe,xt,Re,Te),
            ve = new pM(C,Fe),
            le = new qw,
            Ye = new tM(Qe),
            Je = new gS(C,Ot,zt,qe,$,S,m),
            Be = new rM(C,$,xt),
            ct = new mM(z,Nt,xt,qe),
            Ne = new vS(z,Qe,Nt),
            it = new RS(z,Qe,Nt),
            Nt.programs = fe.programs,
            C.capabilities = xt,
            C.extensions = Qe,
            C.properties = Fe,
            C.renderLists = le,
            C.shadowMap = Be,
            C.state = qe,
            C.info = Nt
        }
        G();
        const Se = new fM(C,z);
        this.xr = Se,
        this.getContext = function() {
            return z
        }
        ,
        this.getContextAttributes = function() {
            return z.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const A = Qe.get("WEBGL_lose_context");
            A && A.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const A = Qe.get("WEBGL_lose_context");
            A && A.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return V
        }
        ,
        this.setPixelRatio = function(A) {
            A !== void 0 && (V = A,
            this.setSize(ae, de, !1))
        }
        ,
        this.getSize = function(A) {
            return A.set(ae, de)
        }
        ,
        this.setSize = function(A, Y, ee=!0) {
            if (Se.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            ae = A,
            de = Y,
            n.width = Math.floor(A * V),
            n.height = Math.floor(Y * V),
            ee === !0 && (n.style.width = A + "px",
            n.style.height = Y + "px"),
            this.setViewport(0, 0, A, Y)
        }
        ,
        this.getDrawingBufferSize = function(A) {
            return A.set(ae * V, de * V).floor()
        }
        ,
        this.setDrawingBufferSize = function(A, Y, ee) {
            ae = A,
            de = Y,
            V = ee,
            n.width = Math.floor(A * ee),
            n.height = Math.floor(Y * ee),
            this.setViewport(0, 0, A, Y)
        }
        ,
        this.getCurrentViewport = function(A) {
            return A.copy(I)
        }
        ,
        this.getViewport = function(A) {
            return A.copy(U)
        }
        ,
        this.setViewport = function(A, Y, ee, te) {
            A.isVector4 ? U.set(A.x, A.y, A.z, A.w) : U.set(A, Y, ee, te),
            qe.viewport(I.copy(U).multiplyScalar(V).round())
        }
        ,
        this.getScissor = function(A) {
            return A.copy(ie)
        }
        ,
        this.setScissor = function(A, Y, ee, te) {
            A.isVector4 ? ie.set(A.x, A.y, A.z, A.w) : ie.set(A, Y, ee, te),
            qe.scissor(oe.copy(ie).multiplyScalar(V).round())
        }
        ,
        this.getScissorTest = function() {
            return ke
        }
        ,
        this.setScissorTest = function(A) {
            qe.setScissorTest(ke = A)
        }
        ,
        this.setOpaqueSort = function(A) {
            ue = A
        }
        ,
        this.setTransparentSort = function(A) {
            re = A
        }
        ,
        this.getClearColor = function(A) {
            return A.copy(Je.getClearColor())
        }
        ,
        this.setClearColor = function() {
            Je.setClearColor(...arguments)
        }
        ,
        this.getClearAlpha = function() {
            return Je.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            Je.setClearAlpha(...arguments)
        }
        ,
        this.clear = function(A=!0, Y=!0, ee=!0) {
            let te = 0;
            if (A) {
                let W = !1;
                if (j !== null) {
                    const we = j.texture.format;
                    W = we === Jd || we === Yd || we === Xd
                }
                if (W) {
                    const we = j.texture.type
                      , be = we === Si || we === Xr || we === Na || we === Da || we === Gd || we === Wd
                      , He = Je.getClearColor()
                      , Ie = Je.getClearAlpha()
                      , nt = He.r
                      , rt = He.g
                      , $e = He.b;
                    be ? (E[0] = nt,
                    E[1] = rt,
                    E[2] = $e,
                    E[3] = Ie,
                    z.clearBufferuiv(z.COLOR, 0, E)) : (T[0] = nt,
                    T[1] = rt,
                    T[2] = $e,
                    T[3] = Ie,
                    z.clearBufferiv(z.COLOR, 0, T))
                } else
                    te |= z.COLOR_BUFFER_BIT
            }
            Y && (te |= z.DEPTH_BUFFER_BIT),
            ee && (te |= z.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            z.clear(te)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            n.removeEventListener("webglcontextlost", Ae, !1),
            n.removeEventListener("webglcontextrestored", De, !1),
            n.removeEventListener("webglcontextcreationerror", ye, !1),
            Je.dispose(),
            le.dispose(),
            Ye.dispose(),
            Fe.dispose(),
            Ot.dispose(),
            zt.dispose(),
            $.dispose(),
            Re.dispose(),
            ct.dispose(),
            fe.dispose(),
            Se.dispose(),
            Se.removeEventListener("sessionstart", un),
            Se.removeEventListener("sessionend", qr),
            Fn.stop()
        }
        ;
        function Ae(A) {
            A.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            H = !0
        }
        function De() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            H = !1;
            const A = Nt.autoReset
              , Y = Be.enabled
              , ee = Be.autoUpdate
              , te = Be.needsUpdate
              , W = Be.type;
            G(),
            Nt.autoReset = A,
            Be.enabled = Y,
            Be.autoUpdate = ee,
            Be.needsUpdate = te,
            Be.type = W
        }
        function ye(A) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", A.statusMessage)
        }
        function he(A) {
            const Y = A.target;
            Y.removeEventListener("dispose", he),
            je(Y)
        }
        function je(A) {
            ot(A),
            Fe.remove(A)
        }
        function ot(A) {
            const Y = Fe.get(A).programs;
            Y !== void 0 && (Y.forEach(function(ee) {
                fe.releaseProgram(ee)
            }),
            A.isShaderMaterial && fe.releaseShaderCache(A))
        }
        this.renderBufferDirect = function(A, Y, ee, te, W, we) {
            Y === null && (Y = Ke);
            const be = W.isMesh && W.matrixWorld.determinant() < 0
              , He = Ei(A, Y, ee, te, W);
            qe.setMaterial(te, be);
            let Ie = ee.index
              , nt = 1;
            if (te.wireframe === !0) {
                if (Ie = M.getWireframeAttribute(ee),
                Ie === void 0)
                    return;
                nt = 2
            }
            const rt = ee.drawRange
              , $e = ee.attributes.position;
            let st = rt.start * nt
              , At = (rt.start + rt.count) * nt;
            we !== null && (st = Math.max(st, we.start * nt),
            At = Math.min(At, (we.start + we.count) * nt)),
            Ie !== null ? (st = Math.max(st, 0),
            At = Math.min(At, Ie.count)) : $e != null && (st = Math.max(st, 0),
            At = Math.min(At, $e.count));
            const St = At - st;
            if (St < 0 || St === 1 / 0)
                return;
            Re.setup(W, te, He, ee, Ie);
            let Dt, Rt = Ne;
            if (Ie !== null && (Dt = P.get(Ie),
            Rt = it,
            Rt.setIndex(Dt)),
            W.isMesh)
                te.wireframe === !0 ? (qe.setLineWidth(te.wireframeLinewidth * gt()),
                Rt.setMode(z.LINES)) : Rt.setMode(z.TRIANGLES);
            else if (W.isLine) {
                let Ze = te.linewidth;
                Ze === void 0 && (Ze = 1),
                qe.setLineWidth(Ze * gt()),
                W.isLineSegments ? Rt.setMode(z.LINES) : W.isLineLoop ? Rt.setMode(z.LINE_LOOP) : Rt.setMode(z.LINE_STRIP)
            } else
                W.isPoints ? Rt.setMode(z.POINTS) : W.isSprite && Rt.setMode(z.TRIANGLES);
            if (W.isBatchedMesh)
                if (W._multiDrawInstances !== null)
                    Fs("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                    Rt.renderMultiDrawInstances(W._multiDrawStarts, W._multiDrawCounts, W._multiDrawCount, W._multiDrawInstances);
                else if (Qe.get("WEBGL_multi_draw"))
                    Rt.renderMultiDraw(W._multiDrawStarts, W._multiDrawCounts, W._multiDrawCount);
                else {
                    const Ze = W._multiDrawStarts
                      , bt = W._multiDrawCounts
                      , ht = W._multiDrawCount
                      , $t = Ie ? P.get(Ie).bytesPerElement : 1
                      , ei = Fe.get(te).currentProgram.getUniforms();
                    for (let yn = 0; yn < ht; yn++)
                        ei.setValue(z, "_gl_DrawID", yn),
                        Rt.render(Ze[yn] / $t, bt[yn])
                }
            else if (W.isInstancedMesh)
                Rt.renderInstances(st, St, W.count);
            else if (ee.isInstancedBufferGeometry) {
                const Ze = ee._maxInstanceCount !== void 0 ? ee._maxInstanceCount : 1 / 0
                  , bt = Math.min(ee.instanceCount, Ze);
                Rt.renderInstances(st, St, bt)
            } else
                Rt.render(st, St)
        }
        ;
        function Ct(A, Y, ee) {
            A.transparent === !0 && A.side === ki && A.forceSinglePass === !1 ? (A.side = Nn,
            A.needsUpdate = !0,
            Kr(A, Y, ee),
            A.side = _r,
            A.needsUpdate = !0,
            Kr(A, Y, ee),
            A.side = ki) : Kr(A, Y, ee)
        }
        this.compile = function(A, Y, ee=null) {
            ee === null && (ee = A),
            g = Ye.get(ee),
            g.init(Y),
            L.push(g),
            ee.traverseVisible(function(W) {
                W.isLight && W.layers.test(Y.layers) && (g.pushLight(W),
                W.castShadow && g.pushShadow(W))
            }),
            A !== ee && A.traverseVisible(function(W) {
                W.isLight && W.layers.test(Y.layers) && (g.pushLight(W),
                W.castShadow && g.pushShadow(W))
            }),
            g.setupLights();
            const te = new Set;
            return A.traverse(function(W) {
                if (!(W.isMesh || W.isPoints || W.isLine || W.isSprite))
                    return;
                const we = W.material;
                if (we)
                    if (Array.isArray(we))
                        for (let be = 0; be < we.length; be++) {
                            const He = we[be];
                            Ct(He, ee, W),
                            te.add(He)
                        }
                    else
                        Ct(we, ee, W),
                        te.add(we)
            }),
            g = L.pop(),
            te
        }
        ,
        this.compileAsync = function(A, Y, ee=null) {
            const te = this.compile(A, Y, ee);
            return new Promise(W => {
                function we() {
                    if (te.forEach(function(be) {
                        Fe.get(be).currentProgram.isReady() && te.delete(be)
                    }),
                    te.size === 0) {
                        W(A);
                        return
                    }
                    setTimeout(we, 10)
                }
                Qe.get("KHR_parallel_shader_compile") !== null ? we() : setTimeout(we, 10)
            }
            )
        }
        ;
        let yt = null;
        function Gn(A) {
            yt && yt(A)
        }
        function un() {
            Fn.stop()
        }
        function qr() {
            Fn.start()
        }
        const Fn = new hg;
        Fn.setAnimationLoop(Gn),
        typeof self < "u" && Fn.setContext(self),
        this.setAnimationLoop = function(A) {
            yt = A,
            Se.setAnimationLoop(A),
            A === null ? Fn.stop() : Fn.start()
        }
        ,
        Se.addEventListener("sessionstart", un),
        Se.addEventListener("sessionend", qr),
        this.render = function(A, Y) {
            if (Y !== void 0 && Y.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (H === !0)
                return;
            if (A.matrixWorldAutoUpdate === !0 && A.updateMatrixWorld(),
            Y.parent === null && Y.matrixWorldAutoUpdate === !0 && Y.updateMatrixWorld(),
            Se.enabled === !0 && Se.isPresenting === !0 && (Se.cameraAutoUpdate === !0 && Se.updateCamera(Y),
            Y = Se.getCamera()),
            A.isScene === !0 && A.onBeforeRender(C, A, Y, j),
            g = Ye.get(A, L.length),
            g.init(Y),
            L.push(g),
            pe.multiplyMatrices(Y.projectionMatrix, Y.matrixWorldInverse),
            ze.setFromProjectionMatrix(pe, yi, Y.reversedDepth),
            me = this.localClippingEnabled,
            Q = Te.init(this.clippingPlanes, me),
            y = le.get(A, N.length),
            y.init(),
            N.push(y),
            Se.enabled === !0 && Se.isPresenting === !0) {
                const we = C.xr.getDepthSensingMesh();
                we !== null && Ws(we, Y, -1 / 0, C.sortObjects)
            }
            Ws(A, Y, 0, C.sortObjects),
            y.finish(),
            C.sortObjects === !0 && y.sort(ue, re),
            Ut = Se.enabled === !1 || Se.isPresenting === !1 || Se.hasDepthSensing() === !1,
            Ut && Je.addToRenderList(y, A),
            this.info.render.frame++,
            Q === !0 && Te.beginShadows();
            const ee = g.state.shadowsArray;
            Be.render(ee, A, Y),
            Q === !0 && Te.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const te = y.opaque
              , W = y.transmissive;
            if (g.setupLights(),
            Y.isArrayCamera) {
                const we = Y.cameras;
                if (W.length > 0)
                    for (let be = 0, He = we.length; be < He; be++) {
                        const Ie = we[be];
                        xr(te, W, A, Ie)
                    }
                Ut && Je.render(A);
                for (let be = 0, He = we.length; be < He; be++) {
                    const Ie = we[be];
                    Vi(y, A, Ie, Ie.viewport)
                }
            } else
                W.length > 0 && xr(te, W, A, Y),
                Ut && Je.render(A),
                Vi(y, A, Y);
            j !== null && F === 0 && (lt.updateMultisampleRenderTarget(j),
            lt.updateRenderTargetMipmap(j)),
            A.isScene === !0 && A.onAfterRender(C, A, Y),
            Re.resetDefaultState(),
            b = -1,
            R = null,
            L.pop(),
            L.length > 0 ? (g = L[L.length - 1],
            Q === !0 && Te.setGlobalState(C.clippingPlanes, g.state.camera)) : g = null,
            N.pop(),
            N.length > 0 ? y = N[N.length - 1] : y = null
        }
        ;
        function Ws(A, Y, ee, te) {
            if (A.visible === !1)
                return;
            if (A.layers.test(Y.layers)) {
                if (A.isGroup)
                    ee = A.renderOrder;
                else if (A.isLOD)
                    A.autoUpdate === !0 && A.update(Y);
                else if (A.isLight)
                    g.pushLight(A),
                    A.castShadow && g.pushShadow(A);
                else if (A.isSprite) {
                    if (!A.frustumCulled || ze.intersectsSprite(A)) {
                        te && Pe.setFromMatrixPosition(A.matrixWorld).applyMatrix4(pe);
                        const be = $.update(A)
                          , He = A.material;
                        He.visible && y.push(A, be, He, ee, Pe.z, null)
                    }
                } else if ((A.isMesh || A.isLine || A.isPoints) && (!A.frustumCulled || ze.intersectsObject(A))) {
                    const be = $.update(A)
                      , He = A.material;
                    if (te && (A.boundingSphere !== void 0 ? (A.boundingSphere === null && A.computeBoundingSphere(),
                    Pe.copy(A.boundingSphere.center)) : (be.boundingSphere === null && be.computeBoundingSphere(),
                    Pe.copy(be.boundingSphere.center)),
                    Pe.applyMatrix4(A.matrixWorld).applyMatrix4(pe)),
                    Array.isArray(He)) {
                        const Ie = be.groups;
                        for (let nt = 0, rt = Ie.length; nt < rt; nt++) {
                            const $e = Ie[nt]
                              , st = He[$e.materialIndex];
                            st && st.visible && y.push(A, be, st, ee, Pe.z, $e)
                        }
                    } else
                        He.visible && y.push(A, be, He, ee, Pe.z, null)
                }
            }
            const we = A.children;
            for (let be = 0, He = we.length; be < He; be++)
                Ws(we[be], Y, ee, te)
        }
        function Vi(A, Y, ee, te) {
            const W = A.opaque
              , we = A.transmissive
              , be = A.transparent;
            g.setupLightsView(ee),
            Q === !0 && Te.setGlobalState(C.clippingPlanes, ee),
            te && qe.viewport(I.copy(te)),
            W.length > 0 && Mi(W, Y, ee),
            we.length > 0 && Mi(we, Y, ee),
            be.length > 0 && Mi(be, Y, ee),
            qe.buffers.depth.setTest(!0),
            qe.buffers.depth.setMask(!0),
            qe.buffers.color.setMask(!0),
            qe.setPolygonOffset(!1)
        }
        function xr(A, Y, ee, te) {
            if ((ee.isScene === !0 ? ee.overrideMaterial : null) !== null)
                return;
            g.state.transmissionRenderTarget[te.id] === void 0 && (g.state.transmissionRenderTarget[te.id] = new Yr(1,1,{
                generateMipmaps: !0,
                type: Qe.has("EXT_color_buffer_half_float") || Qe.has("EXT_color_buffer_float") ? Fa : Si,
                minFilter: Wr,
                samples: 4,
                stencilBuffer: l,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: Et.workingColorSpace
            }));
            const we = g.state.transmissionRenderTarget[te.id]
              , be = te.viewport || I;
            we.setSize(be.z * C.transmissionResolutionScale, be.w * C.transmissionResolutionScale);
            const He = C.getRenderTarget()
              , Ie = C.getActiveCubeFace()
              , nt = C.getActiveMipmapLevel();
            C.setRenderTarget(we),
            C.getClearColor(ce),
            ne = C.getClearAlpha(),
            ne < 1 && C.setClearColor(16777215, .5),
            C.clear(),
            Ut && Je.render(ee);
            const rt = C.toneMapping;
            C.toneMapping = gr;
            const $e = te.viewport;
            if (te.viewport !== void 0 && (te.viewport = void 0),
            g.setupLightsView(te),
            Q === !0 && Te.setGlobalState(C.clippingPlanes, te),
            Mi(A, ee, te),
            lt.updateMultisampleRenderTarget(we),
            lt.updateRenderTargetMipmap(we),
            Qe.has("WEBGL_multisampled_render_to_texture") === !1) {
                let st = !1;
                for (let At = 0, St = Y.length; At < St; At++) {
                    const Dt = Y[At]
                      , Rt = Dt.object
                      , Ze = Dt.geometry
                      , bt = Dt.material
                      , ht = Dt.group;
                    if (bt.side === ki && Rt.layers.test(te.layers)) {
                        const $t = bt.side;
                        bt.side = Nn,
                        bt.needsUpdate = !0,
                        $r(Rt, ee, te, Ze, bt, ht),
                        bt.side = $t,
                        bt.needsUpdate = !0,
                        st = !0
                    }
                }
                st === !0 && (lt.updateMultisampleRenderTarget(we),
                lt.updateRenderTargetMipmap(we))
            }
            C.setRenderTarget(He, Ie, nt),
            C.setClearColor(ce, ne),
            $e !== void 0 && (te.viewport = $e),
            C.toneMapping = rt
        }
        function Mi(A, Y, ee) {
            const te = Y.isScene === !0 ? Y.overrideMaterial : null;
            for (let W = 0, we = A.length; W < we; W++) {
                const be = A[W]
                  , He = be.object
                  , Ie = be.geometry
                  , nt = be.group;
                let rt = be.material;
                rt.allowOverride === !0 && te !== null && (rt = te),
                He.layers.test(ee.layers) && $r(He, Y, ee, Ie, rt, nt)
            }
        }
        function $r(A, Y, ee, te, W, we) {
            A.onBeforeRender(C, Y, ee, te, W, we),
            A.modelViewMatrix.multiplyMatrices(ee.matrixWorldInverse, A.matrixWorld),
            A.normalMatrix.getNormalMatrix(A.modelViewMatrix),
            W.onBeforeRender(C, Y, ee, te, A, we),
            W.transparent === !0 && W.side === ki && W.forceSinglePass === !1 ? (W.side = Nn,
            W.needsUpdate = !0,
            C.renderBufferDirect(ee, Y, te, W, A, we),
            W.side = _r,
            W.needsUpdate = !0,
            C.renderBufferDirect(ee, Y, te, W, A, we),
            W.side = ki) : C.renderBufferDirect(ee, Y, te, W, A, we),
            A.onAfterRender(C, Y, ee, te, W, we)
        }
        function Kr(A, Y, ee) {
            Y.isScene !== !0 && (Y = Ke);
            const te = Fe.get(A)
              , W = g.state.lights
              , we = g.state.shadowsArray
              , be = W.state.version
              , He = fe.getParameters(A, W.state, we, Y, ee)
              , Ie = fe.getProgramCacheKey(He);
            let nt = te.programs;
            te.environment = A.isMeshStandardMaterial ? Y.environment : null,
            te.fog = Y.fog,
            te.envMap = (A.isMeshStandardMaterial ? zt : Ot).get(A.envMap || te.environment),
            te.envMapRotation = te.environment !== null && A.envMap === null ? Y.environmentRotation : A.envMapRotation,
            nt === void 0 && (A.addEventListener("dispose", he),
            nt = new Map,
            te.programs = nt);
            let rt = nt.get(Ie);
            if (rt !== void 0) {
                if (te.currentProgram === rt && te.lightsStateVersion === be)
                    return ja(A, He),
                    rt
            } else
                He.uniforms = fe.getUniforms(A),
                A.onBeforeCompile(He, C),
                rt = fe.acquireProgram(He, Ie),
                nt.set(Ie, rt),
                te.uniforms = He.uniforms;
            const $e = te.uniforms;
            return (!A.isShaderMaterial && !A.isRawShaderMaterial || A.clipping === !0) && ($e.clippingPlanes = Te.uniform),
            ja(A, He),
            te.needsLights = Wa(A),
            te.lightsStateVersion = be,
            te.needsLights && ($e.ambientLightColor.value = W.state.ambient,
            $e.lightProbe.value = W.state.probe,
            $e.directionalLights.value = W.state.directional,
            $e.directionalLightShadows.value = W.state.directionalShadow,
            $e.spotLights.value = W.state.spot,
            $e.spotLightShadows.value = W.state.spotShadow,
            $e.rectAreaLights.value = W.state.rectArea,
            $e.ltc_1.value = W.state.rectAreaLTC1,
            $e.ltc_2.value = W.state.rectAreaLTC2,
            $e.pointLights.value = W.state.point,
            $e.pointLightShadows.value = W.state.pointShadow,
            $e.hemisphereLights.value = W.state.hemi,
            $e.directionalShadowMap.value = W.state.directionalShadowMap,
            $e.directionalShadowMatrix.value = W.state.directionalShadowMatrix,
            $e.spotShadowMap.value = W.state.spotShadowMap,
            $e.spotLightMatrix.value = W.state.spotLightMatrix,
            $e.spotLightMap.value = W.state.spotLightMap,
            $e.pointShadowMap.value = W.state.pointShadowMap,
            $e.pointShadowMatrix.value = W.state.pointShadowMatrix),
            te.currentProgram = rt,
            te.uniformsList = null,
            rt
        }
        function Va(A) {
            if (A.uniformsList === null) {
                const Y = A.currentProgram.getUniforms();
                A.uniformsList = Cl.seqWithValue(Y.seq, A.uniforms)
            }
            return A.uniformsList
        }
        function ja(A, Y) {
            const ee = Fe.get(A);
            ee.outputColorSpace = Y.outputColorSpace,
            ee.batching = Y.batching,
            ee.batchingColor = Y.batchingColor,
            ee.instancing = Y.instancing,
            ee.instancingColor = Y.instancingColor,
            ee.instancingMorph = Y.instancingMorph,
            ee.skinning = Y.skinning,
            ee.morphTargets = Y.morphTargets,
            ee.morphNormals = Y.morphNormals,
            ee.morphColors = Y.morphColors,
            ee.morphTargetsCount = Y.morphTargetsCount,
            ee.numClippingPlanes = Y.numClippingPlanes,
            ee.numIntersection = Y.numClipIntersection,
            ee.vertexAlphas = Y.vertexAlphas,
            ee.vertexTangents = Y.vertexTangents,
            ee.toneMapping = Y.toneMapping
        }
        function Ei(A, Y, ee, te, W) {
            Y.isScene !== !0 && (Y = Ke),
            lt.resetTextureUnits();
            const we = Y.fog
              , be = te.isMeshStandardMaterial ? Y.environment : null
              , He = j === null ? C.outputColorSpace : j.isXRRenderTarget === !0 ? j.texture.colorSpace : Hs
              , Ie = (te.isMeshStandardMaterial ? zt : Ot).get(te.envMap || be)
              , nt = te.vertexColors === !0 && !!ee.attributes.color && ee.attributes.color.itemSize === 4
              , rt = !!ee.attributes.tangent && (!!te.normalMap || te.anisotropy > 0)
              , $e = !!ee.morphAttributes.position
              , st = !!ee.morphAttributes.normal
              , At = !!ee.morphAttributes.color;
            let St = gr;
            te.toneMapped && (j === null || j.isXRRenderTarget === !0) && (St = C.toneMapping);
            const Dt = ee.morphAttributes.position || ee.morphAttributes.normal || ee.morphAttributes.color
              , Rt = Dt !== void 0 ? Dt.length : 0
              , Ze = Fe.get(te)
              , bt = g.state.lights;
            if (Q === !0 && (me === !0 || A !== R)) {
                const Xt = A === R && te.id === b;
                Te.setState(te, A, Xt)
            }
            let ht = !1;
            te.version === Ze.__version ? (Ze.needsLights && Ze.lightsStateVersion !== bt.state.version || Ze.outputColorSpace !== He || W.isBatchedMesh && Ze.batching === !1 || !W.isBatchedMesh && Ze.batching === !0 || W.isBatchedMesh && Ze.batchingColor === !0 && W.colorTexture === null || W.isBatchedMesh && Ze.batchingColor === !1 && W.colorTexture !== null || W.isInstancedMesh && Ze.instancing === !1 || !W.isInstancedMesh && Ze.instancing === !0 || W.isSkinnedMesh && Ze.skinning === !1 || !W.isSkinnedMesh && Ze.skinning === !0 || W.isInstancedMesh && Ze.instancingColor === !0 && W.instanceColor === null || W.isInstancedMesh && Ze.instancingColor === !1 && W.instanceColor !== null || W.isInstancedMesh && Ze.instancingMorph === !0 && W.morphTexture === null || W.isInstancedMesh && Ze.instancingMorph === !1 && W.morphTexture !== null || Ze.envMap !== Ie || te.fog === !0 && Ze.fog !== we || Ze.numClippingPlanes !== void 0 && (Ze.numClippingPlanes !== Te.numPlanes || Ze.numIntersection !== Te.numIntersection) || Ze.vertexAlphas !== nt || Ze.vertexTangents !== rt || Ze.morphTargets !== $e || Ze.morphNormals !== st || Ze.morphColors !== At || Ze.toneMapping !== St || Ze.morphTargetsCount !== Rt) && (ht = !0) : (ht = !0,
            Ze.__version = te.version);
            let $t = Ze.currentProgram;
            ht === !0 && ($t = Kr(te, Y, W));
            let ei = !1
              , yn = !1
              , yr = !1;
            const It = $t.getUniforms()
              , Sn = Ze.uniforms;
            if (qe.useProgram($t.program) && (ei = !0,
            yn = !0,
            yr = !0),
            te.id !== b && (b = te.id,
            yn = !0),
            ei || R !== A) {
                qe.buffers.depth.getReversed() && A.reversedDepth !== !0 && (A._reversedDepth = !0,
                A.updateProjectionMatrix()),
                It.setValue(z, "projectionMatrix", A.projectionMatrix),
                It.setValue(z, "viewMatrix", A.matrixWorldInverse);
                const fn = It.map.cameraPosition;
                fn !== void 0 && fn.setValue(z, Ce.setFromMatrixPosition(A.matrixWorld)),
                xt.logarithmicDepthBuffer && It.setValue(z, "logDepthBufFC", 2 / (Math.log(A.far + 1) / Math.LN2)),
                (te.isMeshPhongMaterial || te.isMeshToonMaterial || te.isMeshLambertMaterial || te.isMeshBasicMaterial || te.isMeshStandardMaterial || te.isShaderMaterial) && It.setValue(z, "isOrthographic", A.isOrthographicCamera === !0),
                R !== A && (R = A,
                yn = !0,
                yr = !0)
            }
            if (W.isSkinnedMesh) {
                It.setOptional(z, W, "bindMatrix"),
                It.setOptional(z, W, "bindMatrixInverse");
                const Xt = W.skeleton;
                Xt && (Xt.boneTexture === null && Xt.computeBoneTexture(),
                It.setValue(z, "boneTexture", Xt.boneTexture, lt))
            }
            W.isBatchedMesh && (It.setOptional(z, W, "batchingTexture"),
            It.setValue(z, "batchingTexture", W._matricesTexture, lt),
            It.setOptional(z, W, "batchingIdTexture"),
            It.setValue(z, "batchingIdTexture", W._indirectTexture, lt),
            It.setOptional(z, W, "batchingColorTexture"),
            W._colorsTexture !== null && It.setValue(z, "batchingColorTexture", W._colorsTexture, lt));
            const dn = ee.morphAttributes;
            if ((dn.position !== void 0 || dn.normal !== void 0 || dn.color !== void 0) && Me.update(W, ee, $t),
            (yn || Ze.receiveShadow !== W.receiveShadow) && (Ze.receiveShadow = W.receiveShadow,
            It.setValue(z, "receiveShadow", W.receiveShadow)),
            te.isMeshGouraudMaterial && te.envMap !== null && (Sn.envMap.value = Ie,
            Sn.flipEnvMap.value = Ie.isCubeTexture && Ie.isRenderTargetTexture === !1 ? -1 : 1),
            te.isMeshStandardMaterial && te.envMap === null && Y.environment !== null && (Sn.envMapIntensity.value = Y.environmentIntensity),
            yn && (It.setValue(z, "toneMappingExposure", C.toneMappingExposure),
            Ze.needsLights && Ga(Sn, yr),
            we && te.fog === !0 && ve.refreshFogUniforms(Sn, we),
            ve.refreshMaterialUniforms(Sn, te, V, de, g.state.transmissionRenderTarget[A.id]),
            Cl.upload(z, Va(Ze), Sn, lt)),
            te.isShaderMaterial && te.uniformsNeedUpdate === !0 && (Cl.upload(z, Va(Ze), Sn, lt),
            te.uniformsNeedUpdate = !1),
            te.isSpriteMaterial && It.setValue(z, "center", W.center),
            It.setValue(z, "modelViewMatrix", W.modelViewMatrix),
            It.setValue(z, "normalMatrix", W.normalMatrix),
            It.setValue(z, "modelMatrix", W.matrixWorld),
            te.isShaderMaterial || te.isRawShaderMaterial) {
                const Xt = te.uniformsGroups;
                for (let fn = 0, Sr = Xt.length; fn < Sr; fn++) {
                    const pt = Xt[fn];
                    ct.update(pt, $t),
                    ct.bind(pt, $t)
                }
            }
            return $t
        }
        function Ga(A, Y) {
            A.ambientLightColor.needsUpdate = Y,
            A.lightProbe.needsUpdate = Y,
            A.directionalLights.needsUpdate = Y,
            A.directionalLightShadows.needsUpdate = Y,
            A.pointLights.needsUpdate = Y,
            A.pointLightShadows.needsUpdate = Y,
            A.spotLights.needsUpdate = Y,
            A.spotLightShadows.needsUpdate = Y,
            A.rectAreaLights.needsUpdate = Y,
            A.hemisphereLights.needsUpdate = Y
        }
        function Wa(A) {
            return A.isMeshLambertMaterial || A.isMeshToonMaterial || A.isMeshPhongMaterial || A.isMeshStandardMaterial || A.isShadowMaterial || A.isShaderMaterial && A.lights === !0
        }
        this.getActiveCubeFace = function() {
            return k
        }
        ,
        this.getActiveMipmapLevel = function() {
            return F
        }
        ,
        this.getRenderTarget = function() {
            return j
        }
        ,
        this.setRenderTargetTextures = function(A, Y, ee) {
            const te = Fe.get(A);
            te.__autoAllocateDepthBuffer = A.resolveDepthBuffer === !1,
            te.__autoAllocateDepthBuffer === !1 && (te.__useRenderToTexture = !1),
            Fe.get(A.texture).__webglTexture = Y,
            Fe.get(A.depthTexture).__webglTexture = te.__autoAllocateDepthBuffer ? void 0 : ee,
            te.__hasExternalTextures = !0
        }
        ,
        this.setRenderTargetFramebuffer = function(A, Y) {
            const ee = Fe.get(A);
            ee.__webglFramebuffer = Y,
            ee.__useDefaultFramebuffer = Y === void 0
        }
        ;
        const Fl = z.createFramebuffer();
        this.setRenderTarget = function(A, Y=0, ee=0) {
            j = A,
            k = Y,
            F = ee;
            let te = !0
              , W = null
              , we = !1
              , be = !1;
            if (A) {
                const Ie = Fe.get(A);
                if (Ie.__useDefaultFramebuffer !== void 0)
                    qe.bindFramebuffer(z.FRAMEBUFFER, null),
                    te = !1;
                else if (Ie.__webglFramebuffer === void 0)
                    lt.setupRenderTarget(A);
                else if (Ie.__hasExternalTextures)
                    lt.rebindTextures(A, Fe.get(A.texture).__webglTexture, Fe.get(A.depthTexture).__webglTexture);
                else if (A.depthBuffer) {
                    const $e = A.depthTexture;
                    if (Ie.__boundDepthTexture !== $e) {
                        if ($e !== null && Fe.has($e) && (A.width !== $e.image.width || A.height !== $e.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        lt.setupDepthRenderbuffer(A)
                    }
                }
                const nt = A.texture;
                (nt.isData3DTexture || nt.isDataArrayTexture || nt.isCompressedArrayTexture) && (be = !0);
                const rt = Fe.get(A).__webglFramebuffer;
                A.isWebGLCubeRenderTarget ? (Array.isArray(rt[Y]) ? W = rt[Y][ee] : W = rt[Y],
                we = !0) : A.samples > 0 && lt.useMultisampledRTT(A) === !1 ? W = Fe.get(A).__webglMultisampledFramebuffer : Array.isArray(rt) ? W = rt[ee] : W = rt,
                I.copy(A.viewport),
                oe.copy(A.scissor),
                se = A.scissorTest
            } else
                I.copy(U).multiplyScalar(V).floor(),
                oe.copy(ie).multiplyScalar(V).floor(),
                se = ke;
            if (ee !== 0 && (W = Fl),
            qe.bindFramebuffer(z.FRAMEBUFFER, W) && te && qe.drawBuffers(A, W),
            qe.viewport(I),
            qe.scissor(oe),
            qe.setScissorTest(se),
            we) {
                const Ie = Fe.get(A.texture);
                z.framebufferTexture2D(z.FRAMEBUFFER, z.COLOR_ATTACHMENT0, z.TEXTURE_CUBE_MAP_POSITIVE_X + Y, Ie.__webglTexture, ee)
            } else if (be) {
                const Ie = Y;
                for (let nt = 0; nt < A.textures.length; nt++) {
                    const rt = Fe.get(A.textures[nt]);
                    z.framebufferTextureLayer(z.FRAMEBUFFER, z.COLOR_ATTACHMENT0 + nt, rt.__webglTexture, ee, Ie)
                }
            } else if (A !== null && ee !== 0) {
                const Ie = Fe.get(A.texture);
                z.framebufferTexture2D(z.FRAMEBUFFER, z.COLOR_ATTACHMENT0, z.TEXTURE_2D, Ie.__webglTexture, ee)
            }
            b = -1
        }
        ,
        this.readRenderTargetPixels = function(A, Y, ee, te, W, we, be, He=0) {
            if (!(A && A.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let Ie = Fe.get(A).__webglFramebuffer;
            if (A.isWebGLCubeRenderTarget && be !== void 0 && (Ie = Ie[be]),
            Ie) {
                qe.bindFramebuffer(z.FRAMEBUFFER, Ie);
                try {
                    const nt = A.textures[He]
                      , rt = nt.format
                      , $e = nt.type;
                    if (!xt.textureFormatReadable(rt)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!xt.textureTypeReadable($e)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    Y >= 0 && Y <= A.width - te && ee >= 0 && ee <= A.height - W && (A.textures.length > 1 && z.readBuffer(z.COLOR_ATTACHMENT0 + He),
                    z.readPixels(Y, ee, te, W, We.convert(rt), We.convert($e), we))
                } finally {
                    const nt = j !== null ? Fe.get(j).__webglFramebuffer : null;
                    qe.bindFramebuffer(z.FRAMEBUFFER, nt)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(A, Y, ee, te, W, we, be, He=0) {
            if (!(A && A.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let Ie = Fe.get(A).__webglFramebuffer;
            if (A.isWebGLCubeRenderTarget && be !== void 0 && (Ie = Ie[be]),
            Ie)
                if (Y >= 0 && Y <= A.width - te && ee >= 0 && ee <= A.height - W) {
                    qe.bindFramebuffer(z.FRAMEBUFFER, Ie);
                    const nt = A.textures[He]
                      , rt = nt.format
                      , $e = nt.type;
                    if (!xt.textureFormatReadable(rt))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!xt.textureTypeReadable($e))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const st = z.createBuffer();
                    z.bindBuffer(z.PIXEL_PACK_BUFFER, st),
                    z.bufferData(z.PIXEL_PACK_BUFFER, we.byteLength, z.STREAM_READ),
                    A.textures.length > 1 && z.readBuffer(z.COLOR_ATTACHMENT0 + He),
                    z.readPixels(Y, ee, te, W, We.convert(rt), We.convert($e), 0);
                    const At = j !== null ? Fe.get(j).__webglFramebuffer : null;
                    qe.bindFramebuffer(z.FRAMEBUFFER, At);
                    const St = z.fenceSync(z.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return z.flush(),
                    await q_(z, St, 4),
                    z.bindBuffer(z.PIXEL_PACK_BUFFER, st),
                    z.getBufferSubData(z.PIXEL_PACK_BUFFER, 0, we),
                    z.deleteBuffer(st),
                    z.deleteSync(St),
                    we
                } else
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
        }
        ,
        this.copyFramebufferToTexture = function(A, Y=null, ee=0) {
            const te = Math.pow(2, -ee)
              , W = Math.floor(A.image.width * te)
              , we = Math.floor(A.image.height * te)
              , be = Y !== null ? Y.x : 0
              , He = Y !== null ? Y.y : 0;
            lt.setTexture2D(A, 0),
            z.copyTexSubImage2D(z.TEXTURE_2D, ee, 0, 0, be, He, W, we),
            qe.unbindTexture()
        }
        ;
        const Xa = z.createFramebuffer()
          , Ya = z.createFramebuffer();
        this.copyTextureToTexture = function(A, Y, ee=null, te=null, W=0, we=null) {
            we === null && (W !== 0 ? (Fs("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
            we = W,
            W = 0) : we = 0);
            let be, He, Ie, nt, rt, $e, st, At, St;
            const Dt = A.isCompressedTexture ? A.mipmaps[we] : A.image;
            if (ee !== null)
                be = ee.max.x - ee.min.x,
                He = ee.max.y - ee.min.y,
                Ie = ee.isBox3 ? ee.max.z - ee.min.z : 1,
                nt = ee.min.x,
                rt = ee.min.y,
                $e = ee.isBox3 ? ee.min.z : 0;
            else {
                const dn = Math.pow(2, -W);
                be = Math.floor(Dt.width * dn),
                He = Math.floor(Dt.height * dn),
                A.isDataArrayTexture ? Ie = Dt.depth : A.isData3DTexture ? Ie = Math.floor(Dt.depth * dn) : Ie = 1,
                nt = 0,
                rt = 0,
                $e = 0
            }
            te !== null ? (st = te.x,
            At = te.y,
            St = te.z) : (st = 0,
            At = 0,
            St = 0);
            const Rt = We.convert(Y.format)
              , Ze = We.convert(Y.type);
            let bt;
            Y.isData3DTexture ? (lt.setTexture3D(Y, 0),
            bt = z.TEXTURE_3D) : Y.isDataArrayTexture || Y.isCompressedArrayTexture ? (lt.setTexture2DArray(Y, 0),
            bt = z.TEXTURE_2D_ARRAY) : (lt.setTexture2D(Y, 0),
            bt = z.TEXTURE_2D),
            z.pixelStorei(z.UNPACK_FLIP_Y_WEBGL, Y.flipY),
            z.pixelStorei(z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha),
            z.pixelStorei(z.UNPACK_ALIGNMENT, Y.unpackAlignment);
            const ht = z.getParameter(z.UNPACK_ROW_LENGTH)
              , $t = z.getParameter(z.UNPACK_IMAGE_HEIGHT)
              , ei = z.getParameter(z.UNPACK_SKIP_PIXELS)
              , yn = z.getParameter(z.UNPACK_SKIP_ROWS)
              , yr = z.getParameter(z.UNPACK_SKIP_IMAGES);
            z.pixelStorei(z.UNPACK_ROW_LENGTH, Dt.width),
            z.pixelStorei(z.UNPACK_IMAGE_HEIGHT, Dt.height),
            z.pixelStorei(z.UNPACK_SKIP_PIXELS, nt),
            z.pixelStorei(z.UNPACK_SKIP_ROWS, rt),
            z.pixelStorei(z.UNPACK_SKIP_IMAGES, $e);
            const It = A.isDataArrayTexture || A.isData3DTexture
              , Sn = Y.isDataArrayTexture || Y.isData3DTexture;
            if (A.isDepthTexture) {
                const dn = Fe.get(A)
                  , Xt = Fe.get(Y)
                  , fn = Fe.get(dn.__renderTarget)
                  , Sr = Fe.get(Xt.__renderTarget);
                qe.bindFramebuffer(z.READ_FRAMEBUFFER, fn.__webglFramebuffer),
                qe.bindFramebuffer(z.DRAW_FRAMEBUFFER, Sr.__webglFramebuffer);
                for (let pt = 0; pt < Ie; pt++)
                    It && (z.framebufferTextureLayer(z.READ_FRAMEBUFFER, z.COLOR_ATTACHMENT0, Fe.get(A).__webglTexture, W, $e + pt),
                    z.framebufferTextureLayer(z.DRAW_FRAMEBUFFER, z.COLOR_ATTACHMENT0, Fe.get(Y).__webglTexture, we, St + pt)),
                    z.blitFramebuffer(nt, rt, be, He, st, At, be, He, z.DEPTH_BUFFER_BIT, z.NEAREST);
                qe.bindFramebuffer(z.READ_FRAMEBUFFER, null),
                qe.bindFramebuffer(z.DRAW_FRAMEBUFFER, null)
            } else if (W !== 0 || A.isRenderTargetTexture || Fe.has(A)) {
                const dn = Fe.get(A)
                  , Xt = Fe.get(Y);
                qe.bindFramebuffer(z.READ_FRAMEBUFFER, Xa),
                qe.bindFramebuffer(z.DRAW_FRAMEBUFFER, Ya);
                for (let fn = 0; fn < Ie; fn++)
                    It ? z.framebufferTextureLayer(z.READ_FRAMEBUFFER, z.COLOR_ATTACHMENT0, dn.__webglTexture, W, $e + fn) : z.framebufferTexture2D(z.READ_FRAMEBUFFER, z.COLOR_ATTACHMENT0, z.TEXTURE_2D, dn.__webglTexture, W),
                    Sn ? z.framebufferTextureLayer(z.DRAW_FRAMEBUFFER, z.COLOR_ATTACHMENT0, Xt.__webglTexture, we, St + fn) : z.framebufferTexture2D(z.DRAW_FRAMEBUFFER, z.COLOR_ATTACHMENT0, z.TEXTURE_2D, Xt.__webglTexture, we),
                    W !== 0 ? z.blitFramebuffer(nt, rt, be, He, st, At, be, He, z.COLOR_BUFFER_BIT, z.NEAREST) : Sn ? z.copyTexSubImage3D(bt, we, st, At, St + fn, nt, rt, be, He) : z.copyTexSubImage2D(bt, we, st, At, nt, rt, be, He);
                qe.bindFramebuffer(z.READ_FRAMEBUFFER, null),
                qe.bindFramebuffer(z.DRAW_FRAMEBUFFER, null)
            } else
                Sn ? A.isDataTexture || A.isData3DTexture ? z.texSubImage3D(bt, we, st, At, St, be, He, Ie, Rt, Ze, Dt.data) : Y.isCompressedArrayTexture ? z.compressedTexSubImage3D(bt, we, st, At, St, be, He, Ie, Rt, Dt.data) : z.texSubImage3D(bt, we, st, At, St, be, He, Ie, Rt, Ze, Dt) : A.isDataTexture ? z.texSubImage2D(z.TEXTURE_2D, we, st, At, be, He, Rt, Ze, Dt.data) : A.isCompressedTexture ? z.compressedTexSubImage2D(z.TEXTURE_2D, we, st, At, Dt.width, Dt.height, Rt, Dt.data) : z.texSubImage2D(z.TEXTURE_2D, we, st, At, be, He, Rt, Ze, Dt);
            z.pixelStorei(z.UNPACK_ROW_LENGTH, ht),
            z.pixelStorei(z.UNPACK_IMAGE_HEIGHT, $t),
            z.pixelStorei(z.UNPACK_SKIP_PIXELS, ei),
            z.pixelStorei(z.UNPACK_SKIP_ROWS, yn),
            z.pixelStorei(z.UNPACK_SKIP_IMAGES, yr),
            we === 0 && Y.generateMipmaps && z.generateMipmap(bt),
            qe.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(A, Y, ee=null, te=null, W=0) {
            return Fs('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),
            this.copyTextureToTexture(A, Y, ee, te, W)
        }
        ,
        this.initRenderTarget = function(A) {
            Fe.get(A).__webglFramebuffer === void 0 && lt.setupRenderTarget(A)
        }
        ,
        this.initTexture = function(A) {
            A.isCubeTexture ? lt.setTextureCube(A, 0) : A.isData3DTexture ? lt.setTexture3D(A, 0) : A.isDataArrayTexture || A.isCompressedArrayTexture ? lt.setTexture2DArray(A, 0) : lt.setTexture2D(A, 0),
            qe.unbindTexture()
        }
        ,
        this.resetState = function() {
            k = 0,
            F = 0,
            j = null,
            qe.reset(),
            Re.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return yi
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const n = this.getContext();
        n.drawingBufferColorSpace = Et._getDrawingBufferColorSpace(e),
        n.unpackColorSpace = Et._getUnpackColorSpace()
    }
}
function _M() {
    const s = ln.useRef(null)
      , e = ln.useRef(null)
      , n = ln.useRef(0);
    return ln.useEffect( () => {
        const r = s.current;
        if (!r)
            return;
        let o;
        try {
            o = new gM({
                alpha: !0,
                antialias: !0
            })
        } catch {
            return
        }
        e.current = o,
        o.setSize(window.innerWidth, window.innerHeight),
        o.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
        o.setClearColor(0, 0),
        r.appendChild(o.domElement);
        const l = new yv
          , u = new jn(60,window.innerWidth / window.innerHeight,.1,1e3);
        u.position.set(0, 0, 8);
        const f = new Pv(16777215,.3);
        l.add(f);
        const m = new mm(65416,.5,50);
        m.position.set(10, 10, 10),
        l.add(m);
        const p = new mm(54527,.3,50);
        p.position.set(-10, -10, -5),
        l.add(p);
        const v = 1500
          , _ = new Un
          , x = new Float32Array(v * 3);
        for (let ne = 0; ne < v; ne++)
            x[ne * 3] = (Math.random() - .5) * 200,
            x[ne * 3 + 1] = (Math.random() - .5) * 200,
            x[ne * 3 + 2] = (Math.random() - .5) * 200;
        _.setAttribute("position", new Zn(x,3));
        const S = new zd({
            color: 16777215,
            size: .3,
            transparent: !0,
            opacity: .6,
            sizeAttenuation: !0
        })
          , E = new cm(_,S);
        l.add(E);
        const T = 400
          , y = new Un
          , g = new Float32Array(T * 3);
        for (let ne = 0; ne < T; ne++)
            g[ne * 3] = (Math.random() - .5) * 30,
            g[ne * 3 + 1] = (Math.random() - .5) * 30,
            g[ne * 3 + 2] = (Math.random() - .5) * 30;
        y.setAttribute("position", new Zn(g,3));
        const N = new zd({
            color: 65416,
            size: .08,
            transparent: !0,
            opacity: .5,
            sizeAttenuation: !0
        })
          , L = new cm(y,N);
        l.add(L);
        const C = [];
        [{
            pos: [-4, 2, -2],
            color: 65416,
            speed: .8
        }, {
            pos: [4, -2, -4],
            color: 16711935,
            speed: 1.2
        }, {
            pos: [-2, -3, -3],
            color: 54527,
            speed: .6
        }, {
            pos: [3, 3, -5],
            color: 16768256,
            speed: 1
        }].forEach( ({pos: ne, color: ae, speed: de}) => {
            const V = new Zd(.6,0)
              , ue = new dm({
                color: ae,
                wireframe: !0,
                transparent: !0,
                opacity: .6,
                emissive: new mt(ae),
                emissiveIntensity: .3
            })
              , re = new fi(V,ue);
            re.position.set(ne[0], ne[1], ne[2]),
            l.add(re),
            C.push({
                mesh: re,
                speed: de
            })
        }
        );
        const k = new ef(1.5,.05,16,100)
          , F = new dm({
            color: 54527,
            emissive: new mt(54527),
            emissiveIntensity: .5,
            transparent: !0,
            opacity: .4
        })
          , j = new fi(k,F);
        j.position.set(3, -1, -3),
        l.add(j);
        const b = new Dv(40,40,65416,65416);
        b.position.y = -5,
        b.material.transparent = !0,
        b.material.opacity = .06,
        l.add(b);
        let R = 0
          , I = 0;
        const oe = ne => {
            R = (ne.clientX / window.innerWidth - .5) * 2,
            I = (ne.clientY / window.innerHeight - .5) * 2
        }
        ;
        window.addEventListener("mousemove", oe);
        const se = () => {
            const ne = window.innerWidth
              , ae = window.innerHeight;
            u.aspect = ne / ae,
            u.updateProjectionMatrix(),
            o.setSize(ne, ae)
        }
        ;
        window.addEventListener("resize", se);
        const ce = () => {
            n.current = requestAnimationFrame(ce);
            const ne = performance.now() * .001;
            E.rotation.y = ne * .01,
            L.rotation.y = ne * .02,
            L.rotation.x = Math.sin(ne * .01) * .1,
            C.forEach( ({mesh: ae, speed: de}) => {
                const V = ne * de;
                ae.rotation.x = Math.sin(V * .4) * .5,
                ae.rotation.y = Math.cos(V * .3) * .5,
                ae.rotation.z = Math.sin(V * .2) * .3,
                ae.position.y += Math.sin(V * .5) * .002
            }
            ),
            j.rotation.x = ne * .15,
            j.rotation.y = ne * .1,
            u.position.x += (R * .5 - u.position.x) * .02,
            u.position.y += (-I * .3 - u.position.y) * .02,
            u.lookAt(0, 0, 0),
            o.render(l, u)
        }
        ;
        return ce(),
        () => {
            cancelAnimationFrame(n.current),
            window.removeEventListener("mousemove", oe),
            window.removeEventListener("resize", se),
            o.dispose(),
            r.contains(o.domElement) && r.removeChild(o.domElement)
        }
    }
    , []),
    O.jsx("div", {
        ref: s,
        className: "fixed inset-0 z-0",
        style: {
            pointerEvents: "none"
        },
        "data-yw": "c3JjL2NvbXBvbmVudHMvU2NlbmUzRC50c3hAMTc3Ojk",
        "data-yw-s": !0
    })
}
class vM extends ln.Component {
    constructor(e) {
        super(e),
        this.state = {
            hasError: !1
        }
    }
    static getDerivedStateFromError() {
        return {
            hasError: !0
        }
    }
    componentDidCatch(e, n) {
        console.warn("3D scene error caught:", e, n)
    }
    render() {
        return this.state.hasError ? this.props.fallback ?? null : this.props.children
    }
}
const xM = [{
    name: "Java / Spring Boot",
    level: 92,
    color: "#00ff88"
}, {
    name: "React / Node.js",
    level: 85,
    color: "#00d4ff"
}, {
    name: "AWS Cloud",
    level: 88,
    color: "#ff00ff"
}, {
    name: "DevOps (Docker/CI-CD)",
    level: 82,
    color: "#ffdd00"
}, {
    name: "PostgreSQL / MongoDB",
    level: 80,
    color: "#00ff88"
}, {
    name: "DSA / System Design",
    level: 78,
    color: "#00d4ff"
}]
  , yM = [{
    title: "Software Engineer Intern",
    company: "GoBasera",
    period: "Sep 2025  Present",
    tag: "ACTIVE MISSION",
    points: ["Building live SaaS platform features with React & PostgreSQL", "80%+ test coverage using TDD & enterprise QA standards", "Extreme Programming: pair coding, code reviews, Kanban flow"]
}, {
    title: "Tech Support Intern",
    company: "Bynry Inc.",
    period: "Jul 2025  Aug 2025",
    tag: "COMPLETED",
    points: ["API testing & Root Cause Analysis with QA teams", "AWS & Jenkins automation for data migration & incident mgmt"]
}, {
    title: "Full Stack Developer Intern",
    company: "Bharat Intern",
    period: "Feb 2024  Mar 2024",
    tag: "COMPLETED",
    points: ["Delivered expense tracker & signup systems (Node.js + MongoDB)", "Optimized API response times & secure auth flows"]
}]
  , SM = [{
    title: "DriveSmarter",
    subtitle: "AI Vehicle Co-Pilot",
    desc: "End-to-end AI system integrating vehicle diagnostics with real-time Computer Vision (OpenCV). React/NestJS dashboard for hands-free vehicle telemetry. Backend with Docker + AWS for scalable data processing.",
    tech: ["React", "NestJS", "OpenCV", "Docker", "AWS"],
    color: "#00ff88"
}, {
    title: "DevOps Chatbot",
    subtitle: "Automated Infrastructure",
    desc: "Slack-integrated Jenkins automation for health checks, logs, and service restarts. Docker-deployed with automated CI/CD pipelines for streamlined system maintenance.",
    tech: ["Slack API", "Jenkins", "Docker", "CI/CD"],
    color: "#00d4ff"
}, {
    title: "Event Portal",
    subtitle: "Serverless Management",
    desc: "Serverless AWS Amplify backend with S3 for secure image uploads and API Gateway. Full infrastructure management with scalable cloud architecture.",
    tech: ["AWS Amplify", "S3", "API Gateway", "Serverless"],
    color: "#ff00ff"
}]
  , wM = ["AWS Academy Cloud Foundations (2024)", "AWS APAC Solutions Architecture  Forage (2025)", "Verizon Cloud Platform  Forage (2025)", "Web Development  Teachnook & IIT Bhubaneswar", "Linguaskill  Soft Skills Certification"];
function MM() {
    const s = ln.useRef(null);
    return ln.useEffect( () => {
        const e = s.current;
        if (!e)
            return;
        const n = new IntersectionObserver( ([r]) => {
            r.isIntersecting && (e.classList.add("visible"),
            n.unobserve(e))
        }
        ,{
            threshold: .15
        });
        return n.observe(e),
        () => n.disconnect()
    }
    , []),
    s
}
function In({children: s, className: e=""}) {
    const n = MM();
    return O.jsx("div", {
        ref: n,
        className: `reveal-section ${e}`,
        "data-yw": "c3JjL0FwcC50c3hAMTIzOjQ",
        "data-yw-s": !0,
        children: s
    })
}
function EM({onComplete: s}) {
    const [e,n] = ln.useState(0)
      , [r,o] = ln.useState([])
      , l = ["> Initializing SHRIYASH.exe ...", "> Loading neural networks  OK", "> Connecting to cloud matrix  OK", "> Rendering 3D viewport ...", "> Compiling skill modules  OK", "> System ready. Welcome, Player."];
    return ln.useEffect( () => {
        let u = 0;
        const f = setInterval( () => {
            u < l.length ? (o(m => [...m, l[u]]),
            n((u + 1) / l.length * 100),
            u++) : (clearInterval(f),
            setTimeout(s, 600))
        }
        , 400);
        return () => clearInterval(f)
    }
    , []),
    O.jsx("div", {
        className: "fixed inset-0 z-[100] flex items-center justify-center bg-void",
        "data-yw": "c3JjL0FwcC50c3hAMTU5OjQ",
        "data-yw-s": !0,
        children: O.jsxs("div", {
            className: "w-full max-w-lg px-6",
            "data-yw": "c3JjL0FwcC50c3hAMTYwOjY",
            "data-yw-s": !0,
            children: [O.jsx("h2", {
                className: "font-heading text-neon-green text-2xl mb-6 tracking-wider animate-pulse-neon",
                "data-yw": "c3JjL0FwcC50c3hAMTYxOjg",
                "data-yw-t": !0,
                "data-yw-s": !0,
                children: "SYSTEM BOOT"
            }), O.jsxs("div", {
                className: "font-mono text-sm space-y-1 mb-8 min-h-[180px]",
                "data-yw": "c3JjL0FwcC50c3hAMTY0Ojg",
                "data-yw-s": !0,
                children: [r.map( (u, f) => O.jsx("div", {
                    className: "text-neon-green/80 animate-fade-in",
                    "data-yw": "c3JjL0FwcC50c3hAMTY2OjEy",
                    "data-yw-s": !0,
                    children: u
                }, f)), e < 100 && O.jsx("span", {
                    className: "text-neon-green animate-blink",
                    "data-yw": "c3JjL0FwcC50c3hAMTY4OjI5",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    children: ""
                })]
            }), O.jsx("div", {
                className: "w-full h-1 bg-void-200 rounded overflow-hidden",
                "data-yw": "c3JjL0FwcC50c3hAMTcwOjg",
                "data-yw-s": !0,
                children: O.jsx("div", {
                    className: "h-full bg-neon-green transition-all duration-300 shadow-neon",
                    style: {
                        width: `${e}%`
                    },
                    "data-yw": "c3JjL0FwcC50c3hAMTcxOjEw"
                })
            }), O.jsxs("div", {
                className: "font-mono text-xs text-neon-green/50 mt-2",
                "data-yw": "c3JjL0FwcC50c3hAMTc2Ojg",
                "data-yw-s": !0,
                children: [Math.round(e), O.jsx("span", {
                    "data-yw": "c3JjL0FwcC50c3hAMTc2Ojg5",
                    "data-yw-t": !0,
                    "data-yw-auto": !0,
                    children: "% LOADED"
                })]
            })]
        })
    })
}
function TM() {
    const [s,e] = ln.useState(!1)
      , [n,r] = ln.useState(!1);
    ln.useEffect( () => {
        const l = () => e(window.scrollY > 50);
        return window.addEventListener("scroll", l),
        () => window.removeEventListener("scroll", l)
    }
    , []);
    const o = [{
        label: "ABOUT",
        href: "#about"
    }, {
        label: "SKILLS",
        href: "#skills"
    }, {
        label: "XP",
        href: "#experience"
    }, {
        label: "PROJECTS",
        href: "#projects"
    }, {
        label: "CONTACT",
        href: "#contact"
    }];
    return O.jsxs("nav", {
        className: `fixed top-0 left-0 right-0 z-50 transition-all duration-300 ${s ? "bg-void/90 backdrop-blur-md border-b border-neon-green/10" : ""}`,
        "data-yw": "c3JjL0FwcC50c3hAMjAyOjQ",
        "data-yw-s": !0,
        children: [O.jsxs("div", {
            className: "max-w-6xl mx-auto px-4 py-3 flex items-center justify-between",
            "data-yw": "c3JjL0FwcC50c3hAMjAzOjY",
            "data-yw-s": !0,
            children: [O.jsxs("a", {
                href: "#",
                className: "font-heading text-neon-green text-lg tracking-widest hover:text-neon-cyan transition-colors",
                "data-yw": "c3JjL0FwcC50c3hAMjA0Ojg",
                "data-yw-s": !0,
                "data-yw-l": !0,
                children: [O.jsx("span", {
                    "data-yw": "c3JjL0FwcC50c3hAMjA0OjEyNA",
                    "data-yw-t": !0,
                    "data-yw-auto": !0,
                    children: "SS"
                }), O.jsx("span", {
                    className: "text-neon-cyan",
                    "data-yw": "c3JjL0FwcC50c3hAMjA1OjEy",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    children: "."
                }), O.jsx("span", {
                    "data-yw": "c3JjL0FwcC50c3hAMjA1OjUz",
                    "data-yw-t": !0,
                    "data-yw-auto": !0,
                    children: "exe"
                })]
            }), O.jsx("div", {
                className: "hidden tablet:flex items-center gap-6",
                "data-yw": "c3JjL0FwcC50c3hAMjA3Ojg",
                "data-yw-s": !0,
                children: o.map(l => O.jsxs("a", {
                    href: l.href,
                    className: "font-heading text-xs tracking-wider text-white/60 hover:text-neon-green transition-colors relative group",
                    "data-yw": "c3JjL0FwcC50c3hAMjA5OjEy",
                    "data-yw-s": !0,
                    children: [l.label, O.jsx("span", {
                        className: "absolute bottom-0 left-0 w-0 h-[1px] bg-neon-green transition-all duration-300 group-hover:w-full",
                        "data-yw": "c3JjL0FwcC50c3hAMjE1OjE0",
                        "data-yw-s": !0
                    })]
                }, l.label))
            }), O.jsx("button", {
                className: "tablet:hidden text-neon-green font-mono text-sm",
                onClick: () => r(!n),
                "data-yw": "c3JjL0FwcC50c3hAMjE5Ojg",
                "data-yw-s": !0,
                children: n ? "[X]" : "[]"
            })]
        }), n && O.jsx("div", {
            className: "tablet:hidden bg-void/95 backdrop-blur-md border-t border-neon-green/10 px-4 py-4 space-y-3",
            "data-yw": "c3JjL0FwcC50c3hAMjI3Ojg",
            "data-yw-s": !0,
            children: o.map(l => O.jsxs("a", {
                href: l.href,
                className: "block font-heading text-sm tracking-wider text-white/70 hover:text-neon-green transition-colors",
                onClick: () => r(!1),
                "data-yw": "c3JjL0FwcC50c3hAMjI5OjEy",
                "data-yw-s": !0,
                children: ["> ", l.label]
            }, l.label))
        })]
    })
}
function AM() {
    const [s,e] = ln.useState("")
      , n = "Software Engineer // Cloud Architect // AI Enthusiast";
    return ln.useEffect( () => {
        let r = 0;
        const o = setInterval( () => {
            r <= n.length ? (e(n.slice(0, r)),
            r++) : clearInterval(o)
        }
        , 40);
        return () => clearInterval(o)
    }
    , []),
    O.jsx("section", {
        className: "relative min-h-screen flex items-center justify-center px-4 pt-16",
        "data-yw": "c3JjL0FwcC50c3hAMjYzOjQ",
        "data-yw-s": !0,
        children: O.jsxs("div", {
            className: "text-center z-10 max-w-4xl",
            "data-yw": "c3JjL0FwcC50c3hAMjY0OjY",
            "data-yw-s": !0,
            children: [O.jsx("div", {
                className: "font-mono text-neon-green/60 text-xs tracking-[0.3em] mb-4 animate-fade-in",
                "data-yw": "c3JjL0FwcC50c3hAMjY1Ojg",
                "data-yw-s": !0,
                children: "// PLAYER_ONE.INIT"
            }), O.jsx("h1", {
                className: "font-heading text-5xl tablet:text-7xl desktop:text-8xl font-bold mb-4 tracking-wider",
                "data-yw": "c3JjL0FwcC50c3hAMjY4Ojg",
                "data-yw-s": !0,
                children: O.jsx("span", {
                    className: "glitch-text text-white",
                    "data-text": "SHRIYASH",
                    "data-yw": "c3JjL0FwcC50c3hAMjY5OjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    children: "SHRIYASH"
                })
            }), O.jsx("h2", {
                className: "font-heading text-2xl tablet:text-3xl desktop:text-4xl text-neon-green font-semibold mb-6 tracking-wide",
                "data-yw": "c3JjL0FwcC50c3hAMjcxOjg",
                "data-yw-t": !0,
                "data-yw-s": !0,
                children: "SAWANT"
            }), O.jsxs("div", {
                className: "font-mono text-sm tablet:text-base text-neon-cyan/80 mb-8 min-h-[24px]",
                "data-yw": "c3JjL0FwcC50c3hAMjc0Ojg",
                "data-yw-s": !0,
                children: [O.jsx("span", {
                    "data-yw": "c3JjL0FwcC50c3hAMjc1OjEw",
                    "data-yw-s": !0,
                    children: s
                }), O.jsx("span", {
                    className: "animate-blink text-neon-green",
                    "data-yw": "c3JjL0FwcC50c3hAMjc2OjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    children: ""
                })]
            }), O.jsxs("div", {
                className: "flex flex-col tablet:flex-row gap-4 justify-center items-center mb-8",
                "data-yw": "c3JjL0FwcC50c3hAMjc4Ojg",
                "data-yw-s": !0,
                children: [O.jsx("a", {
                    href: "#projects",
                    className: "neon-border hud-corners px-8 py-3 font-heading text-sm tracking-wider text-neon-green hover:bg-neon-green/10 transition-all hover:shadow-neon",
                    "data-yw": "c3JjL0FwcC50c3hAMjc5OjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    "data-yw-l": !0,
                    children: "VIEW PROJECTS"
                }), O.jsx("a", {
                    href: "#contact",
                    className: "neon-border-cyan px-8 py-3 font-heading text-sm tracking-wider text-neon-cyan hover:bg-neon-cyan/10 transition-all hover:shadow-neon-cyan",
                    "data-yw": "c3JjL0FwcC50c3hAMjg1OjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    "data-yw-l": !0,
                    children: "CONNECT"
                })]
            }), O.jsxs("div", {
                className: "flex justify-center gap-6 font-mono text-xs text-white/40",
                "data-yw": "c3JjL0FwcC50c3hAMjkyOjg",
                "data-yw-s": !0,
                children: [O.jsx("a", {
                    href: "https://linkedin.com/in/shriyash-sawant-5a6a6120a",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "hover:text-neon-green transition-colors",
                    "data-yw": "c3JjL0FwcC50c3hAMjkzOjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    "data-yw-l": !0,
                    children: "[LinkedIn]"
                }), O.jsx("a", {
                    href: "https://github.com/shriyashsawant",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "hover:text-neon-cyan transition-colors",
                    "data-yw": "c3JjL0FwcC50c3hAMjk0OjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    "data-yw-l": !0,
                    children: "[GitHub]"
                }), O.jsx("a", {
                    href: "mailto:shriyashsantoshsawant@gmail.com",
                    className: "hover:text-neon-magenta transition-colors",
                    "data-yw": "c3JjL0FwcC50c3hAMjk1OjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    "data-yw-l": !0,
                    children: "[Email]"
                })]
            }), O.jsxs("div", {
                className: "absolute bottom-8 left-1/2 -translate-x-1/2 flex flex-col items-center gap-2 animate-float",
                "data-yw": "c3JjL0FwcC50c3hAMjk5Ojg",
                "data-yw-s": !0,
                children: [O.jsx("span", {
                    className: "font-mono text-[10px] tracking-[0.3em] text-neon-green/40",
                    "data-yw": "c3JjL0FwcC50c3hAMzAwOjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    children: "SCROLL"
                }), O.jsx("div", {
                    className: "w-[1px] h-8 bg-gradient-to-b from-neon-green/40 to-transparent",
                    "data-yw": "c3JjL0FwcC50c3hAMzAxOjEw",
                    "data-yw-s": !0
                })]
            })]
        })
    })
}
function CM() {
    return O.jsx("section", {
        id: "about",
        className: "relative z-10 py-24 px-4",
        "data-yw": "c3JjL0FwcC50c3hAMzExOjQ",
        "data-yw-s": !0,
        children: O.jsxs("div", {
            className: "max-w-4xl mx-auto",
            "data-yw": "c3JjL0FwcC50c3hAMzEyOjY",
            "data-yw-s": !0,
            children: [O.jsxs(In, {
                "data-yw": "c3JjL0FwcC50c3hAMzEzOjg",
                "data-yw-s": !0,
                children: [O.jsx("div", {
                    className: "font-mono text-neon-green/50 text-xs mb-2 tracking-wider",
                    "data-yw": "c3JjL0FwcC50c3hAMzE0OjEw",
                    "data-yw-s": !0,
                    children: "// 01"
                }), O.jsxs("h3", {
                    className: "font-heading text-3xl tablet:text-4xl text-white font-bold tracking-wider mb-8",
                    "data-yw": "c3JjL0FwcC50c3hAMzE1OjEw",
                    "data-yw-s": !0,
                    children: [O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hAMzE1OjEwNQ",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "ABOUT"
                    }), O.jsx("span", {
                        className: "text-neon-green",
                        "data-yw": "c3JjL0FwcC50c3hAMzE2OjE3",
                        "data-yw-t": !0,
                        "data-yw-s": !0,
                        children: "_"
                    }), O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hAMzE2OjU5",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "ME"
                    })]
                })]
            }), O.jsx(In, {
                "data-yw": "c3JjL0FwcC50c3hAMzE5Ojg",
                "data-yw-s": !0,
                children: O.jsx("div", {
                    className: "neon-border hud-corners bg-hud-card rounded-lg p-6 tablet:p-8",
                    "data-yw": "c3JjL0FwcC50c3hAMzIwOjEw",
                    "data-yw-s": !0,
                    children: O.jsxs("div", {
                        className: "grid tablet:grid-cols-3 gap-6",
                        "data-yw": "c3JjL0FwcC50c3hAMzIxOjEy",
                        "data-yw-s": !0,
                        children: [O.jsxs("div", {
                            className: "tablet:col-span-2",
                            "data-yw": "c3JjL0FwcC50c3hAMzIyOjE0",
                            "data-yw-s": !0,
                            children: [O.jsxs("p", {
                                className: "font-body text-lg text-white/80 leading-relaxed mb-4",
                                "data-yw": "c3JjL0FwcC50c3hAMzIzOjE2",
                                "data-yw-s": !0,
                                children: [O.jsx("span", {
                                    "data-yw": "c3JjL0FwcC50c3hAMzIzOjg0",
                                    "data-yw-t": !0,
                                    "data-yw-auto": !0,
                                    children: "Computer Engineering student specializing in "
                                }), O.jsx("span", {
                                    className: "text-neon-green font-semibold",
                                    "data-yw": "c3JjL0FwcC50c3hAMzI0OjYz",
                                    "data-yw-t": !0,
                                    "data-yw-s": !0,
                                    children: "Cloud Computing"
                                }), O.jsx("span", {
                                    "data-yw": "c3JjL0FwcC50c3hAMzI0OjEzMw",
                                    "data-yw-t": !0,
                                    "data-yw-auto": !0,
                                    children: " and"
                                }), " ", O.jsx("span", {
                                    className: "text-neon-cyan font-semibold",
                                    "data-yw": "c3JjL0FwcC50c3hAMzI1OjE4",
                                    "data-yw-t": !0,
                                    "data-yw-s": !0,
                                    children: "AI/ML"
                                }), O.jsx("span", {
                                    "data-yw": "c3JjL0FwcC50c3hAMzI1Ojc3",
                                    "data-yw-t": !0,
                                    "data-yw-auto": !0,
                                    children: ", driven by a deep-seated interest in high-precision engineering and Japanese technological innovation."
                                })]
                            }), O.jsxs("p", {
                                className: "font-body text-base text-white/60 leading-relaxed",
                                "data-yw": "c3JjL0FwcC50c3hAMzI4OjE2",
                                "data-yw-s": !0,
                                children: [O.jsx("span", {
                                    "data-yw": "c3JjL0FwcC50c3hAMzI4Ojgx",
                                    "data-yw-t": !0,
                                    "data-yw-auto": !0,
                                    children: "Expert in Java/JEE and Spring Boot with a proven track record of building scalable SaaS solutions and AI-driven automation. Committed to the philosophy of "
                                }), O.jsx("span", {
                                    className: "text-neon-magenta",
                                    "data-yw": "c3JjL0FwcC50c3hAMzMwOjQ5",
                                    "data-yw-t": !0,
                                    "data-yw-s": !0,
                                    children: "Kaizen"
                                }), O.jsx("span", {
                                    "data-yw": "c3JjL0FwcC50c3hAMzMwOjk4",
                                    "data-yw-t": !0,
                                    "data-yw-auto": !0,
                                    children: "  continuous improvement  and eager to contribute technical rigor to global engineering teams."
                                })]
                            })]
                        }), O.jsxs("div", {
                            className: "space-y-4",
                            "data-yw": "c3JjL0FwcC50c3hAMzM0OjE0",
                            "data-yw-s": !0,
                            children: [O.jsxs("div", {
                                className: "neon-border rounded-lg p-4 text-center",
                                "data-yw": "c3JjL0FwcC50c3hAMzM1OjE2",
                                "data-yw-s": !0,
                                children: [O.jsx("div", {
                                    className: "font-heading text-2xl text-neon-green",
                                    "data-yw": "c3JjL0FwcC50c3hAMzM2OjE4",
                                    "data-yw-t": !0,
                                    "data-yw-s": !0,
                                    children: "B.Tech"
                                }), O.jsx("div", {
                                    className: "font-mono text-xs text-white/50 mt-1",
                                    "data-yw": "c3JjL0FwcC50c3hAMzM3OjE4",
                                    "data-yw-t": !0,
                                    "data-yw-s": !0,
                                    children: "MIT ADT University"
                                }), O.jsx("div", {
                                    className: "font-mono text-xs text-neon-cyan/60",
                                    "data-yw": "c3JjL0FwcC50c3hAMzM4OjE4",
                                    "data-yw-t": !0,
                                    "data-yw-s": !0,
                                    children: "2022  2026"
                                })]
                            }), O.jsxs("div", {
                                className: "neon-border-cyan rounded-lg p-4 text-center",
                                "data-yw": "c3JjL0FwcC50c3hAMzQwOjE2",
                                "data-yw-s": !0,
                                children: [O.jsx("div", {
                                    className: "font-heading text-lg text-neon-cyan",
                                    "data-yw": "c3JjL0FwcC50c3hAMzQxOjE4",
                                    "data-yw-t": !0,
                                    "data-yw-s": !0,
                                    children: "Pune, India"
                                }), O.jsx("div", {
                                    className: "font-mono text-xs text-white/50 mt-1",
                                    "data-yw": "c3JjL0FwcC50c3hAMzQyOjE4",
                                    "data-yw-t": !0,
                                    "data-yw-s": !0,
                                    children: "Base Location"
                                })]
                            })]
                        })]
                    })
                })
            })]
        })
    })
}
function RM() {
    return O.jsx("section", {
        id: "skills",
        className: "relative z-10 py-24 px-4",
        "data-yw": "c3JjL0FwcC50c3hAMzU2OjQ",
        "data-yw-s": !0,
        children: O.jsxs("div", {
            className: "max-w-4xl mx-auto",
            "data-yw": "c3JjL0FwcC50c3hAMzU3OjY",
            "data-yw-s": !0,
            children: [O.jsxs(In, {
                "data-yw": "c3JjL0FwcC50c3hAMzU4Ojg",
                "data-yw-s": !0,
                children: [O.jsx("div", {
                    className: "font-mono text-neon-green/50 text-xs mb-2 tracking-wider",
                    "data-yw": "c3JjL0FwcC50c3hAMzU5OjEw",
                    "data-yw-s": !0,
                    children: "// 02"
                }), O.jsxs("h3", {
                    className: "font-heading text-3xl tablet:text-4xl text-white font-bold tracking-wider mb-2",
                    "data-yw": "c3JjL0FwcC50c3hAMzYwOjEw",
                    "data-yw-s": !0,
                    children: [O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hAMzYwOjEwNQ",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "SKILL"
                    }), O.jsx("span", {
                        className: "text-neon-green",
                        "data-yw": "c3JjL0FwcC50c3hAMzYxOjE3",
                        "data-yw-t": !0,
                        "data-yw-s": !0,
                        children: "_"
                    }), O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hAMzYxOjU5",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "TREE"
                    })]
                }), O.jsx("p", {
                    className: "font-mono text-xs text-neon-cyan/50 mb-10",
                    "data-yw": "c3JjL0FwcC50c3hAMzYzOjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    children: "POWER LEVELS"
                })]
            }), O.jsx("div", {
                className: "grid gap-5",
                "data-yw": "c3JjL0FwcC50c3hAMzY2Ojg",
                "data-yw-s": !0,
                children: xM.map( (s, e) => O.jsx(In, {
                    "data-yw": "c3JjL0FwcC50c3hAMzY4OjEy",
                    "data-yw-s": !0,
                    children: O.jsxs("div", {
                        className: "flex items-center gap-4",
                        "data-yw": "c3JjL0FwcC50c3hAMzY5OjE0",
                        "data-yw-s": !0,
                        children: [O.jsx("div", {
                            className: "font-mono text-xs text-white/30 w-8",
                            "data-yw": "c3JjL0FwcC50c3hAMzcwOjE2",
                            "data-yw-s": !0,
                            children: String(e + 1).padStart(2, "0")
                        }), O.jsxs("div", {
                            className: "flex-1",
                            "data-yw": "c3JjL0FwcC50c3hAMzcxOjE2",
                            "data-yw-s": !0,
                            children: [O.jsxs("div", {
                                className: "flex justify-between mb-1",
                                "data-yw": "c3JjL0FwcC50c3hAMzcyOjE4",
                                "data-yw-s": !0,
                                children: [O.jsx("span", {
                                    className: "font-heading text-sm tracking-wider text-white/90",
                                    "data-yw": "c3JjL0FwcC50c3hAMzczOjIw",
                                    "data-yw-s": !0,
                                    children: s.name
                                }), O.jsxs("span", {
                                    className: "font-mono text-xs",
                                    style: {
                                        color: s.color
                                    },
                                    "data-yw": "c3JjL0FwcC50c3hAMzc0OjIw",
                                    children: [s.level, O.jsx("span", {
                                        "data-yw": "c3JjL0FwcC50c3hAMzc0OjEwMA",
                                        "data-yw-t": !0,
                                        "data-yw-auto": !0,
                                        children: "/100"
                                    })]
                                })]
                            }), O.jsx("div", {
                                className: "w-full h-2 bg-void-200 rounded-full overflow-hidden",
                                "data-yw": "c3JjL0FwcC50c3hAMzc2OjE4",
                                "data-yw-s": !0,
                                children: O.jsx("div", {
                                    className: "h-full rounded-full skill-bar-fill",
                                    style: {
                                        "--bar-width": `${s.level}%`,
                                        backgroundColor: s.color,
                                        boxShadow: `0 0 10px ${s.color}40`
                                    },
                                    "data-yw": "c3JjL0FwcC50c3hAMzc3OjIw"
                                })
                            })]
                        })]
                    })
                }, s.name))
            }), O.jsx(In, {
                className: "mt-10",
                "data-yw": "c3JjL0FwcC50c3hAMzkyOjg",
                "data-yw-s": !0,
                children: O.jsxs("div", {
                    className: "neon-border rounded-lg p-5 bg-hud-card",
                    "data-yw": "c3JjL0FwcC50c3hAMzkzOjEw",
                    "data-yw-s": !0,
                    children: [O.jsx("h4", {
                        className: "font-heading text-sm tracking-wider text-neon-green mb-4",
                        "data-yw": "c3JjL0FwcC50c3hAMzk0OjEy",
                        "data-yw-t": !0,
                        "data-yw-s": !0,
                        children: "TECH_INVENTORY"
                    }), O.jsx("div", {
                        className: "flex flex-wrap gap-2",
                        "data-yw": "c3JjL0FwcC50c3hAMzk1OjEy",
                        "data-yw-s": !0,
                        children: ["Java/JEE", "Spring Boot", "React", "Node.js", "AWS", "Docker", "Jenkins", "PostgreSQL", "MongoDB", "TypeScript", "Hibernate", "REST APIs", "Microservices", "GitHub Actions", "Nginx", "Tailwind CSS"].map(s => O.jsx("span", {
                            className: "font-mono text-xs px-3 py-1.5 rounded bg-void-200 text-neon-cyan/70 border border-neon-cyan/10 hover:border-neon-cyan/30 hover:text-neon-cyan transition-all cursor-default",
                            "data-yw": "c3JjL0FwcC50c3hAMzk3OjE2",
                            "data-yw-s": !0,
                            children: s
                        }, s))
                    })]
                })
            })]
        })
    })
}
function bM() {
    return O.jsx("section", {
        id: "experience",
        className: "relative z-10 py-24 px-4",
        "data-yw": "c3JjL0FwcC50c3hANDEyOjQ",
        "data-yw-s": !0,
        children: O.jsxs("div", {
            className: "max-w-4xl mx-auto",
            "data-yw": "c3JjL0FwcC50c3hANDEzOjY",
            "data-yw-s": !0,
            children: [O.jsxs(In, {
                "data-yw": "c3JjL0FwcC50c3hANDE0Ojg",
                "data-yw-s": !0,
                children: [O.jsx("div", {
                    className: "font-mono text-neon-green/50 text-xs mb-2 tracking-wider",
                    "data-yw": "c3JjL0FwcC50c3hANDE1OjEw",
                    "data-yw-s": !0,
                    children: "// 03"
                }), O.jsxs("h3", {
                    className: "font-heading text-3xl tablet:text-4xl text-white font-bold tracking-wider mb-2",
                    "data-yw": "c3JjL0FwcC50c3hANDE2OjEw",
                    "data-yw-s": !0,
                    children: [O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hANDE2OjEwNQ",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "MISSION"
                    }), O.jsx("span", {
                        className: "text-neon-green",
                        "data-yw": "c3JjL0FwcC50c3hANDE3OjE5",
                        "data-yw-t": !0,
                        "data-yw-s": !0,
                        children: "_"
                    }), O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hANDE3OjYx",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "LOG"
                    })]
                }), O.jsx("p", {
                    className: "font-mono text-xs text-neon-cyan/50 mb-10",
                    "data-yw": "c3JjL0FwcC50c3hANDE5OjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    children: "EXPERIENCE TIMELINE"
                })]
            }), O.jsxs("div", {
                className: "relative",
                "data-yw": "c3JjL0FwcC50c3hANDIyOjg",
                "data-yw-s": !0,
                children: [O.jsx("div", {
                    className: "absolute left-4 tablet:left-6 top-0 bottom-0 w-[1px] bg-gradient-to-b from-neon-green/30 via-neon-cyan/20 to-transparent",
                    "data-yw": "c3JjL0FwcC50c3hANDI0OjEw",
                    "data-yw-s": !0
                }), O.jsx("div", {
                    className: "space-y-8",
                    "data-yw": "c3JjL0FwcC50c3hANDI2OjEw",
                    "data-yw-s": !0,
                    children: yM.map( (s, e) => O.jsx(In, {
                        "data-yw": "c3JjL0FwcC50c3hANDI4OjE0",
                        "data-yw-s": !0,
                        children: O.jsxs("div", {
                            className: "relative pl-12 tablet:pl-16",
                            "data-yw": "c3JjL0FwcC50c3hANDI5OjE2",
                            "data-yw-s": !0,
                            children: [O.jsx("div", {
                                className: "absolute left-2.5 tablet:left-4.5 top-2 w-3 h-3 rounded-full border-2 border-neon-green bg-void shadow-neon",
                                "data-yw": "c3JjL0FwcC50c3hANDMxOjE4",
                                "data-yw-s": !0
                            }), O.jsxs("div", {
                                className: "neon-border hud-corners bg-hud-card rounded-lg p-5 card-3d",
                                "data-yw": "c3JjL0FwcC50c3hANDMzOjE4",
                                "data-yw-s": !0,
                                children: [O.jsxs("div", {
                                    className: "flex flex-wrap items-center gap-3 mb-3",
                                    "data-yw": "c3JjL0FwcC50c3hANDM0OjIw",
                                    "data-yw-s": !0,
                                    children: [O.jsx("span", {
                                        className: "font-mono text-[10px] px-2 py-0.5 rounded bg-neon-green/10 text-neon-green border border-neon-green/20",
                                        "data-yw": "c3JjL0FwcC50c3hANDM1OjIy",
                                        "data-yw-s": !0,
                                        children: s.tag
                                    }), O.jsx("span", {
                                        className: "font-mono text-xs text-white/40",
                                        "data-yw": "c3JjL0FwcC50c3hANDM4OjIy",
                                        "data-yw-s": !0,
                                        children: s.period
                                    })]
                                }), O.jsx("h4", {
                                    className: "font-heading text-lg tracking-wider text-white mb-1",
                                    "data-yw": "c3JjL0FwcC50c3hANDQwOjIw",
                                    "data-yw-s": !0,
                                    children: s.title
                                }), O.jsxs("div", {
                                    className: "font-mono text-sm text-neon-cyan/70 mb-3",
                                    "data-yw": "c3JjL0FwcC50c3hANDQxOjIw",
                                    "data-yw-s": !0,
                                    children: [O.jsx("span", {
                                        "data-yw": "c3JjL0FwcC50c3hANDQxOjc4",
                                        "data-yw-t": !0,
                                        "data-yw-auto": !0,
                                        children: "@ "
                                    }), s.company]
                                }), O.jsx("ul", {
                                    className: "space-y-2",
                                    "data-yw": "c3JjL0FwcC50c3hANDQyOjIw",
                                    "data-yw-s": !0,
                                    children: s.points.map( (n, r) => O.jsxs("li", {
                                        className: "font-body text-sm text-white/60 flex gap-2",
                                        "data-yw": "c3JjL0FwcC50c3hANDQ0OjI0",
                                        "data-yw-s": !0,
                                        children: [O.jsx("span", {
                                            className: "text-neon-green/60 mt-0.5",
                                            "data-yw": "c3JjL0FwcC50c3hANDQ1OjI2",
                                            "data-yw-t": !0,
                                            "data-yw-s": !0,
                                            children: ""
                                        }), O.jsx("span", {
                                            "data-yw": "c3JjL0FwcC50c3hANDQ2OjI2",
                                            "data-yw-s": !0,
                                            children: n
                                        })]
                                    }, r))
                                })]
                            })]
                        })
                    }, e))
                })]
            })]
        })
    })
}
function LM() {
    return O.jsx("section", {
        id: "projects",
        className: "relative z-10 py-24 px-4",
        "data-yw": "c3JjL0FwcC50c3hANDY0OjQ",
        "data-yw-s": !0,
        children: O.jsxs("div", {
            className: "max-w-5xl mx-auto",
            "data-yw": "c3JjL0FwcC50c3hANDY1OjY",
            "data-yw-s": !0,
            children: [O.jsxs(In, {
                "data-yw": "c3JjL0FwcC50c3hANDY2Ojg",
                "data-yw-s": !0,
                children: [O.jsx("div", {
                    className: "font-mono text-neon-green/50 text-xs mb-2 tracking-wider",
                    "data-yw": "c3JjL0FwcC50c3hANDY3OjEw",
                    "data-yw-s": !0,
                    children: "// 04"
                }), O.jsxs("h3", {
                    className: "font-heading text-3xl tablet:text-4xl text-white font-bold tracking-wider mb-2",
                    "data-yw": "c3JjL0FwcC50c3hANDY4OjEw",
                    "data-yw-s": !0,
                    children: [O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hANDY4OjEwNQ",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "BUILD"
                    }), O.jsx("span", {
                        className: "text-neon-green",
                        "data-yw": "c3JjL0FwcC50c3hANDY5OjE3",
                        "data-yw-t": !0,
                        "data-yw-s": !0,
                        children: "_"
                    }), O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hANDY5OjU5",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "LOG"
                    })]
                }), O.jsx("p", {
                    className: "font-mono text-xs text-neon-cyan/50 mb-10",
                    "data-yw": "c3JjL0FwcC50c3hANDcxOjEw",
                    "data-yw-t": !0,
                    "data-yw-s": !0,
                    children: "KEY PROJECTS"
                })]
            }), O.jsx("div", {
                className: "grid tablet:grid-cols-2 desktop:grid-cols-3 gap-6",
                "data-yw": "c3JjL0FwcC50c3hANDc0Ojg",
                "data-yw-s": !0,
                children: SM.map(s => O.jsx(In, {
                    "data-yw": "c3JjL0FwcC50c3hANDc2OjEy",
                    "data-yw-s": !0,
                    children: O.jsxs("div", {
                        className: "neon-border bg-hud-card rounded-lg p-6 h-full card-3d group hover:shadow-neon transition-all duration-500",
                        style: {
                            borderColor: `${s.color}20`
                        },
                        "data-yw": "c3JjL0FwcC50c3hANDc3OjE0",
                        children: [O.jsxs("div", {
                            className: "flex items-center gap-2 mb-3",
                            "data-yw": "c3JjL0FwcC50c3hANDgxOjE2",
                            "data-yw-s": !0,
                            children: [O.jsx("div", {
                                className: "w-2 h-2 rounded-full",
                                style: {
                                    backgroundColor: s.color,
                                    boxShadow: `0 0 8px ${s.color}`
                                },
                                "data-yw": "c3JjL0FwcC50c3hANDgyOjE4"
                            }), O.jsx("span", {
                                className: "font-mono text-[10px] tracking-wider",
                                style: {
                                    color: `${s.color}99`
                                },
                                "data-yw": "c3JjL0FwcC50c3hANDgzOjE4",
                                children: s.subtitle.toUpperCase()
                            })]
                        }), O.jsx("h4", {
                            className: "font-heading text-xl tracking-wider text-white mb-3 group-hover:text-neon-green transition-colors",
                            "data-yw": "c3JjL0FwcC50c3hANDg1OjE2",
                            "data-yw-s": !0,
                            children: s.title
                        }), O.jsx("p", {
                            className: "font-body text-sm text-white/50 leading-relaxed mb-4",
                            "data-yw": "c3JjL0FwcC50c3hANDg4OjE2",
                            "data-yw-s": !0,
                            children: s.desc
                        }), O.jsx("div", {
                            className: "flex flex-wrap gap-1.5 mt-auto",
                            "data-yw": "c3JjL0FwcC50c3hANDg5OjE2",
                            "data-yw-s": !0,
                            children: s.tech.map(e => O.jsx("span", {
                                className: "font-mono text-[10px] px-2 py-0.5 rounded bg-void-200 text-white/40 border border-white/5",
                                "data-yw": "c3JjL0FwcC50c3hANDkxOjIw",
                                "data-yw-s": !0,
                                children: e
                            }, e))
                        })]
                    })
                }, s.title))
            })]
        })
    })
}
function PM() {
    return O.jsx("section", {
        className: "relative z-10 py-16 px-4",
        "data-yw": "c3JjL0FwcC50c3hANTA4OjQ",
        "data-yw-s": !0,
        children: O.jsxs("div", {
            className: "max-w-4xl mx-auto",
            "data-yw": "c3JjL0FwcC50c3hANTA5OjY",
            "data-yw-s": !0,
            children: [O.jsxs(In, {
                "data-yw": "c3JjL0FwcC50c3hANTEwOjg",
                "data-yw-s": !0,
                children: [O.jsx("div", {
                    className: "font-mono text-neon-green/50 text-xs mb-2 tracking-wider",
                    "data-yw": "c3JjL0FwcC50c3hANTExOjEw",
                    "data-yw-s": !0,
                    children: "// 05"
                }), O.jsxs("h3", {
                    className: "font-heading text-3xl tablet:text-4xl text-white font-bold tracking-wider mb-8",
                    "data-yw": "c3JjL0FwcC50c3hANTEyOjEw",
                    "data-yw-s": !0,
                    children: [O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hANTEyOjEwNQ",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "ACHIEVEMENTS"
                    }), O.jsx("span", {
                        className: "text-neon-green",
                        "data-yw": "c3JjL0FwcC50c3hANTEzOjI0",
                        "data-yw-t": !0,
                        "data-yw-s": !0,
                        children: "_"
                    }), O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hANTEzOjY2",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "UNLOCKED"
                    })]
                })]
            }), O.jsx(In, {
                "data-yw": "c3JjL0FwcC50c3hANTE2Ojg",
                "data-yw-s": !0,
                children: O.jsx("div", {
                    className: "grid tablet:grid-cols-2 gap-3",
                    "data-yw": "c3JjL0FwcC50c3hANTE3OjEw",
                    "data-yw-s": !0,
                    children: wM.map( (s, e) => O.jsxs("div", {
                        className: "neon-border bg-hud-card rounded-lg p-4 flex items-center gap-3 hover:bg-void-200 transition-colors",
                        "data-yw": "c3JjL0FwcC50c3hANTE5OjE0",
                        "data-yw-s": !0,
                        children: [O.jsx("div", {
                            className: "font-heading text-lg text-neon-green",
                            "data-yw": "c3JjL0FwcC50c3hANTIwOjE2",
                            "data-yw-t": !0,
                            "data-yw-s": !0,
                            children: ""
                        }), O.jsx("span", {
                            className: "font-body text-sm text-white/70",
                            "data-yw": "c3JjL0FwcC50c3hANTIxOjE2",
                            "data-yw-s": !0,
                            children: s
                        })]
                    }, e))
                })
            })]
        })
    })
}
function NM() {
    return O.jsx("section", {
        id: "contact",
        className: "relative z-10 py-24 px-4",
        "data-yw": "c3JjL0FwcC50c3hANTM0OjQ",
        "data-yw-s": !0,
        children: O.jsxs("div", {
            className: "max-w-3xl mx-auto text-center",
            "data-yw": "c3JjL0FwcC50c3hANTM1OjY",
            "data-yw-s": !0,
            children: [O.jsxs(In, {
                "data-yw": "c3JjL0FwcC50c3hANTM2Ojg",
                "data-yw-s": !0,
                children: [O.jsx("div", {
                    className: "font-mono text-neon-green/50 text-xs mb-2 tracking-wider",
                    "data-yw": "c3JjL0FwcC50c3hANTM3OjEw",
                    "data-yw-s": !0,
                    children: "// 06"
                }), O.jsxs("h3", {
                    className: "font-heading text-3xl tablet:text-4xl text-white font-bold tracking-wider mb-6",
                    "data-yw": "c3JjL0FwcC50c3hANTM4OjEw",
                    "data-yw-s": !0,
                    children: [O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hANTM4OjEwNQ",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "INIT"
                    }), O.jsx("span", {
                        className: "text-neon-green",
                        "data-yw": "c3JjL0FwcC50c3hANTM5OjE2",
                        "data-yw-t": !0,
                        "data-yw-s": !0,
                        children: "_"
                    }), O.jsx("span", {
                        "data-yw": "c3JjL0FwcC50c3hANTM5OjU4",
                        "data-yw-t": !0,
                        "data-yw-auto": !0,
                        children: "CONNECTION"
                    })]
                })]
            }), O.jsx(In, {
                "data-yw": "c3JjL0FwcC50c3hANTQzOjg",
                "data-yw-s": !0,
                children: O.jsxs("div", {
                    className: "neon-border hud-corners bg-hud-card rounded-lg p-8",
                    "data-yw": "c3JjL0FwcC50c3hANTQ0OjEw",
                    "data-yw-s": !0,
                    children: [O.jsxs("div", {
                        className: "font-mono text-sm text-white/40 mb-6 text-left",
                        "data-yw": "c3JjL0FwcC50c3hANTQ1OjEy",
                        "data-yw-s": !0,
                        children: [O.jsx("span", {
                            className: "text-neon-green",
                            "data-yw": "c3JjL0FwcC50c3hANTQ2OjE0",
                            "data-yw-t": !0,
                            "data-yw-s": !0,
                            children: "root@shriyash"
                        }), O.jsx("span", {
                            "data-yw": "c3JjL0FwcC50c3hANTQ2OjY4",
                            "data-yw-t": !0,
                            "data-yw-auto": !0,
                            children: ":"
                        }), O.jsx("span", {
                            className: "text-neon-cyan",
                            "data-yw": "c3JjL0FwcC50c3hANTQ2OjY5",
                            "data-yw-t": !0,
                            "data-yw-s": !0,
                            children: "~"
                        }), O.jsx("span", {
                            "data-yw": "c3JjL0FwcC50c3hANTQ2OjExMA",
                            "data-yw-t": !0,
                            "data-yw-auto": !0,
                            children: "$ cat contact_info.txt"
                        })]
                    }), O.jsxs("div", {
                        className: "space-y-4 text-left font-mono text-sm",
                        "data-yw": "c3JjL0FwcC50c3hANTQ4OjEy",
                        "data-yw-s": !0,
                        children: [O.jsxs("div", {
                            className: "flex flex-wrap items-center gap-2",
                            "data-yw": "c3JjL0FwcC50c3hANTQ5OjE0",
                            "data-yw-s": !0,
                            children: [O.jsx("span", {
                                className: "text-neon-green/60",
                                "data-yw": "c3JjL0FwcC50c3hANTUwOjE2",
                                "data-yw-t": !0,
                                "data-yw-s": !0,
                                children: "EMAIL:"
                            }), O.jsx("a", {
                                href: "mailto:shriyashsantoshsawant@gmail.com",
                                className: "text-neon-cyan hover:text-neon-green transition-colors break-all",
                                "data-yw": "c3JjL0FwcC50c3hANTUxOjE2",
                                "data-yw-t": !0,
                                "data-yw-s": !0,
                                "data-yw-l": !0,
                                children: "shriyashsantoshsawant@gmail.com"
                            })]
                        }), O.jsxs("div", {
                            className: "flex flex-wrap items-center gap-2",
                            "data-yw": "c3JjL0FwcC50c3hANTU1OjE0",
                            "data-yw-s": !0,
                            children: [O.jsx("span", {
                                className: "text-neon-green/60",
                                "data-yw": "c3JjL0FwcC50c3hANTU2OjE2",
                                "data-yw-t": !0,
                                "data-yw-s": !0,
                                children: "PHONE:"
                            }), O.jsx("span", {
                                className: "text-white/70",
                                "data-yw": "c3JjL0FwcC50c3hANTU3OjE2",
                                "data-yw-t": !0,
                                "data-yw-s": !0,
                                children: "+91 9511746917"
                            })]
                        }), O.jsxs("div", {
                            className: "flex flex-wrap items-center gap-2",
                            "data-yw": "c3JjL0FwcC50c3hANTU5OjE0",
                            "data-yw-s": !0,
                            children: [O.jsx("span", {
                                className: "text-neon-green/60",
                                "data-yw": "c3JjL0FwcC50c3hANTYwOjE2",
                                "data-yw-t": !0,
                                "data-yw-s": !0,
                                children: "LOCATION:"
                            }), O.jsx("span", {
                                className: "text-white/70",
                                "data-yw": "c3JjL0FwcC50c3hANTYxOjE2",
                                "data-yw-t": !0,
                                "data-yw-s": !0,
                                children: "Pune, India"
                            })]
                        }), O.jsxs("div", {
                            className: "flex flex-wrap items-center gap-2",
                            "data-yw": "c3JjL0FwcC50c3hANTYzOjE0",
                            "data-yw-s": !0,
                            children: [O.jsx("span", {
                                className: "text-neon-green/60",
                                "data-yw": "c3JjL0FwcC50c3hANTY0OjE2",
                                "data-yw-t": !0,
                                "data-yw-s": !0,
                                children: "LINKEDIN:"
                            }), O.jsx("a", {
                                href: "https://linkedin.com/in/shriyash-sawant-5a6a6120a",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                className: "text-neon-cyan hover:text-neon-green transition-colors break-all",
                                "data-yw": "c3JjL0FwcC50c3hANTY1OjE2",
                                "data-yw-t": !0,
                                "data-yw-s": !0,
                                "data-yw-l": !0,
                                children: "linkedin.com/in/shriyash-sawant-5a6a6120a"
                            })]
                        }), O.jsxs("div", {
                            className: "flex flex-wrap items-center gap-2",
                            "data-yw": "c3JjL0FwcC50c3hANTY5OjE0",
                            "data-yw-s": !0,
                            children: [O.jsx("span", {
                                className: "text-neon-green/60",
                                "data-yw": "c3JjL0FwcC50c3hANTcwOjE2",
                                "data-yw-t": !0,
                                "data-yw-s": !0,
                                children: "GITHUB:"
                            }), O.jsx("a", {
                                href: "https://github.com/shriyashsawant",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                className: "text-neon-cyan hover:text-neon-green transition-colors break-all",
                                "data-yw": "c3JjL0FwcC50c3hANTcxOjE2",
                                "data-yw-t": !0,
                                "data-yw-s": !0,
                                "data-yw-l": !0,
                                children: "github.com/shriyashsawant"
                            })]
                        })]
                    }), O.jsx("div", {
                        className: "mt-8 pt-6 border-t border-neon-green/10",
                        "data-yw": "c3JjL0FwcC50c3hANTc2OjEy",
                        "data-yw-s": !0,
                        children: O.jsx("div", {
                            className: "font-mono text-xs text-white/30 typing-cursor",
                            "data-yw": "c3JjL0FwcC50c3hANTc3OjE0",
                            "data-yw-t": !0,
                            "data-yw-s": !0,
                            children: "Ready to collaborate? Let's build something amazing together"
                        })
                    })]
                })
            }), O.jsx(In, {
                className: "mt-8",
                "data-yw": "c3JjL0FwcC50c3hANTg0Ojg",
                "data-yw-s": !0,
                children: O.jsxs("div", {
                    className: "flex justify-center gap-4",
                    "data-yw": "c3JjL0FwcC50c3hANTg1OjEw",
                    "data-yw-s": !0,
                    children: [O.jsx("a", {
                        href: "mailto:shriyashsantoshsawant@gmail.com",
                        className: "neon-border px-6 py-3 font-heading text-sm tracking-wider text-neon-green hover:bg-neon-green/10 transition-all hover:shadow-neon rounded-lg",
                        "data-yw": "c3JjL0FwcC50c3hANTg2OjEy",
                        "data-yw-t": !0,
                        "data-yw-s": !0,
                        "data-yw-l": !0,
                        children: "SEND_MESSAGE"
                    }), O.jsx("a", {
                        href: "https://linkedin.com/in/shriyash-sawant-5a6a6120a",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "neon-border-cyan px-6 py-3 font-heading text-sm tracking-wider text-neon-cyan hover:bg-neon-cyan/10 transition-all hover:shadow-neon-cyan rounded-lg",
                        "data-yw": "c3JjL0FwcC50c3hANTkyOjEy",
                        "data-yw-t": !0,
                        "data-yw-s": !0,
                        "data-yw-l": !0,
                        children: "LINKEDIN"
                    })]
                })
            })]
        })
    })
}
function DM() {
    return O.jsx("footer", {
        className: "relative z-10 py-8 px-4 border-t border-neon-green/5",
        "data-yw": "c3JjL0FwcC50c3hANjEwOjQ",
        "data-yw-s": !0,
        children: O.jsxs("div", {
            className: "max-w-4xl mx-auto text-center",
            "data-yw": "c3JjL0FwcC50c3hANjExOjY",
            "data-yw-s": !0,
            children: [O.jsx("div", {
                className: "font-mono text-xs text-white/20",
                "data-yw": "c3JjL0FwcC50c3hANjEyOjg",
                "data-yw-t": !0,
                "data-yw-s": !0,
                children: " 2026 SHRIYASH SAWANT  Crafted with code & creativity"
            }), O.jsx("div", {
                className: "font-mono text-[10px] text-neon-green/20 mt-1",
                "data-yw": "c3JjL0FwcC50c3hANjE1Ojg",
                "data-yw-t": !0,
                "data-yw-s": !0,
                children: "v1.0.0 // SHRIYASH.exe"
            })]
        })
    })
}
function IM() {
    const [s,e] = ln.useState(!0);
    return O.jsxs("div", {
        className: "scanline-overlay grid-bg",
        "data-yw": "c3JjL0FwcC50c3hANjI4OjQ",
        "data-yw-s": !0,
        children: [s && O.jsx(EM, {
            onComplete: () => e(!1),
            "data-yw": "c3JjL0FwcC50c3hANjI5OjE4",
            "data-yw-s": !0
        }), !s && O.jsxs(O.Fragment, {
            children: [O.jsx(vM, {
                "data-yw": "c3JjL0FwcC50c3hANjMzOjEw",
                "data-yw-s": !0,
                children: O.jsx(_M, {
                    "data-yw": "c3JjL0FwcC50c3hANjM0OjEy",
                    "data-yw-s": !0
                })
            }), O.jsx(TM, {
                "data-yw": "c3JjL0FwcC50c3hANjM2OjEw",
                "data-yw-s": !0
            }), O.jsxs("main", {
                className: "relative z-10",
                "data-yw": "c3JjL0FwcC50c3hANjM3OjEw",
                "data-yw-s": !0,
                children: [O.jsx(AM, {
                    "data-yw": "c3JjL0FwcC50c3hANjM4OjEy",
                    "data-yw-s": !0
                }), O.jsx(CM, {
                    "data-yw": "c3JjL0FwcC50c3hANjM5OjEy",
                    "data-yw-s": !0
                }), O.jsx(RM, {
                    "data-yw": "c3JjL0FwcC50c3hANjQwOjEy",
                    "data-yw-s": !0
                }), O.jsx(bM, {
                    "data-yw": "c3JjL0FwcC50c3hANjQxOjEy",
                    "data-yw-s": !0
                }), O.jsx(LM, {
                    "data-yw": "c3JjL0FwcC50c3hANjQyOjEy",
                    "data-yw-s": !0
                }), O.jsx(PM, {
                    "data-yw": "c3JjL0FwcC50c3hANjQzOjEy",
                    "data-yw-s": !0
                }), O.jsx(NM, {
                    "data-yw": "c3JjL0FwcC50c3hANjQ0OjEy",
                    "data-yw-s": !0
                })]
            }), O.jsx(DM, {
                "data-yw": "c3JjL0FwcC50c3hANjQ2OjEw",
                "data-yw-s": !0
            })]
        })]
    })
}
s_.createRoot(document.getElementById("root")).render(O.jsx(ln.StrictMode, {
    "data-yw": "c3JjL21haW4udHN4QDc6Mg",
    "data-yw-s": !0,
    children: O.jsx(IM, {
        "data-yw": "c3JjL21haW4udHN4QDg6NA",
        "data-yw-s": !0
    })
}));
//# sourceMappingURL=index-B__4FnpL.js.map
